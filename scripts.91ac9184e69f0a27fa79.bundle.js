webpackJsonp([4,5],{100:function(t,n){t.exports=function(t){"undefined"!=typeof execScript?execScript(t):eval.call(null,t)}},372:function(t,n,e){e(100)(e(658))},373:function(t,n,e){e(100)(e(659))},374:function(t,n,e){e(100)(e(660))},375:function(t,n,e){e(100)(e(661))},376:function(t,n,e){e(100)(e(662))},658:function(t,n){t.exports="/*!\n * Bootstrap v3.3.7 (http://getbootstrap.com)\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under the MIT license\n */\n\nif (typeof jQuery === 'undefined') {\n  throw new Error('Bootstrap\\'s JavaScript requires jQuery')\n}\n\n+function ($) {\n  'use strict';\n  var version = $.fn.jquery.split(' ')[0].split('.')\n  if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1) || (version[0] > 3)) {\n    throw new Error('Bootstrap\\'s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4')\n  }\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: transition.js v3.3.7\n * http://getbootstrap.com/javascript/#transitions\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)\n  // ============================================================\n\n  function transitionEnd() {\n    var el = document.createElement('bootstrap')\n\n    var transEndEventNames = {\n      WebkitTransition : 'webkitTransitionEnd',\n      MozTransition    : 'transitionend',\n      OTransition      : 'oTransitionEnd otransitionend',\n      transition       : 'transitionend'\n    }\n\n    for (var name in transEndEventNames) {\n      if (el.style[name] !== undefined) {\n        return { end: transEndEventNames[name] }\n      }\n    }\n\n    return false // explicit for ie8 (  ._.)\n  }\n\n  // http://blog.alexmaccaw.com/css-transitions\n  $.fn.emulateTransitionEnd = function (duration) {\n    var called = false\n    var $el = this\n    $(this).one('bsTransitionEnd', function () { called = true })\n    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }\n    setTimeout(callback, duration)\n    return this\n  }\n\n  $(function () {\n    $.support.transition = transitionEnd()\n\n    if (!$.support.transition) return\n\n    $.event.special.bsTransitionEnd = {\n      bindType: $.support.transition.end,\n      delegateType: $.support.transition.end,\n      handle: function (e) {\n        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)\n      }\n    }\n  })\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: alert.js v3.3.7\n * http://getbootstrap.com/javascript/#alerts\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // ALERT CLASS DEFINITION\n  // ======================\n\n  var dismiss = '[data-dismiss=\"alert\"]'\n  var Alert   = function (el) {\n    $(el).on('click', dismiss, this.close)\n  }\n\n  Alert.VERSION = '3.3.7'\n\n  Alert.TRANSITION_DURATION = 150\n\n  Alert.prototype.close = function (e) {\n    var $this    = $(this)\n    var selector = $this.attr('data-target')\n\n    if (!selector) {\n      selector = $this.attr('href')\n      selector = selector && selector.replace(/.*(?=#[^\\s]*$)/, '') // strip for ie7\n    }\n\n    var $parent = $(selector === '#' ? [] : selector)\n\n    if (e) e.preventDefault()\n\n    if (!$parent.length) {\n      $parent = $this.closest('.alert')\n    }\n\n    $parent.trigger(e = $.Event('close.bs.alert'))\n\n    if (e.isDefaultPrevented()) return\n\n    $parent.removeClass('in')\n\n    function removeElement() {\n      // detach from parent, fire event then clean up data\n      $parent.detach().trigger('closed.bs.alert').remove()\n    }\n\n    $.support.transition && $parent.hasClass('fade') ?\n      $parent\n        .one('bsTransitionEnd', removeElement)\n        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :\n      removeElement()\n  }\n\n\n  // ALERT PLUGIN DEFINITION\n  // =======================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this)\n      var data  = $this.data('bs.alert')\n\n      if (!data) $this.data('bs.alert', (data = new Alert(this)))\n      if (typeof option == 'string') data[option].call($this)\n    })\n  }\n\n  var old = $.fn.alert\n\n  $.fn.alert             = Plugin\n  $.fn.alert.Constructor = Alert\n\n\n  // ALERT NO CONFLICT\n  // =================\n\n  $.fn.alert.noConflict = function () {\n    $.fn.alert = old\n    return this\n  }\n\n\n  // ALERT DATA-API\n  // ==============\n\n  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: button.js v3.3.7\n * http://getbootstrap.com/javascript/#buttons\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // BUTTON PUBLIC CLASS DEFINITION\n  // ==============================\n\n  var Button = function (element, options) {\n    this.$element  = $(element)\n    this.options   = $.extend({}, Button.DEFAULTS, options)\n    this.isLoading = false\n  }\n\n  Button.VERSION  = '3.3.7'\n\n  Button.DEFAULTS = {\n    loadingText: 'loading...'\n  }\n\n  Button.prototype.setState = function (state) {\n    var d    = 'disabled'\n    var $el  = this.$element\n    var val  = $el.is('input') ? 'val' : 'html'\n    var data = $el.data()\n\n    state += 'Text'\n\n    if (data.resetText == null) $el.data('resetText', $el[val]())\n\n    // push to event loop to allow forms to submit\n    setTimeout($.proxy(function () {\n      $el[val](data[state] == null ? this.options[state] : data[state])\n\n      if (state == 'loadingText') {\n        this.isLoading = true\n        $el.addClass(d).attr(d, d).prop(d, true)\n      } else if (this.isLoading) {\n        this.isLoading = false\n        $el.removeClass(d).removeAttr(d).prop(d, false)\n      }\n    }, this), 0)\n  }\n\n  Button.prototype.toggle = function () {\n    var changed = true\n    var $parent = this.$element.closest('[data-toggle=\"buttons\"]')\n\n    if ($parent.length) {\n      var $input = this.$element.find('input')\n      if ($input.prop('type') == 'radio') {\n        if ($input.prop('checked')) changed = false\n        $parent.find('.active').removeClass('active')\n        this.$element.addClass('active')\n      } else if ($input.prop('type') == 'checkbox') {\n        if (($input.prop('checked')) !== this.$element.hasClass('active')) changed = false\n        this.$element.toggleClass('active')\n      }\n      $input.prop('checked', this.$element.hasClass('active'))\n      if (changed) $input.trigger('change')\n    } else {\n      this.$element.attr('aria-pressed', !this.$element.hasClass('active'))\n      this.$element.toggleClass('active')\n    }\n  }\n\n\n  // BUTTON PLUGIN DEFINITION\n  // ========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.button')\n      var options = typeof option == 'object' && option\n\n      if (!data) $this.data('bs.button', (data = new Button(this, options)))\n\n      if (option == 'toggle') data.toggle()\n      else if (option) data.setState(option)\n    })\n  }\n\n  var old = $.fn.button\n\n  $.fn.button             = Plugin\n  $.fn.button.Constructor = Button\n\n\n  // BUTTON NO CONFLICT\n  // ==================\n\n  $.fn.button.noConflict = function () {\n    $.fn.button = old\n    return this\n  }\n\n\n  // BUTTON DATA-API\n  // ===============\n\n  $(document)\n    .on('click.bs.button.data-api', '[data-toggle^=\"button\"]', function (e) {\n      var $btn = $(e.target).closest('.btn')\n      Plugin.call($btn, 'toggle')\n      if (!($(e.target).is('input[type=\"radio\"], input[type=\"checkbox\"]'))) {\n        // Prevent double click on radios, and the double selections (so cancellation) on checkboxes\n        e.preventDefault()\n        // The target component still receive the focus\n        if ($btn.is('input,button')) $btn.trigger('focus')\n        else $btn.find('input:visible,button:visible').first().trigger('focus')\n      }\n    })\n    .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^=\"button\"]', function (e) {\n      $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type))\n    })\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: carousel.js v3.3.7\n * http://getbootstrap.com/javascript/#carousel\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // CAROUSEL CLASS DEFINITION\n  // =========================\n\n  var Carousel = function (element, options) {\n    this.$element    = $(element)\n    this.$indicators = this.$element.find('.carousel-indicators')\n    this.options     = options\n    this.paused      = null\n    this.sliding     = null\n    this.interval    = null\n    this.$active     = null\n    this.$items      = null\n\n    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))\n\n    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element\n      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))\n      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))\n  }\n\n  Carousel.VERSION  = '3.3.7'\n\n  Carousel.TRANSITION_DURATION = 600\n\n  Carousel.DEFAULTS = {\n    interval: 5000,\n    pause: 'hover',\n    wrap: true,\n    keyboard: true\n  }\n\n  Carousel.prototype.keydown = function (e) {\n    if (/input|textarea/i.test(e.target.tagName)) return\n    switch (e.which) {\n      case 37: this.prev(); break\n      case 39: this.next(); break\n      default: return\n    }\n\n    e.preventDefault()\n  }\n\n  Carousel.prototype.cycle = function (e) {\n    e || (this.paused = false)\n\n    this.interval && clearInterval(this.interval)\n\n    this.options.interval\n      && !this.paused\n      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))\n\n    return this\n  }\n\n  Carousel.prototype.getItemIndex = function (item) {\n    this.$items = item.parent().children('.item')\n    return this.$items.index(item || this.$active)\n  }\n\n  Carousel.prototype.getItemForDirection = function (direction, active) {\n    var activeIndex = this.getItemIndex(active)\n    var willWrap = (direction == 'prev' && activeIndex === 0)\n                || (direction == 'next' && activeIndex == (this.$items.length - 1))\n    if (willWrap && !this.options.wrap) return active\n    var delta = direction == 'prev' ? -1 : 1\n    var itemIndex = (activeIndex + delta) % this.$items.length\n    return this.$items.eq(itemIndex)\n  }\n\n  Carousel.prototype.to = function (pos) {\n    var that        = this\n    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))\n\n    if (pos > (this.$items.length - 1) || pos < 0) return\n\n    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, \"slid\"\n    if (activeIndex == pos) return this.pause().cycle()\n\n    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))\n  }\n\n  Carousel.prototype.pause = function (e) {\n    e || (this.paused = true)\n\n    if (this.$element.find('.next, .prev').length && $.support.transition) {\n      this.$element.trigger($.support.transition.end)\n      this.cycle(true)\n    }\n\n    this.interval = clearInterval(this.interval)\n\n    return this\n  }\n\n  Carousel.prototype.next = function () {\n    if (this.sliding) return\n    return this.slide('next')\n  }\n\n  Carousel.prototype.prev = function () {\n    if (this.sliding) return\n    return this.slide('prev')\n  }\n\n  Carousel.prototype.slide = function (type, next) {\n    var $active   = this.$element.find('.item.active')\n    var $next     = next || this.getItemForDirection(type, $active)\n    var isCycling = this.interval\n    var direction = type == 'next' ? 'left' : 'right'\n    var that      = this\n\n    if ($next.hasClass('active')) return (this.sliding = false)\n\n    var relatedTarget = $next[0]\n    var slideEvent = $.Event('slide.bs.carousel', {\n      relatedTarget: relatedTarget,\n      direction: direction\n    })\n    this.$element.trigger(slideEvent)\n    if (slideEvent.isDefaultPrevented()) return\n\n    this.sliding = true\n\n    isCycling && this.pause()\n\n    if (this.$indicators.length) {\n      this.$indicators.find('.active').removeClass('active')\n      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])\n      $nextIndicator && $nextIndicator.addClass('active')\n    }\n\n    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, \"slid\"\n    if ($.support.transition && this.$element.hasClass('slide')) {\n      $next.addClass(type)\n      $next[0].offsetWidth // force reflow\n      $active.addClass(direction)\n      $next.addClass(direction)\n      $active\n        .one('bsTransitionEnd', function () {\n          $next.removeClass([type, direction].join(' ')).addClass('active')\n          $active.removeClass(['active', direction].join(' '))\n          that.sliding = false\n          setTimeout(function () {\n            that.$element.trigger(slidEvent)\n          }, 0)\n        })\n        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)\n    } else {\n      $active.removeClass('active')\n      $next.addClass('active')\n      this.sliding = false\n      this.$element.trigger(slidEvent)\n    }\n\n    isCycling && this.cycle()\n\n    return this\n  }\n\n\n  // CAROUSEL PLUGIN DEFINITION\n  // ==========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.carousel')\n      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)\n      var action  = typeof option == 'string' ? option : options.slide\n\n      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))\n      if (typeof option == 'number') data.to(option)\n      else if (action) data[action]()\n      else if (options.interval) data.pause().cycle()\n    })\n  }\n\n  var old = $.fn.carousel\n\n  $.fn.carousel             = Plugin\n  $.fn.carousel.Constructor = Carousel\n\n\n  // CAROUSEL NO CONFLICT\n  // ====================\n\n  $.fn.carousel.noConflict = function () {\n    $.fn.carousel = old\n    return this\n  }\n\n\n  // CAROUSEL DATA-API\n  // =================\n\n  var clickHandler = function (e) {\n    var href\n    var $this   = $(this)\n    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\\s]+$)/, '')) // strip for ie7\n    if (!$target.hasClass('carousel')) return\n    var options = $.extend({}, $target.data(), $this.data())\n    var slideIndex = $this.attr('data-slide-to')\n    if (slideIndex) options.interval = false\n\n    Plugin.call($target, options)\n\n    if (slideIndex) {\n      $target.data('bs.carousel').to(slideIndex)\n    }\n\n    e.preventDefault()\n  }\n\n  $(document)\n    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)\n    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)\n\n  $(window).on('load', function () {\n    $('[data-ride=\"carousel\"]').each(function () {\n      var $carousel = $(this)\n      Plugin.call($carousel, $carousel.data())\n    })\n  })\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: collapse.js v3.3.7\n * http://getbootstrap.com/javascript/#collapse\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n/* jshint latedef: false */\n\n+function ($) {\n  'use strict';\n\n  // COLLAPSE PUBLIC CLASS DEFINITION\n  // ================================\n\n  var Collapse = function (element, options) {\n    this.$element      = $(element)\n    this.options       = $.extend({}, Collapse.DEFAULTS, options)\n    this.$trigger      = $('[data-toggle=\"collapse\"][href=\"#' + element.id + '\"],' +\n                           '[data-toggle=\"collapse\"][data-target=\"#' + element.id + '\"]')\n    this.transitioning = null\n\n    if (this.options.parent) {\n      this.$parent = this.getParent()\n    } else {\n      this.addAriaAndCollapsedClass(this.$element, this.$trigger)\n    }\n\n    if (this.options.toggle) this.toggle()\n  }\n\n  Collapse.VERSION  = '3.3.7'\n\n  Collapse.TRANSITION_DURATION = 350\n\n  Collapse.DEFAULTS = {\n    toggle: true\n  }\n\n  Collapse.prototype.dimension = function () {\n    var hasWidth = this.$element.hasClass('width')\n    return hasWidth ? 'width' : 'height'\n  }\n\n  Collapse.prototype.show = function () {\n    if (this.transitioning || this.$element.hasClass('in')) return\n\n    var activesData\n    var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')\n\n    if (actives && actives.length) {\n      activesData = actives.data('bs.collapse')\n      if (activesData && activesData.transitioning) return\n    }\n\n    var startEvent = $.Event('show.bs.collapse')\n    this.$element.trigger(startEvent)\n    if (startEvent.isDefaultPrevented()) return\n\n    if (actives && actives.length) {\n      Plugin.call(actives, 'hide')\n      activesData || actives.data('bs.collapse', null)\n    }\n\n    var dimension = this.dimension()\n\n    this.$element\n      .removeClass('collapse')\n      .addClass('collapsing')[dimension](0)\n      .attr('aria-expanded', true)\n\n    this.$trigger\n      .removeClass('collapsed')\n      .attr('aria-expanded', true)\n\n    this.transitioning = 1\n\n    var complete = function () {\n      this.$element\n        .removeClass('collapsing')\n        .addClass('collapse in')[dimension]('')\n      this.transitioning = 0\n      this.$element\n        .trigger('shown.bs.collapse')\n    }\n\n    if (!$.support.transition) return complete.call(this)\n\n    var scrollSize = $.camelCase(['scroll', dimension].join('-'))\n\n    this.$element\n      .one('bsTransitionEnd', $.proxy(complete, this))\n      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])\n  }\n\n  Collapse.prototype.hide = function () {\n    if (this.transitioning || !this.$element.hasClass('in')) return\n\n    var startEvent = $.Event('hide.bs.collapse')\n    this.$element.trigger(startEvent)\n    if (startEvent.isDefaultPrevented()) return\n\n    var dimension = this.dimension()\n\n    this.$element[dimension](this.$element[dimension]())[0].offsetHeight\n\n    this.$element\n      .addClass('collapsing')\n      .removeClass('collapse in')\n      .attr('aria-expanded', false)\n\n    this.$trigger\n      .addClass('collapsed')\n      .attr('aria-expanded', false)\n\n    this.transitioning = 1\n\n    var complete = function () {\n      this.transitioning = 0\n      this.$element\n        .removeClass('collapsing')\n        .addClass('collapse')\n        .trigger('hidden.bs.collapse')\n    }\n\n    if (!$.support.transition) return complete.call(this)\n\n    this.$element\n      [dimension](0)\n      .one('bsTransitionEnd', $.proxy(complete, this))\n      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)\n  }\n\n  Collapse.prototype.toggle = function () {\n    this[this.$element.hasClass('in') ? 'hide' : 'show']()\n  }\n\n  Collapse.prototype.getParent = function () {\n    return $(this.options.parent)\n      .find('[data-toggle=\"collapse\"][data-parent=\"' + this.options.parent + '\"]')\n      .each($.proxy(function (i, element) {\n        var $element = $(element)\n        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)\n      }, this))\n      .end()\n  }\n\n  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {\n    var isOpen = $element.hasClass('in')\n\n    $element.attr('aria-expanded', isOpen)\n    $trigger\n      .toggleClass('collapsed', !isOpen)\n      .attr('aria-expanded', isOpen)\n  }\n\n  function getTargetFromTrigger($trigger) {\n    var href\n    var target = $trigger.attr('data-target')\n      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\\s]+$)/, '') // strip for ie7\n\n    return $(target)\n  }\n\n\n  // COLLAPSE PLUGIN DEFINITION\n  // ==========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.collapse')\n      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)\n\n      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false\n      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.collapse\n\n  $.fn.collapse             = Plugin\n  $.fn.collapse.Constructor = Collapse\n\n\n  // COLLAPSE NO CONFLICT\n  // ====================\n\n  $.fn.collapse.noConflict = function () {\n    $.fn.collapse = old\n    return this\n  }\n\n\n  // COLLAPSE DATA-API\n  // =================\n\n  $(document).on('click.bs.collapse.data-api', '[data-toggle=\"collapse\"]', function (e) {\n    var $this   = $(this)\n\n    if (!$this.attr('data-target')) e.preventDefault()\n\n    var $target = getTargetFromTrigger($this)\n    var data    = $target.data('bs.collapse')\n    var option  = data ? 'toggle' : $this.data()\n\n    Plugin.call($target, option)\n  })\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: dropdown.js v3.3.7\n * http://getbootstrap.com/javascript/#dropdowns\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // DROPDOWN CLASS DEFINITION\n  // =========================\n\n  var backdrop = '.dropdown-backdrop'\n  var toggle   = '[data-toggle=\"dropdown\"]'\n  var Dropdown = function (element) {\n    $(element).on('click.bs.dropdown', this.toggle)\n  }\n\n  Dropdown.VERSION = '3.3.7'\n\n  function getParent($this) {\n    var selector = $this.attr('data-target')\n\n    if (!selector) {\n      selector = $this.attr('href')\n      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\\s]*$)/, '') // strip for ie7\n    }\n\n    var $parent = selector && $(selector)\n\n    return $parent && $parent.length ? $parent : $this.parent()\n  }\n\n  function clearMenus(e) {\n    if (e && e.which === 3) return\n    $(backdrop).remove()\n    $(toggle).each(function () {\n      var $this         = $(this)\n      var $parent       = getParent($this)\n      var relatedTarget = { relatedTarget: this }\n\n      if (!$parent.hasClass('open')) return\n\n      if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return\n\n      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))\n\n      if (e.isDefaultPrevented()) return\n\n      $this.attr('aria-expanded', 'false')\n      $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget))\n    })\n  }\n\n  Dropdown.prototype.toggle = function (e) {\n    var $this = $(this)\n\n    if ($this.is('.disabled, :disabled')) return\n\n    var $parent  = getParent($this)\n    var isActive = $parent.hasClass('open')\n\n    clearMenus()\n\n    if (!isActive) {\n      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {\n        // if mobile we use a backdrop because click events don't delegate\n        $(document.createElement('div'))\n          .addClass('dropdown-backdrop')\n          .insertAfter($(this))\n          .on('click', clearMenus)\n      }\n\n      var relatedTarget = { relatedTarget: this }\n      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))\n\n      if (e.isDefaultPrevented()) return\n\n      $this\n        .trigger('focus')\n        .attr('aria-expanded', 'true')\n\n      $parent\n        .toggleClass('open')\n        .trigger($.Event('shown.bs.dropdown', relatedTarget))\n    }\n\n    return false\n  }\n\n  Dropdown.prototype.keydown = function (e) {\n    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return\n\n    var $this = $(this)\n\n    e.preventDefault()\n    e.stopPropagation()\n\n    if ($this.is('.disabled, :disabled')) return\n\n    var $parent  = getParent($this)\n    var isActive = $parent.hasClass('open')\n\n    if (!isActive && e.which != 27 || isActive && e.which == 27) {\n      if (e.which == 27) $parent.find(toggle).trigger('focus')\n      return $this.trigger('click')\n    }\n\n    var desc = ' li:not(.disabled):visible a'\n    var $items = $parent.find('.dropdown-menu' + desc)\n\n    if (!$items.length) return\n\n    var index = $items.index(e.target)\n\n    if (e.which == 38 && index > 0)                 index--         // up\n    if (e.which == 40 && index < $items.length - 1) index++         // down\n    if (!~index)                                    index = 0\n\n    $items.eq(index).trigger('focus')\n  }\n\n\n  // DROPDOWN PLUGIN DEFINITION\n  // ==========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this)\n      var data  = $this.data('bs.dropdown')\n\n      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))\n      if (typeof option == 'string') data[option].call($this)\n    })\n  }\n\n  var old = $.fn.dropdown\n\n  $.fn.dropdown             = Plugin\n  $.fn.dropdown.Constructor = Dropdown\n\n\n  // DROPDOWN NO CONFLICT\n  // ====================\n\n  $.fn.dropdown.noConflict = function () {\n    $.fn.dropdown = old\n    return this\n  }\n\n\n  // APPLY TO STANDARD DROPDOWN ELEMENTS\n  // ===================================\n\n  $(document)\n    .on('click.bs.dropdown.data-api', clearMenus)\n    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })\n    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)\n    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)\n    .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: modal.js v3.3.7\n * http://getbootstrap.com/javascript/#modals\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // MODAL CLASS DEFINITION\n  // ======================\n\n  var Modal = function (element, options) {\n    this.options             = options\n    this.$body               = $(document.body)\n    this.$element            = $(element)\n    this.$dialog             = this.$element.find('.modal-dialog')\n    this.$backdrop           = null\n    this.isShown             = null\n    this.originalBodyPad     = null\n    this.scrollbarWidth      = 0\n    this.ignoreBackdropClick = false\n\n    if (this.options.remote) {\n      this.$element\n        .find('.modal-content')\n        .load(this.options.remote, $.proxy(function () {\n          this.$element.trigger('loaded.bs.modal')\n        }, this))\n    }\n  }\n\n  Modal.VERSION  = '3.3.7'\n\n  Modal.TRANSITION_DURATION = 300\n  Modal.BACKDROP_TRANSITION_DURATION = 150\n\n  Modal.DEFAULTS = {\n    backdrop: true,\n    keyboard: true,\n    show: true\n  }\n\n  Modal.prototype.toggle = function (_relatedTarget) {\n    return this.isShown ? this.hide() : this.show(_relatedTarget)\n  }\n\n  Modal.prototype.show = function (_relatedTarget) {\n    var that = this\n    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })\n\n    this.$element.trigger(e)\n\n    if (this.isShown || e.isDefaultPrevented()) return\n\n    this.isShown = true\n\n    this.checkScrollbar()\n    this.setScrollbar()\n    this.$body.addClass('modal-open')\n\n    this.escape()\n    this.resize()\n\n    this.$element.on('click.dismiss.bs.modal', '[data-dismiss=\"modal\"]', $.proxy(this.hide, this))\n\n    this.$dialog.on('mousedown.dismiss.bs.modal', function () {\n      that.$element.one('mouseup.dismiss.bs.modal', function (e) {\n        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true\n      })\n    })\n\n    this.backdrop(function () {\n      var transition = $.support.transition && that.$element.hasClass('fade')\n\n      if (!that.$element.parent().length) {\n        that.$element.appendTo(that.$body) // don't move modals dom position\n      }\n\n      that.$element\n        .show()\n        .scrollTop(0)\n\n      that.adjustDialog()\n\n      if (transition) {\n        that.$element[0].offsetWidth // force reflow\n      }\n\n      that.$element.addClass('in')\n\n      that.enforceFocus()\n\n      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })\n\n      transition ?\n        that.$dialog // wait for modal to slide in\n          .one('bsTransitionEnd', function () {\n            that.$element.trigger('focus').trigger(e)\n          })\n          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :\n        that.$element.trigger('focus').trigger(e)\n    })\n  }\n\n  Modal.prototype.hide = function (e) {\n    if (e) e.preventDefault()\n\n    e = $.Event('hide.bs.modal')\n\n    this.$element.trigger(e)\n\n    if (!this.isShown || e.isDefaultPrevented()) return\n\n    this.isShown = false\n\n    this.escape()\n    this.resize()\n\n    $(document).off('focusin.bs.modal')\n\n    this.$element\n      .removeClass('in')\n      .off('click.dismiss.bs.modal')\n      .off('mouseup.dismiss.bs.modal')\n\n    this.$dialog.off('mousedown.dismiss.bs.modal')\n\n    $.support.transition && this.$element.hasClass('fade') ?\n      this.$element\n        .one('bsTransitionEnd', $.proxy(this.hideModal, this))\n        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :\n      this.hideModal()\n  }\n\n  Modal.prototype.enforceFocus = function () {\n    $(document)\n      .off('focusin.bs.modal') // guard against infinite focus loop\n      .on('focusin.bs.modal', $.proxy(function (e) {\n        if (document !== e.target &&\n            this.$element[0] !== e.target &&\n            !this.$element.has(e.target).length) {\n          this.$element.trigger('focus')\n        }\n      }, this))\n  }\n\n  Modal.prototype.escape = function () {\n    if (this.isShown && this.options.keyboard) {\n      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {\n        e.which == 27 && this.hide()\n      }, this))\n    } else if (!this.isShown) {\n      this.$element.off('keydown.dismiss.bs.modal')\n    }\n  }\n\n  Modal.prototype.resize = function () {\n    if (this.isShown) {\n      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))\n    } else {\n      $(window).off('resize.bs.modal')\n    }\n  }\n\n  Modal.prototype.hideModal = function () {\n    var that = this\n    this.$element.hide()\n    this.backdrop(function () {\n      that.$body.removeClass('modal-open')\n      that.resetAdjustments()\n      that.resetScrollbar()\n      that.$element.trigger('hidden.bs.modal')\n    })\n  }\n\n  Modal.prototype.removeBackdrop = function () {\n    this.$backdrop && this.$backdrop.remove()\n    this.$backdrop = null\n  }\n\n  Modal.prototype.backdrop = function (callback) {\n    var that = this\n    var animate = this.$element.hasClass('fade') ? 'fade' : ''\n\n    if (this.isShown && this.options.backdrop) {\n      var doAnimate = $.support.transition && animate\n\n      this.$backdrop = $(document.createElement('div'))\n        .addClass('modal-backdrop ' + animate)\n        .appendTo(this.$body)\n\n      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {\n        if (this.ignoreBackdropClick) {\n          this.ignoreBackdropClick = false\n          return\n        }\n        if (e.target !== e.currentTarget) return\n        this.options.backdrop == 'static'\n          ? this.$element[0].focus()\n          : this.hide()\n      }, this))\n\n      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow\n\n      this.$backdrop.addClass('in')\n\n      if (!callback) return\n\n      doAnimate ?\n        this.$backdrop\n          .one('bsTransitionEnd', callback)\n          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :\n        callback()\n\n    } else if (!this.isShown && this.$backdrop) {\n      this.$backdrop.removeClass('in')\n\n      var callbackRemove = function () {\n        that.removeBackdrop()\n        callback && callback()\n      }\n      $.support.transition && this.$element.hasClass('fade') ?\n        this.$backdrop\n          .one('bsTransitionEnd', callbackRemove)\n          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :\n        callbackRemove()\n\n    } else if (callback) {\n      callback()\n    }\n  }\n\n  // these following methods are used to handle overflowing modals\n\n  Modal.prototype.handleUpdate = function () {\n    this.adjustDialog()\n  }\n\n  Modal.prototype.adjustDialog = function () {\n    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight\n\n    this.$element.css({\n      paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',\n      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''\n    })\n  }\n\n  Modal.prototype.resetAdjustments = function () {\n    this.$element.css({\n      paddingLeft: '',\n      paddingRight: ''\n    })\n  }\n\n  Modal.prototype.checkScrollbar = function () {\n    var fullWindowWidth = window.innerWidth\n    if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8\n      var documentElementRect = document.documentElement.getBoundingClientRect()\n      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)\n    }\n    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth\n    this.scrollbarWidth = this.measureScrollbar()\n  }\n\n  Modal.prototype.setScrollbar = function () {\n    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)\n    this.originalBodyPad = document.body.style.paddingRight || ''\n    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)\n  }\n\n  Modal.prototype.resetScrollbar = function () {\n    this.$body.css('padding-right', this.originalBodyPad)\n  }\n\n  Modal.prototype.measureScrollbar = function () { // thx walsh\n    var scrollDiv = document.createElement('div')\n    scrollDiv.className = 'modal-scrollbar-measure'\n    this.$body.append(scrollDiv)\n    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth\n    this.$body[0].removeChild(scrollDiv)\n    return scrollbarWidth\n  }\n\n\n  // MODAL PLUGIN DEFINITION\n  // =======================\n\n  function Plugin(option, _relatedTarget) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.modal')\n      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)\n\n      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))\n      if (typeof option == 'string') data[option](_relatedTarget)\n      else if (options.show) data.show(_relatedTarget)\n    })\n  }\n\n  var old = $.fn.modal\n\n  $.fn.modal             = Plugin\n  $.fn.modal.Constructor = Modal\n\n\n  // MODAL NO CONFLICT\n  // =================\n\n  $.fn.modal.noConflict = function () {\n    $.fn.modal = old\n    return this\n  }\n\n\n  // MODAL DATA-API\n  // ==============\n\n  $(document).on('click.bs.modal.data-api', '[data-toggle=\"modal\"]', function (e) {\n    var $this   = $(this)\n    var href    = $this.attr('href')\n    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\\s]+$)/, ''))) // strip for ie7\n    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())\n\n    if ($this.is('a')) e.preventDefault()\n\n    $target.one('show.bs.modal', function (showEvent) {\n      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown\n      $target.one('hidden.bs.modal', function () {\n        $this.is(':visible') && $this.trigger('focus')\n      })\n    })\n    Plugin.call($target, option, this)\n  })\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: tooltip.js v3.3.7\n * http://getbootstrap.com/javascript/#tooltip\n * Inspired by the original jQuery.tipsy by Jason Frame\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // TOOLTIP PUBLIC CLASS DEFINITION\n  // ===============================\n\n  var Tooltip = function (element, options) {\n    this.type       = null\n    this.options    = null\n    this.enabled    = null\n    this.timeout    = null\n    this.hoverState = null\n    this.$element   = null\n    this.inState    = null\n\n    this.init('tooltip', element, options)\n  }\n\n  Tooltip.VERSION  = '3.3.7'\n\n  Tooltip.TRANSITION_DURATION = 150\n\n  Tooltip.DEFAULTS = {\n    animation: true,\n    placement: 'top',\n    selector: false,\n    template: '<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>',\n    trigger: 'hover focus',\n    title: '',\n    delay: 0,\n    html: false,\n    container: false,\n    viewport: {\n      selector: 'body',\n      padding: 0\n    }\n  }\n\n  Tooltip.prototype.init = function (type, element, options) {\n    this.enabled   = true\n    this.type      = type\n    this.$element  = $(element)\n    this.options   = this.getOptions(options)\n    this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport))\n    this.inState   = { click: false, hover: false, focus: false }\n\n    if (this.$element[0] instanceof document.constructor && !this.options.selector) {\n      throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!')\n    }\n\n    var triggers = this.options.trigger.split(' ')\n\n    for (var i = triggers.length; i--;) {\n      var trigger = triggers[i]\n\n      if (trigger == 'click') {\n        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))\n      } else if (trigger != 'manual') {\n        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'\n        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'\n\n        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))\n        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))\n      }\n    }\n\n    this.options.selector ?\n      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :\n      this.fixTitle()\n  }\n\n  Tooltip.prototype.getDefaults = function () {\n    return Tooltip.DEFAULTS\n  }\n\n  Tooltip.prototype.getOptions = function (options) {\n    options = $.extend({}, this.getDefaults(), this.$element.data(), options)\n\n    if (options.delay && typeof options.delay == 'number') {\n      options.delay = {\n        show: options.delay,\n        hide: options.delay\n      }\n    }\n\n    return options\n  }\n\n  Tooltip.prototype.getDelegateOptions = function () {\n    var options  = {}\n    var defaults = this.getDefaults()\n\n    this._options && $.each(this._options, function (key, value) {\n      if (defaults[key] != value) options[key] = value\n    })\n\n    return options\n  }\n\n  Tooltip.prototype.enter = function (obj) {\n    var self = obj instanceof this.constructor ?\n      obj : $(obj.currentTarget).data('bs.' + this.type)\n\n    if (!self) {\n      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())\n      $(obj.currentTarget).data('bs.' + this.type, self)\n    }\n\n    if (obj instanceof $.Event) {\n      self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true\n    }\n\n    if (self.tip().hasClass('in') || self.hoverState == 'in') {\n      self.hoverState = 'in'\n      return\n    }\n\n    clearTimeout(self.timeout)\n\n    self.hoverState = 'in'\n\n    if (!self.options.delay || !self.options.delay.show) return self.show()\n\n    self.timeout = setTimeout(function () {\n      if (self.hoverState == 'in') self.show()\n    }, self.options.delay.show)\n  }\n\n  Tooltip.prototype.isInStateTrue = function () {\n    for (var key in this.inState) {\n      if (this.inState[key]) return true\n    }\n\n    return false\n  }\n\n  Tooltip.prototype.leave = function (obj) {\n    var self = obj instanceof this.constructor ?\n      obj : $(obj.currentTarget).data('bs.' + this.type)\n\n    if (!self) {\n      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())\n      $(obj.currentTarget).data('bs.' + this.type, self)\n    }\n\n    if (obj instanceof $.Event) {\n      self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false\n    }\n\n    if (self.isInStateTrue()) return\n\n    clearTimeout(self.timeout)\n\n    self.hoverState = 'out'\n\n    if (!self.options.delay || !self.options.delay.hide) return self.hide()\n\n    self.timeout = setTimeout(function () {\n      if (self.hoverState == 'out') self.hide()\n    }, self.options.delay.hide)\n  }\n\n  Tooltip.prototype.show = function () {\n    var e = $.Event('show.bs.' + this.type)\n\n    if (this.hasContent() && this.enabled) {\n      this.$element.trigger(e)\n\n      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])\n      if (e.isDefaultPrevented() || !inDom) return\n      var that = this\n\n      var $tip = this.tip()\n\n      var tipId = this.getUID(this.type)\n\n      this.setContent()\n      $tip.attr('id', tipId)\n      this.$element.attr('aria-describedby', tipId)\n\n      if (this.options.animation) $tip.addClass('fade')\n\n      var placement = typeof this.options.placement == 'function' ?\n        this.options.placement.call(this, $tip[0], this.$element[0]) :\n        this.options.placement\n\n      var autoToken = /\\s?auto?\\s?/i\n      var autoPlace = autoToken.test(placement)\n      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'\n\n      $tip\n        .detach()\n        .css({ top: 0, left: 0, display: 'block' })\n        .addClass(placement)\n        .data('bs.' + this.type, this)\n\n      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)\n      this.$element.trigger('inserted.bs.' + this.type)\n\n      var pos          = this.getPosition()\n      var actualWidth  = $tip[0].offsetWidth\n      var actualHeight = $tip[0].offsetHeight\n\n      if (autoPlace) {\n        var orgPlacement = placement\n        var viewportDim = this.getPosition(this.$viewport)\n\n        placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top'    :\n                    placement == 'top'    && pos.top    - actualHeight < viewportDim.top    ? 'bottom' :\n                    placement == 'right'  && pos.right  + actualWidth  > viewportDim.width  ? 'left'   :\n                    placement == 'left'   && pos.left   - actualWidth  < viewportDim.left   ? 'right'  :\n                    placement\n\n        $tip\n          .removeClass(orgPlacement)\n          .addClass(placement)\n      }\n\n      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)\n\n      this.applyPlacement(calculatedOffset, placement)\n\n      var complete = function () {\n        var prevHoverState = that.hoverState\n        that.$element.trigger('shown.bs.' + that.type)\n        that.hoverState = null\n\n        if (prevHoverState == 'out') that.leave(that)\n      }\n\n      $.support.transition && this.$tip.hasClass('fade') ?\n        $tip\n          .one('bsTransitionEnd', complete)\n          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :\n        complete()\n    }\n  }\n\n  Tooltip.prototype.applyPlacement = function (offset, placement) {\n    var $tip   = this.tip()\n    var width  = $tip[0].offsetWidth\n    var height = $tip[0].offsetHeight\n\n    // manually read margins because getBoundingClientRect includes difference\n    var marginTop = parseInt($tip.css('margin-top'), 10)\n    var marginLeft = parseInt($tip.css('margin-left'), 10)\n\n    // we must check for NaN for ie 8/9\n    if (isNaN(marginTop))  marginTop  = 0\n    if (isNaN(marginLeft)) marginLeft = 0\n\n    offset.top  += marginTop\n    offset.left += marginLeft\n\n    // $.fn.offset doesn't round pixel values\n    // so we use setOffset directly with our own function B-0\n    $.offset.setOffset($tip[0], $.extend({\n      using: function (props) {\n        $tip.css({\n          top: Math.round(props.top),\n          left: Math.round(props.left)\n        })\n      }\n    }, offset), 0)\n\n    $tip.addClass('in')\n\n    // check to see if placing tip in new offset caused the tip to resize itself\n    var actualWidth  = $tip[0].offsetWidth\n    var actualHeight = $tip[0].offsetHeight\n\n    if (placement == 'top' && actualHeight != height) {\n      offset.top = offset.top + height - actualHeight\n    }\n\n    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)\n\n    if (delta.left) offset.left += delta.left\n    else offset.top += delta.top\n\n    var isVertical          = /top|bottom/.test(placement)\n    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight\n    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'\n\n    $tip.offset(offset)\n    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)\n  }\n\n  Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {\n    this.arrow()\n      .css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n      .css(isVertical ? 'top' : 'left', '')\n  }\n\n  Tooltip.prototype.setContent = function () {\n    var $tip  = this.tip()\n    var title = this.getTitle()\n\n    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)\n    $tip.removeClass('fade in top bottom left right')\n  }\n\n  Tooltip.prototype.hide = function (callback) {\n    var that = this\n    var $tip = $(this.$tip)\n    var e    = $.Event('hide.bs.' + this.type)\n\n    function complete() {\n      if (that.hoverState != 'in') $tip.detach()\n      if (that.$element) { // TODO: Check whether guarding this code with this `if` is really necessary.\n        that.$element\n          .removeAttr('aria-describedby')\n          .trigger('hidden.bs.' + that.type)\n      }\n      callback && callback()\n    }\n\n    this.$element.trigger(e)\n\n    if (e.isDefaultPrevented()) return\n\n    $tip.removeClass('in')\n\n    $.support.transition && $tip.hasClass('fade') ?\n      $tip\n        .one('bsTransitionEnd', complete)\n        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :\n      complete()\n\n    this.hoverState = null\n\n    return this\n  }\n\n  Tooltip.prototype.fixTitle = function () {\n    var $e = this.$element\n    if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {\n      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')\n    }\n  }\n\n  Tooltip.prototype.hasContent = function () {\n    return this.getTitle()\n  }\n\n  Tooltip.prototype.getPosition = function ($element) {\n    $element   = $element || this.$element\n\n    var el     = $element[0]\n    var isBody = el.tagName == 'BODY'\n\n    var elRect    = el.getBoundingClientRect()\n    if (elRect.width == null) {\n      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })\n    }\n    var isSvg = window.SVGElement && el instanceof window.SVGElement\n    // Avoid using $.offset() on SVGs since it gives incorrect results in jQuery 3.\n    // See https://github.com/twbs/bootstrap/issues/20280\n    var elOffset  = isBody ? { top: 0, left: 0 } : (isSvg ? null : $element.offset())\n    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }\n    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null\n\n    return $.extend({}, elRect, scroll, outerDims, elOffset)\n  }\n\n  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {\n    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2 } :\n           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } :\n           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :\n        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }\n\n  }\n\n  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {\n    var delta = { top: 0, left: 0 }\n    if (!this.$viewport) return delta\n\n    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0\n    var viewportDimensions = this.getPosition(this.$viewport)\n\n    if (/right|left/.test(placement)) {\n      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll\n      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight\n      if (topEdgeOffset < viewportDimensions.top) { // top overflow\n        delta.top = viewportDimensions.top - topEdgeOffset\n      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset\n      }\n    } else {\n      var leftEdgeOffset  = pos.left - viewportPadding\n      var rightEdgeOffset = pos.left + viewportPadding + actualWidth\n      if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n        delta.left = viewportDimensions.left - leftEdgeOffset\n      } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\n        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset\n      }\n    }\n\n    return delta\n  }\n\n  Tooltip.prototype.getTitle = function () {\n    var title\n    var $e = this.$element\n    var o  = this.options\n\n    title = $e.attr('data-original-title')\n      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)\n\n    return title\n  }\n\n  Tooltip.prototype.getUID = function (prefix) {\n    do prefix += ~~(Math.random() * 1000000)\n    while (document.getElementById(prefix))\n    return prefix\n  }\n\n  Tooltip.prototype.tip = function () {\n    if (!this.$tip) {\n      this.$tip = $(this.options.template)\n      if (this.$tip.length != 1) {\n        throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!')\n      }\n    }\n    return this.$tip\n  }\n\n  Tooltip.prototype.arrow = function () {\n    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))\n  }\n\n  Tooltip.prototype.enable = function () {\n    this.enabled = true\n  }\n\n  Tooltip.prototype.disable = function () {\n    this.enabled = false\n  }\n\n  Tooltip.prototype.toggleEnabled = function () {\n    this.enabled = !this.enabled\n  }\n\n  Tooltip.prototype.toggle = function (e) {\n    var self = this\n    if (e) {\n      self = $(e.currentTarget).data('bs.' + this.type)\n      if (!self) {\n        self = new this.constructor(e.currentTarget, this.getDelegateOptions())\n        $(e.currentTarget).data('bs.' + this.type, self)\n      }\n    }\n\n    if (e) {\n      self.inState.click = !self.inState.click\n      if (self.isInStateTrue()) self.enter(self)\n      else self.leave(self)\n    } else {\n      self.tip().hasClass('in') ? self.leave(self) : self.enter(self)\n    }\n  }\n\n  Tooltip.prototype.destroy = function () {\n    var that = this\n    clearTimeout(this.timeout)\n    this.hide(function () {\n      that.$element.off('.' + that.type).removeData('bs.' + that.type)\n      if (that.$tip) {\n        that.$tip.detach()\n      }\n      that.$tip = null\n      that.$arrow = null\n      that.$viewport = null\n      that.$element = null\n    })\n  }\n\n\n  // TOOLTIP PLUGIN DEFINITION\n  // =========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.tooltip')\n      var options = typeof option == 'object' && option\n\n      if (!data && /destroy|hide/.test(option)) return\n      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.tooltip\n\n  $.fn.tooltip             = Plugin\n  $.fn.tooltip.Constructor = Tooltip\n\n\n  // TOOLTIP NO CONFLICT\n  // ===================\n\n  $.fn.tooltip.noConflict = function () {\n    $.fn.tooltip = old\n    return this\n  }\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: popover.js v3.3.7\n * http://getbootstrap.com/javascript/#popovers\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // POPOVER PUBLIC CLASS DEFINITION\n  // ===============================\n\n  var Popover = function (element, options) {\n    this.init('popover', element, options)\n  }\n\n  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')\n\n  Popover.VERSION  = '3.3.7'\n\n  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {\n    placement: 'right',\n    trigger: 'click',\n    content: '',\n    template: '<div class=\"popover\" role=\"tooltip\"><div class=\"arrow\"></div><h3 class=\"popover-title\"></h3><div class=\"popover-content\"></div></div>'\n  })\n\n\n  // NOTE: POPOVER EXTENDS tooltip.js\n  // ================================\n\n  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)\n\n  Popover.prototype.constructor = Popover\n\n  Popover.prototype.getDefaults = function () {\n    return Popover.DEFAULTS\n  }\n\n  Popover.prototype.setContent = function () {\n    var $tip    = this.tip()\n    var title   = this.getTitle()\n    var content = this.getContent()\n\n    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)\n    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events\n      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'\n    ](content)\n\n    $tip.removeClass('fade top bottom left right in')\n\n    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do\n    // this manually by checking the contents.\n    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()\n  }\n\n  Popover.prototype.hasContent = function () {\n    return this.getTitle() || this.getContent()\n  }\n\n  Popover.prototype.getContent = function () {\n    var $e = this.$element\n    var o  = this.options\n\n    return $e.attr('data-content')\n      || (typeof o.content == 'function' ?\n            o.content.call($e[0]) :\n            o.content)\n  }\n\n  Popover.prototype.arrow = function () {\n    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))\n  }\n\n\n  // POPOVER PLUGIN DEFINITION\n  // =========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.popover')\n      var options = typeof option == 'object' && option\n\n      if (!data && /destroy|hide/.test(option)) return\n      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.popover\n\n  $.fn.popover             = Plugin\n  $.fn.popover.Constructor = Popover\n\n\n  // POPOVER NO CONFLICT\n  // ===================\n\n  $.fn.popover.noConflict = function () {\n    $.fn.popover = old\n    return this\n  }\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: scrollspy.js v3.3.7\n * http://getbootstrap.com/javascript/#scrollspy\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // SCROLLSPY CLASS DEFINITION\n  // ==========================\n\n  function ScrollSpy(element, options) {\n    this.$body          = $(document.body)\n    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)\n    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)\n    this.selector       = (this.options.target || '') + ' .nav li > a'\n    this.offsets        = []\n    this.targets        = []\n    this.activeTarget   = null\n    this.scrollHeight   = 0\n\n    this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))\n    this.refresh()\n    this.process()\n  }\n\n  ScrollSpy.VERSION  = '3.3.7'\n\n  ScrollSpy.DEFAULTS = {\n    offset: 10\n  }\n\n  ScrollSpy.prototype.getScrollHeight = function () {\n    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)\n  }\n\n  ScrollSpy.prototype.refresh = function () {\n    var that          = this\n    var offsetMethod  = 'offset'\n    var offsetBase    = 0\n\n    this.offsets      = []\n    this.targets      = []\n    this.scrollHeight = this.getScrollHeight()\n\n    if (!$.isWindow(this.$scrollElement[0])) {\n      offsetMethod = 'position'\n      offsetBase   = this.$scrollElement.scrollTop()\n    }\n\n    this.$body\n      .find(this.selector)\n      .map(function () {\n        var $el   = $(this)\n        var href  = $el.data('target') || $el.attr('href')\n        var $href = /^#./.test(href) && $(href)\n\n        return ($href\n          && $href.length\n          && $href.is(':visible')\n          && [[$href[offsetMethod]().top + offsetBase, href]]) || null\n      })\n      .sort(function (a, b) { return a[0] - b[0] })\n      .each(function () {\n        that.offsets.push(this[0])\n        that.targets.push(this[1])\n      })\n  }\n\n  ScrollSpy.prototype.process = function () {\n    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset\n    var scrollHeight = this.getScrollHeight()\n    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()\n    var offsets      = this.offsets\n    var targets      = this.targets\n    var activeTarget = this.activeTarget\n    var i\n\n    if (this.scrollHeight != scrollHeight) {\n      this.refresh()\n    }\n\n    if (scrollTop >= maxScroll) {\n      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)\n    }\n\n    if (activeTarget && scrollTop < offsets[0]) {\n      this.activeTarget = null\n      return this.clear()\n    }\n\n    for (i = offsets.length; i--;) {\n      activeTarget != targets[i]\n        && scrollTop >= offsets[i]\n        && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1])\n        && this.activate(targets[i])\n    }\n  }\n\n  ScrollSpy.prototype.activate = function (target) {\n    this.activeTarget = target\n\n    this.clear()\n\n    var selector = this.selector +\n      '[data-target=\"' + target + '\"],' +\n      this.selector + '[href=\"' + target + '\"]'\n\n    var active = $(selector)\n      .parents('li')\n      .addClass('active')\n\n    if (active.parent('.dropdown-menu').length) {\n      active = active\n        .closest('li.dropdown')\n        .addClass('active')\n    }\n\n    active.trigger('activate.bs.scrollspy')\n  }\n\n  ScrollSpy.prototype.clear = function () {\n    $(this.selector)\n      .parentsUntil(this.options.target, '.active')\n      .removeClass('active')\n  }\n\n\n  // SCROLLSPY PLUGIN DEFINITION\n  // ===========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.scrollspy')\n      var options = typeof option == 'object' && option\n\n      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.scrollspy\n\n  $.fn.scrollspy             = Plugin\n  $.fn.scrollspy.Constructor = ScrollSpy\n\n\n  // SCROLLSPY NO CONFLICT\n  // =====================\n\n  $.fn.scrollspy.noConflict = function () {\n    $.fn.scrollspy = old\n    return this\n  }\n\n\n  // SCROLLSPY DATA-API\n  // ==================\n\n  $(window).on('load.bs.scrollspy.data-api', function () {\n    $('[data-spy=\"scroll\"]').each(function () {\n      var $spy = $(this)\n      Plugin.call($spy, $spy.data())\n    })\n  })\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: tab.js v3.3.7\n * http://getbootstrap.com/javascript/#tabs\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // TAB CLASS DEFINITION\n  // ====================\n\n  var Tab = function (element) {\n    // jscs:disable requireDollarBeforejQueryAssignment\n    this.element = $(element)\n    // jscs:enable requireDollarBeforejQueryAssignment\n  }\n\n  Tab.VERSION = '3.3.7'\n\n  Tab.TRANSITION_DURATION = 150\n\n  Tab.prototype.show = function () {\n    var $this    = this.element\n    var $ul      = $this.closest('ul:not(.dropdown-menu)')\n    var selector = $this.data('target')\n\n    if (!selector) {\n      selector = $this.attr('href')\n      selector = selector && selector.replace(/.*(?=#[^\\s]*$)/, '') // strip for ie7\n    }\n\n    if ($this.parent('li').hasClass('active')) return\n\n    var $previous = $ul.find('.active:last a')\n    var hideEvent = $.Event('hide.bs.tab', {\n      relatedTarget: $this[0]\n    })\n    var showEvent = $.Event('show.bs.tab', {\n      relatedTarget: $previous[0]\n    })\n\n    $previous.trigger(hideEvent)\n    $this.trigger(showEvent)\n\n    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return\n\n    var $target = $(selector)\n\n    this.activate($this.closest('li'), $ul)\n    this.activate($target, $target.parent(), function () {\n      $previous.trigger({\n        type: 'hidden.bs.tab',\n        relatedTarget: $this[0]\n      })\n      $this.trigger({\n        type: 'shown.bs.tab',\n        relatedTarget: $previous[0]\n      })\n    })\n  }\n\n  Tab.prototype.activate = function (element, container, callback) {\n    var $active    = container.find('> .active')\n    var transition = callback\n      && $.support.transition\n      && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length)\n\n    function next() {\n      $active\n        .removeClass('active')\n        .find('> .dropdown-menu > .active')\n          .removeClass('active')\n        .end()\n        .find('[data-toggle=\"tab\"]')\n          .attr('aria-expanded', false)\n\n      element\n        .addClass('active')\n        .find('[data-toggle=\"tab\"]')\n          .attr('aria-expanded', true)\n\n      if (transition) {\n        element[0].offsetWidth // reflow for transition\n        element.addClass('in')\n      } else {\n        element.removeClass('fade')\n      }\n\n      if (element.parent('.dropdown-menu').length) {\n        element\n          .closest('li.dropdown')\n            .addClass('active')\n          .end()\n          .find('[data-toggle=\"tab\"]')\n            .attr('aria-expanded', true)\n      }\n\n      callback && callback()\n    }\n\n    $active.length && transition ?\n      $active\n        .one('bsTransitionEnd', next)\n        .emulateTransitionEnd(Tab.TRANSITION_DURATION) :\n      next()\n\n    $active.removeClass('in')\n  }\n\n\n  // TAB PLUGIN DEFINITION\n  // =====================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this)\n      var data  = $this.data('bs.tab')\n\n      if (!data) $this.data('bs.tab', (data = new Tab(this)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.tab\n\n  $.fn.tab             = Plugin\n  $.fn.tab.Constructor = Tab\n\n\n  // TAB NO CONFLICT\n  // ===============\n\n  $.fn.tab.noConflict = function () {\n    $.fn.tab = old\n    return this\n  }\n\n\n  // TAB DATA-API\n  // ============\n\n  var clickHandler = function (e) {\n    e.preventDefault()\n    Plugin.call($(this), 'show')\n  }\n\n  $(document)\n    .on('click.bs.tab.data-api', '[data-toggle=\"tab\"]', clickHandler)\n    .on('click.bs.tab.data-api', '[data-toggle=\"pill\"]', clickHandler)\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: affix.js v3.3.7\n * http://getbootstrap.com/javascript/#affix\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // AFFIX CLASS DEFINITION\n  // ======================\n\n  var Affix = function (element, options) {\n    this.options = $.extend({}, Affix.DEFAULTS, options)\n\n    this.$target = $(this.options.target)\n      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))\n      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))\n\n    this.$element     = $(element)\n    this.affixed      = null\n    this.unpin        = null\n    this.pinnedOffset = null\n\n    this.checkPosition()\n  }\n\n  Affix.VERSION  = '3.3.7'\n\n  Affix.RESET    = 'affix affix-top affix-bottom'\n\n  Affix.DEFAULTS = {\n    offset: 0,\n    target: window\n  }\n\n  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {\n    var scrollTop    = this.$target.scrollTop()\n    var position     = this.$element.offset()\n    var targetHeight = this.$target.height()\n\n    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false\n\n    if (this.affixed == 'bottom') {\n      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'\n      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'\n    }\n\n    var initializing   = this.affixed == null\n    var colliderTop    = initializing ? scrollTop : position.top\n    var colliderHeight = initializing ? targetHeight : height\n\n    if (offsetTop != null && scrollTop <= offsetTop) return 'top'\n    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'\n\n    return false\n  }\n\n  Affix.prototype.getPinnedOffset = function () {\n    if (this.pinnedOffset) return this.pinnedOffset\n    this.$element.removeClass(Affix.RESET).addClass('affix')\n    var scrollTop = this.$target.scrollTop()\n    var position  = this.$element.offset()\n    return (this.pinnedOffset = position.top - scrollTop)\n  }\n\n  Affix.prototype.checkPositionWithEventLoop = function () {\n    setTimeout($.proxy(this.checkPosition, this), 1)\n  }\n\n  Affix.prototype.checkPosition = function () {\n    if (!this.$element.is(':visible')) return\n\n    var height       = this.$element.height()\n    var offset       = this.options.offset\n    var offsetTop    = offset.top\n    var offsetBottom = offset.bottom\n    var scrollHeight = Math.max($(document).height(), $(document.body).height())\n\n    if (typeof offset != 'object')         offsetBottom = offsetTop = offset\n    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)\n    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)\n\n    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)\n\n    if (this.affixed != affix) {\n      if (this.unpin != null) this.$element.css('top', '')\n\n      var affixType = 'affix' + (affix ? '-' + affix : '')\n      var e         = $.Event(affixType + '.bs.affix')\n\n      this.$element.trigger(e)\n\n      if (e.isDefaultPrevented()) return\n\n      this.affixed = affix\n      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null\n\n      this.$element\n        .removeClass(Affix.RESET)\n        .addClass(affixType)\n        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')\n    }\n\n    if (affix == 'bottom') {\n      this.$element.offset({\n        top: scrollHeight - height - offsetBottom\n      })\n    }\n  }\n\n\n  // AFFIX PLUGIN DEFINITION\n  // =======================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.affix')\n      var options = typeof option == 'object' && option\n\n      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.affix\n\n  $.fn.affix             = Plugin\n  $.fn.affix.Constructor = Affix\n\n\n  // AFFIX NO CONFLICT\n  // =================\n\n  $.fn.affix.noConflict = function () {\n    $.fn.affix = old\n    return this\n  }\n\n\n  // AFFIX DATA-API\n  // ==============\n\n  $(window).on('load', function () {\n    $('[data-spy=\"affix\"]').each(function () {\n      var $spy = $(this)\n      var data = $spy.data()\n\n      data.offset = data.offset || {}\n\n      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom\n      if (data.offsetTop    != null) data.offset.top    = data.offsetTop\n\n      Plugin.call($spy, data)\n    })\n  })\n\n}(jQuery);\n";
},659:function(t,n){t.exports="// ==ClosureCompiler==\n// @compilation_level SIMPLE_OPTIMIZATIONS\n\n/**\n * @license Highcharts JS v4.2.7 (2016-09-21)\n *\n * (c) 2009-2016 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        module.exports = factory;\n    } else {\n        factory(Highcharts);\n    }\n}(function (Highcharts) {\nvar arrayMin = Highcharts.arrayMin,\n        arrayMax = Highcharts.arrayMax,\n        each = Highcharts.each,\n        extend = Highcharts.extend,\n        isNumber = Highcharts.isNumber,\n        merge = Highcharts.merge,\n        map = Highcharts.map,\n        pick = Highcharts.pick,\n        pInt = Highcharts.pInt,\n        correctFloat = Highcharts.correctFloat,\n        defaultPlotOptions = Highcharts.getOptions().plotOptions,\n        seriesTypes = Highcharts.seriesTypes,\n        extendClass = Highcharts.extendClass,\n        splat = Highcharts.splat,\n        wrap = Highcharts.wrap,\n        Axis = Highcharts.Axis,\n        Tick = Highcharts.Tick,\n        Point = Highcharts.Point,\n        Pointer = Highcharts.Pointer,\n        CenteredSeriesMixin = Highcharts.CenteredSeriesMixin,\n        TrackerMixin = Highcharts.TrackerMixin,\n        Series = Highcharts.Series,\n        math = Math,\n        mathRound = math.round,\n        mathFloor = math.floor,\n        mathMax = math.max,\n        Color = Highcharts.Color,\n        noop = function () {},\n        UNDEFINED;/**\n     * The Pane object allows options that are common to a set of X and Y axes.\n     *\n     * In the future, this can be extended to basic Highcharts and Highstock.\n     */\n    function Pane(options, chart, firstAxis) {\n        this.init(options, chart, firstAxis);\n    }\n\n    // Extend the Pane prototype\n    extend(Pane.prototype, {\n\n        /**\n         * Initiate the Pane object\n         */\n        init: function (options, chart, firstAxis) {\n            var pane = this,\n                backgroundOption,\n                defaultOptions = pane.defaultOptions;\n\n            pane.chart = chart;\n\n            // Set options. Angular charts have a default background (#3318)\n            pane.options = options = merge(defaultOptions, chart.angular ? { background: {} } : undefined, options);\n\n            backgroundOption = options.background;\n\n            // To avoid having weighty logic to place, update and remove the backgrounds,\n            // push them to the first axis' plot bands and borrow the existing logic there.\n            if (backgroundOption) {\n                each([].concat(splat(backgroundOption)).reverse(), function (config) {\n                    var backgroundColor = config.backgroundColor,  // if defined, replace the old one (specific for gradients)\n                        axisUserOptions = firstAxis.userOptions;\n                    config = merge(pane.defaultBackgroundOptions, config);\n                    if (backgroundColor) {\n                        config.backgroundColor = backgroundColor;\n                    }\n                    config.color = config.backgroundColor; // due to naming in plotBands\n                    firstAxis.options.plotBands.unshift(config);\n                    axisUserOptions.plotBands = axisUserOptions.plotBands || []; // #3176\n                    if (axisUserOptions.plotBands !== firstAxis.options.plotBands) {\n                        axisUserOptions.plotBands.unshift(config);\n                    }\n                });\n            }\n        },\n\n        /**\n         * The default options object\n         */\n        defaultOptions: {\n            // background: {conditional},\n            center: ['50%', '50%'],\n            size: '85%',\n            startAngle: 0\n            //endAngle: startAngle + 360\n        },\n\n        /**\n         * The default background options\n         */\n        defaultBackgroundOptions: {\n            shape: 'circle',\n            borderWidth: 1,\n            borderColor: 'silver',\n            backgroundColor: {\n                linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 },\n                stops: [\n                    [0, '#FFF'],\n                    [1, '#DDD']\n                ]\n            },\n            from: -Number.MAX_VALUE, // corrected to axis min\n            innerRadius: 0,\n            to: Number.MAX_VALUE, // corrected to axis max\n            outerRadius: '105%'\n        }\n    });\n\n    var axisProto = Axis.prototype,\n        tickProto = Tick.prototype;\n\n    /**\n     * Augmented methods for the x axis in order to hide it completely, used for the X axis in gauges\n     */\n    var hiddenAxisMixin = {\n        getOffset: noop,\n        redraw: function () {\n            this.isDirty = false; // prevent setting Y axis dirty\n        },\n        render: function () {\n            this.isDirty = false; // prevent setting Y axis dirty\n        },\n        setScale: noop,\n        setCategories: noop,\n        setTitle: noop\n    };\n\n    /**\n     * Augmented methods for the value axis\n     */\n    var radialAxisMixin = {\n        isRadial: true,\n\n        /**\n         * The default options extend defaultYAxisOptions\n         */\n        defaultRadialGaugeOptions: {\n            labels: {\n                align: 'center',\n                x: 0,\n                y: null // auto\n            },\n            minorGridLineWidth: 0,\n            minorTickInterval: 'auto',\n            minorTickLength: 10,\n            minorTickPosition: 'inside',\n            minorTickWidth: 1,\n            tickLength: 10,\n            tickPosition: 'inside',\n            tickWidth: 2,\n            title: {\n                rotation: 0\n            },\n            zIndex: 2 // behind dials, points in the series group\n        },\n\n        // Circular axis around the perimeter of a polar chart\n        defaultRadialXOptions: {\n            gridLineWidth: 1, // spokes\n            labels: {\n                align: null, // auto\n                distance: 15,\n                x: 0,\n                y: null // auto\n            },\n            maxPadding: 0,\n            minPadding: 0,\n            showLastLabel: false,\n            tickLength: 0\n        },\n\n        // Radial axis, like a spoke in a polar chart\n        defaultRadialYOptions: {\n            gridLineInterpolation: 'circle',\n            labels: {\n                align: 'right',\n                x: -3,\n                y: -2\n            },\n            showLastLabel: false,\n            title: {\n                x: 4,\n                text: null,\n                rotation: 90\n            }\n        },\n\n        /**\n         * Merge and set options\n         */\n        setOptions: function (userOptions) {\n\n            var options = this.options = merge(\n                this.defaultOptions,\n                this.defaultRadialOptions,\n                userOptions\n            );\n\n            // Make sure the plotBands array is instanciated for each Axis (#2649)\n            if (!options.plotBands) {\n                options.plotBands = [];\n            }\n\n        },\n\n        /**\n         * Wrap the getOffset method to return zero offset for title or labels in a radial\n         * axis\n         */\n        getOffset: function () {\n            // Call the Axis prototype method (the method we're in now is on the instance)\n            axisProto.getOffset.call(this);\n\n            // Title or label offsets are not counted\n            this.chart.axisOffset[this.side] = 0;\n\n            // Set the center array\n            this.center = this.pane.center = CenteredSeriesMixin.getCenter.call(this.pane);\n        },\n\n\n        /**\n         * Get the path for the axis line. This method is also referenced in the getPlotLinePath\n         * method.\n         */\n        getLinePath: function (lineWidth, radius) {\n            var center = this.center,\n                end,\n                chart = this.chart,\n                r = pick(radius, center[2] / 2 - this.offset),\n                path;\n\n            if (this.isCircular || radius !== undefined) {\n                path = this.chart.renderer.symbols.arc(\n                    this.left + center[0],\n                    this.top + center[1],\n                    r,\n                    r,\n                    {\n                        start: this.startAngleRad,\n                        end: this.endAngleRad,\n                        open: true,\n                        innerR: 0\n                    }\n                );\n            } else {\n                end = this.postTranslate(this.angleRad, r);\n                path = ['M', center[0] + chart.plotLeft, center[1] + chart.plotTop, 'L', end.x, end.y];\n            }\n            return path;\n        },\n\n        /**\n         * Override setAxisTranslation by setting the translation to the difference\n         * in rotation. This allows the translate method to return angle for\n         * any given value.\n         */\n        setAxisTranslation: function () {\n\n            // Call uber method\n            axisProto.setAxisTranslation.call(this);\n\n            // Set transA and minPixelPadding\n            if (this.center) { // it's not defined the first time\n                if (this.isCircular) {\n\n                    this.transA = (this.endAngleRad - this.startAngleRad) /\n                        ((this.max - this.min) || 1);\n\n\n                } else {\n                    this.transA = (this.center[2] / 2) / ((this.max - this.min) || 1);\n                }\n\n                if (this.isXAxis) {\n                    this.minPixelPadding = this.transA * this.minPointOffset;\n                } else {\n                    // This is a workaround for regression #2593, but categories still don't position correctly.\n                    this.minPixelPadding = 0;\n                }\n            }\n        },\n\n        /**\n         * In case of auto connect, add one closestPointRange to the max value right before\n         * tickPositions are computed, so that ticks will extend passed the real max.\n         */\n        beforeSetTickPositions: function () {\n            // If autoConnect is true, polygonal grid lines are connected, and one closestPointRange\n            // is added to the X axis to prevent the last point from overlapping the first.\n            this.autoConnect = this.isCircular && pick(this.userMax, this.options.max) === undefined &&\n                this.endAngleRad - this.startAngleRad === 2 * Math.PI;\n        \n            if (this.autoConnect) {\n                this.max += (this.categories && 1) || this.pointRange || this.closestPointRange || 0; // #1197, #2260\n            }\n        },\n\n        /**\n         * Override the setAxisSize method to use the arc's circumference as length. This\n         * allows tickPixelInterval to apply to pixel lengths along the perimeter\n         */\n        setAxisSize: function () {\n\n            axisProto.setAxisSize.call(this);\n\n            if (this.isRadial) {\n\n                // Set the center array\n                this.center = this.pane.center = Highcharts.CenteredSeriesMixin.getCenter.call(this.pane);\n\n                // The sector is used in Axis.translate to compute the translation of reversed axis points (#2570)\n                if (this.isCircular) {\n                    this.sector = this.endAngleRad - this.startAngleRad;\n                }\n\n                // Axis len is used to lay out the ticks\n                this.len = this.width = this.height = this.center[2] * pick(this.sector, 1) / 2;\n\n\n            }\n        },\n\n        /**\n         * Returns the x, y coordinate of a point given by a value and a pixel distance\n         * from center\n         */\n        getPosition: function (value, length) {\n            return this.postTranslate(\n                this.isCircular ? this.translate(value) : this.angleRad, // #2848\n                pick(this.isCircular ? length : this.translate(value), this.center[2] / 2) - this.offset\n            );\n        },\n\n        /**\n         * Translate from intermediate plotX (angle), plotY (axis.len - radius) to final chart coordinates.\n         */\n        postTranslate: function (angle, radius) {\n\n            var chart = this.chart,\n                center = this.center;\n\n            angle = this.startAngleRad + angle;\n\n            return {\n                x: chart.plotLeft + center[0] + Math.cos(angle) * radius,\n                y: chart.plotTop + center[1] + Math.sin(angle) * radius\n            };\n\n        },\n\n        /**\n         * Find the path for plot bands along the radial axis\n         */\n        getPlotBandPath: function (from, to, options) {\n            var center = this.center,\n                startAngleRad = this.startAngleRad,\n                fullRadius = center[2] / 2,\n                radii = [\n                    pick(options.outerRadius, '100%'),\n                    options.innerRadius,\n                    pick(options.thickness, 10)\n                ],\n                offset = Math.min(this.offset, 0),\n                percentRegex = /%$/,\n                start,\n                end,\n                open,\n                isCircular = this.isCircular, // X axis in a polar chart\n                ret;\n\n            // Polygonal plot bands\n            if (this.options.gridLineInterpolation === 'polygon') {\n                ret = this.getPlotLinePath(from).concat(this.getPlotLinePath(to, true));\n\n            // Circular grid bands\n            } else {\n\n                // Keep within bounds\n                from = Math.max(from, this.min);\n                to = Math.min(to, this.max);\n\n                // Plot bands on Y axis (radial axis) - inner and outer radius depend on to and from\n                if (!isCircular) {\n                    radii[0] = this.translate(from);\n                    radii[1] = this.translate(to);\n                }\n\n                // Convert percentages to pixel values\n                radii = map(radii, function (radius) {\n                    if (percentRegex.test(radius)) {\n                        radius = (pInt(radius, 10) * fullRadius) / 100;\n                    }\n                    return radius;\n                });\n\n                // Handle full circle\n                if (options.shape === 'circle' || !isCircular) {\n                    start = -Math.PI / 2;\n                    end = Math.PI * 1.5;\n                    open = true;\n                } else {\n                    start = startAngleRad + this.translate(from);\n                    end = startAngleRad + this.translate(to);\n                }\n\n                radii[0] -= offset; // #5283\n                radii[2] -= offset; // #5283\n\n                ret = this.chart.renderer.symbols.arc(\n                    this.left + center[0],\n                    this.top + center[1],\n                    radii[0],\n                    radii[0],\n                    {\n                        start: Math.min(start, end), // Math is for reversed yAxis (#3606)\n                        end: Math.max(start, end),\n                        innerR: pick(radii[1], radii[0] - radii[2]),\n                        open: open\n                    }\n                );\n            }\n\n            return ret;\n        },\n\n        /**\n         * Find the path for plot lines perpendicular to the radial axis.\n         */\n        getPlotLinePath: function (value, reverse) {\n            var axis = this,\n                center = axis.center,\n                chart = axis.chart,\n                end = axis.getPosition(value),\n                xAxis,\n                xy,\n                tickPositions,\n                ret;\n\n            // Spokes\n            if (axis.isCircular) {\n                ret = ['M', center[0] + chart.plotLeft, center[1] + chart.plotTop, 'L', end.x, end.y];\n\n            // Concentric circles\n            } else if (axis.options.gridLineInterpolation === 'circle') {\n                value = axis.translate(value);\n                if (value) { // a value of 0 is in the center\n                    ret = axis.getLinePath(0, value);\n                }\n            // Concentric polygons\n            } else {\n                // Find the X axis in the same pane\n                each(chart.xAxis, function (a) {\n                    if (a.pane === axis.pane) {\n                        xAxis = a;\n                    }\n                });\n                ret = [];\n                value = axis.translate(value);\n                tickPositions = xAxis.tickPositions;\n                if (xAxis.autoConnect) {\n                    tickPositions = tickPositions.concat([tickPositions[0]]);\n                }\n                // Reverse the positions for concatenation of polygonal plot bands\n                if (reverse) {\n                    tickPositions = [].concat(tickPositions).reverse();\n                }\n\n                each(tickPositions, function (pos, i) {\n                    xy = xAxis.getPosition(pos, value);\n                    ret.push(i ? 'L' : 'M', xy.x, xy.y);\n                });\n\n            }\n            return ret;\n        },\n\n        /**\n         * Find the position for the axis title, by default inside the gauge\n         */\n        getTitlePosition: function () {\n            var center = this.center,\n                chart = this.chart,\n                titleOptions = this.options.title;\n\n            return {\n                x: chart.plotLeft + center[0] + (titleOptions.x || 0),\n                y: chart.plotTop + center[1] - ({ high: 0.5, middle: 0.25, low: 0 }[titleOptions.align] *\n                    center[2]) + (titleOptions.y || 0)\n            };\n        }\n\n    };\n\n    /**\n     * Override axisProto.init to mix in special axis instance functions and function overrides\n     */\n    wrap(axisProto, 'init', function (proceed, chart, userOptions) {\n        var axis = this,\n            angular = chart.angular,\n            polar = chart.polar,\n            isX = userOptions.isX,\n            isHidden = angular && isX,\n            isCircular,\n            options,\n            chartOptions = chart.options,\n            paneIndex = userOptions.pane || 0,\n            pane,\n            paneOptions;\n\n        // Before prototype.init\n        if (angular) {\n            extend(this, isHidden ? hiddenAxisMixin : radialAxisMixin);\n            isCircular =  !isX;\n            if (isCircular) {\n                this.defaultRadialOptions = this.defaultRadialGaugeOptions;\n            }\n\n        } else if (polar) {\n            //extend(this, userOptions.isX ? radialAxisMixin : radialAxisMixin);\n            extend(this, radialAxisMixin);\n            isCircular = isX;\n            this.defaultRadialOptions = isX ? this.defaultRadialXOptions : merge(this.defaultYAxisOptions, this.defaultRadialYOptions);\n\n        }\n\n        // Disable certain features on angular and polar axes\n        if (angular || polar) {\n            chart.inverted = false;\n            chartOptions.chart.zoomType = null;\n        }\n\n        // Run prototype.init\n        proceed.call(this, chart, userOptions);\n\n        if (!isHidden && (angular || polar)) {\n            options = this.options;\n\n            // Create the pane and set the pane options.\n            if (!chart.panes) {\n                chart.panes = [];\n            }\n            this.pane = pane = chart.panes[paneIndex] = chart.panes[paneIndex] || new Pane(\n                splat(chartOptions.pane)[paneIndex],\n                chart,\n                axis\n            );\n            paneOptions = pane.options;\n\n            // Start and end angle options are\n            // given in degrees relative to top, while internal computations are\n            // in radians relative to right (like SVG).\n            this.angleRad = (options.angle || 0) * Math.PI / 180; // Y axis in polar charts\n            this.startAngleRad = (paneOptions.startAngle - 90) * Math.PI / 180; // Gauges\n            this.endAngleRad = (pick(paneOptions.endAngle, paneOptions.startAngle + 360)  - 90) * Math.PI / 180; // Gauges\n            this.offset = options.offset || 0;\n\n            this.isCircular = isCircular;\n\n        }\n\n    });\n\n    /**\n     * Wrap auto label align to avoid setting axis-wide rotation on radial axes (#4920)\n     * @param   {Function} proceed\n     * @returns {String} Alignment\n     */\n    wrap(axisProto, 'autoLabelAlign', function (proceed) {\n        if (!this.isRadial) {\n            return proceed.apply(this, [].slice.call(arguments, 1));\n        } // else return undefined\n    });\n\n    /**\n     * Add special cases within the Tick class' methods for radial axes.\n     */\n    wrap(tickProto, 'getPosition', function (proceed, horiz, pos, tickmarkOffset, old) {\n        var axis = this.axis;\n\n        return axis.getPosition ?\n            axis.getPosition(pos) :\n            proceed.call(this, horiz, pos, tickmarkOffset, old);\n    });\n\n    /**\n     * Wrap the getLabelPosition function to find the center position of the label\n     * based on the distance option\n     */\n    wrap(tickProto, 'getLabelPosition', function (proceed, x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {\n        var axis = this.axis,\n            optionsY = labelOptions.y,\n            ret,\n            centerSlot = 20, // 20 degrees to each side at the top and bottom\n            align = labelOptions.align,\n            angle = ((axis.translate(this.pos) + axis.startAngleRad + Math.PI / 2) / Math.PI * 180) % 360;\n\n        if (axis.isRadial) { // Both X and Y axes in a polar chart\n            ret = axis.getPosition(this.pos, (axis.center[2] / 2) + pick(labelOptions.distance, -25));\n\n            // Automatically rotated\n            if (labelOptions.rotation === 'auto') {\n                label.attr({\n                    rotation: angle\n                });\n\n            // Vertically centered\n            } else if (optionsY === null) {\n                optionsY = axis.chart.renderer.fontMetrics(label.styles.fontSize).b - label.getBBox().height / 2;\n            }\n\n            // Automatic alignment\n            if (align === null) {\n                if (axis.isCircular) { // Y axis\n                    if (this.label.getBBox().width > axis.len * axis.tickInterval / (axis.max - axis.min)) { // #3506\n                        centerSlot = 0;\n                    }\n                    if (angle > centerSlot && angle < 180 - centerSlot) {\n                        align = 'left'; // right hemisphere\n                    } else if (angle > 180 + centerSlot && angle < 360 - centerSlot) {\n                        align = 'right'; // left hemisphere\n                    } else {\n                        align = 'center'; // top or bottom\n                    }\n                } else {\n                    align = 'center';\n                }\n                label.attr({\n                    align: align\n                });\n            }\n\n            ret.x += labelOptions.x;\n            ret.y += optionsY;\n\n        } else {\n            ret = proceed.call(this, x, y, label, horiz, labelOptions, tickmarkOffset, index, step);\n        }\n        return ret;\n    });\n\n    /**\n     * Wrap the getMarkPath function to return the path of the radial marker\n     */\n    wrap(tickProto, 'getMarkPath', function (proceed, x, y, tickLength, tickWidth, horiz, renderer) {\n        var axis = this.axis,\n            endPoint,\n            ret;\n\n        if (axis.isRadial) {\n            endPoint = axis.getPosition(this.pos, axis.center[2] / 2 + tickLength);\n            ret = [\n                'M',\n                x,\n                y,\n                'L',\n                endPoint.x,\n                endPoint.y\n            ];\n        } else {\n            ret = proceed.call(this, x, y, tickLength, tickWidth, horiz, renderer);\n        }\n        return ret;\n    });\n    /*\n     * The AreaRangeSeries class\n     *\n     */\n\n    /**\n     * Extend the default options with map options\n     */\n    defaultPlotOptions.arearange = merge(defaultPlotOptions.area, {\n        lineWidth: 1,\n        marker: null,\n        threshold: null,\n        tooltip: {\n            pointFormat: '<span style=\"color:{series.color}\">\\u25CF</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'\n        },\n        trackByArea: true,\n        dataLabels: {\n            align: null,\n            verticalAlign: null,\n            xLow: 0,\n            xHigh: 0,\n            yLow: 0,\n            yHigh: 0\n        },\n        states: {\n            hover: {\n                halo: false\n            }\n        }\n    });\n\n    /**\n     * Add the series type\n     */\n    seriesTypes.arearange = extendClass(seriesTypes.area, {\n        type: 'arearange',\n        pointArrayMap: ['low', 'high'],\n        dataLabelCollections: ['dataLabel', 'dataLabelUpper'],\n        toYData: function (point) {\n            return [point.low, point.high];\n        },\n        pointValKey: 'low',\n        deferTranslatePolar: true,\n\n        /**\n         * Translate a point's plotHigh from the internal angle and radius measures to\n         * true plotHigh coordinates. This is an addition of the toXY method found in\n         * Polar.js, because it runs too early for arearanges to be considered (#3419).\n         */\n        highToXY: function (point) {\n            // Find the polar plotX and plotY\n            var chart = this.chart,\n                xy = this.xAxis.postTranslate(point.rectPlotX, this.yAxis.len - point.plotHigh);\n            point.plotHighX = xy.x - chart.plotLeft;\n            point.plotHigh = xy.y - chart.plotTop;\n        },\n\n        /**\n         * Translate data points from raw values x and y to plotX and plotY\n         */\n        translate: function () {\n            var series = this,\n                yAxis = series.yAxis;\n\n            seriesTypes.area.prototype.translate.apply(series);\n\n            // Set plotLow and plotHigh\n            each(series.points, function (point) {\n\n                var low = point.low,\n                    high = point.high,\n                    plotY = point.plotY;\n\n                if (high === null || low === null) {\n                    point.isNull = true;\n                } else {\n                    point.plotLow = plotY;\n                    point.plotHigh = yAxis.translate(high, 0, 1, 0, 1);\n                }\n            });\n\n            // Postprocess plotHigh\n            if (this.chart.polar) {\n                each(this.points, function (point) {\n                    series.highToXY(point);\n                });\n            }\n        },\n\n        /**\n         * Extend the line series' getSegmentPath method by applying the segment\n         * path to both lower and higher values of the range\n         */\n        getGraphPath: function (points) {\n        \n            var highPoints = [],\n                highAreaPoints = [],\n                i,\n                getGraphPath = seriesTypes.area.prototype.getGraphPath,\n                point,\n                pointShim,\n                linePath,\n                lowerPath,\n                options = this.options,\n                step = options.step,\n                higherPath,\n                higherAreaPath;\n\n            points = points || this.points;\n            i = points.length;\n\n            // Create the top line and the top part of the area fill. The area fill compensates for \n            // null points by drawing down to the lower graph, moving across the null gap and \n            // starting again at the lower graph.\n            i = points.length;\n            while (i--) {\n                point = points[i];\n        \n                if (!point.isNull && !options.connectEnds && (!points[i + 1] || points[i + 1].isNull)) {\n                    highAreaPoints.push({\n                        plotX: point.plotX,\n                        plotY: point.plotY,\n                        doCurve: false // #5186, gaps in areasplinerange fill\n                    });\n                }\n            \n                pointShim = {\n                    polarPlotY: point.polarPlotY,\n                    rectPlotX: point.rectPlotX,\n                    yBottom: point.yBottom,\n                    plotX: pick(point.plotHighX, point.plotX), // plotHighX is for polar charts\n                    plotY: point.plotHigh,\n                    isNull: point.isNull\n                };\n                highAreaPoints.push(pointShim);\n                highPoints.push(pointShim);\n                if (!point.isNull && !options.connectEnds && (!points[i - 1] || points[i - 1].isNull)) {\n                    highAreaPoints.push({\n                        plotX: point.plotX,\n                        plotY: point.plotY,\n                        doCurve: false // #5186, gaps in areasplinerange fill\n                    });\n                }\n            }\n\n            // Get the paths\n            lowerPath = getGraphPath.call(this, points);\n            if (step) {\n                if (step === true) {\n                    step = 'left';\n                }\n                options.step = { left: 'right', center: 'center', right: 'left' }[step]; // swap for reading in getGraphPath\n            }\n            higherPath = getGraphPath.call(this, highPoints);\n            higherAreaPath = getGraphPath.call(this, highAreaPoints);\n            options.step = step;\n\n            // Create a line on both top and bottom of the range\n            linePath = [].concat(lowerPath, higherPath);\n\n            // For the area path, we need to change the 'move' statement into 'lineTo' or 'curveTo'\n            if (!this.chart.polar && higherAreaPath[0] === 'M') {\n                higherAreaPath[0] = 'L'; // this probably doesn't work for spline        \n            }\n\n            this.graphPath = linePath;\n            this.areaPath = this.areaPath.concat(lowerPath, higherAreaPath);\n\n            // Prepare for sideways animation\n            linePath.isArea = true;\n            linePath.xMap = lowerPath.xMap;\n            this.areaPath.xMap = lowerPath.xMap;\n\n            return linePath;\n        },\n\n        /**\n         * Extend the basic drawDataLabels method by running it for both lower and higher\n         * values.\n         */\n        drawDataLabels: function () {\n\n            var data = this.data,\n                length = data.length,\n                i,\n                originalDataLabels = [],\n                seriesProto = Series.prototype,\n                dataLabelOptions = this.options.dataLabels,\n                align = dataLabelOptions.align,\n                verticalAlign = dataLabelOptions.verticalAlign,\n                inside = dataLabelOptions.inside,\n                point,\n                up,\n                inverted = this.chart.inverted;\n\n            if (dataLabelOptions.enabled || this._hasPointLabels) {\n\n                // Step 1: set preliminary values for plotY and dataLabel and draw the upper labels\n                i = length;\n                while (i--) {\n                    point = data[i];\n                    if (point) {\n                        up = inside ? point.plotHigh < point.plotLow : point.plotHigh > point.plotLow;\n\n                        // Set preliminary values\n                        point.y = point.high;\n                        point._plotY = point.plotY;\n                        point.plotY = point.plotHigh;\n\n                        // Store original data labels and set preliminary label objects to be picked up\n                        // in the uber method\n                        originalDataLabels[i] = point.dataLabel;\n                        point.dataLabel = point.dataLabelUpper;\n\n                        // Set the default offset\n                        point.below = up;\n                        if (inverted) {\n                            if (!align) {\n                                dataLabelOptions.align = up ? 'right' : 'left';\n                            }\n                        } else {\n                            if (!verticalAlign) {\n                                dataLabelOptions.verticalAlign = up ? 'top' : 'bottom';\n                            }\n                        }\n\n                        dataLabelOptions.x = dataLabelOptions.xHigh;\n                        dataLabelOptions.y = dataLabelOptions.yHigh;\n                    }\n                }\n\n                if (seriesProto.drawDataLabels) {\n                    seriesProto.drawDataLabels.apply(this, arguments); // #1209\n                }\n\n                // Step 2: reorganize and handle data labels for the lower values\n                i = length;\n                while (i--) {\n                    point = data[i];\n                    if (point) {\n                        up = inside ? point.plotHigh < point.plotLow : point.plotHigh > point.plotLow;\n\n                        // Move the generated labels from step 1, and reassign the original data labels\n                        point.dataLabelUpper = point.dataLabel;\n                        point.dataLabel = originalDataLabels[i];\n\n                        // Reset values\n                        point.y = point.low;\n                        point.plotY = point._plotY;\n\n                        // Set the default offset\n                        point.below = !up;\n                        if (inverted) {\n                            if (!align) {\n                                dataLabelOptions.align = up ? 'left' : 'right';\n                            }\n                        } else {\n                            if (!verticalAlign) {\n                                dataLabelOptions.verticalAlign = up ? 'bottom' : 'top';\n                            }\n                        \n                        }\n\n                        dataLabelOptions.x = dataLabelOptions.xLow;\n                        dataLabelOptions.y = dataLabelOptions.yLow;\n                    }\n                }\n                if (seriesProto.drawDataLabels) {\n                    seriesProto.drawDataLabels.apply(this, arguments);\n                }\n            }\n\n            dataLabelOptions.align = align;\n            dataLabelOptions.verticalAlign = verticalAlign;\n        },\n\n        alignDataLabel: function () {\n            seriesTypes.column.prototype.alignDataLabel.apply(this, arguments);\n        },\n\n        setStackedPoints: noop,\n\n        getSymbol: noop,\n\n        drawPoints: noop\n    });\n    /**\n     * The AreaSplineRangeSeries class\n     */\n\n    defaultPlotOptions.areasplinerange = merge(defaultPlotOptions.arearange);\n\n    /**\n     * AreaSplineRangeSeries object\n     */\n    seriesTypes.areasplinerange = extendClass(seriesTypes.arearange, {\n        type: 'areasplinerange',\n        getPointSpline: seriesTypes.spline.prototype.getPointSpline\n    });\n\n    (function () {\n\n        var colProto = seriesTypes.column.prototype;\n\n        /**\n         * The ColumnRangeSeries class\n         */\n        defaultPlotOptions.columnrange = merge(defaultPlotOptions.column, defaultPlotOptions.arearange, {\n            lineWidth: 1,\n            pointRange: null\n        });\n\n        /**\n         * ColumnRangeSeries object\n         */\n        seriesTypes.columnrange = extendClass(seriesTypes.arearange, {\n            type: 'columnrange',\n            /**\n             * Translate data points from raw values x and y to plotX and plotY\n             */\n            translate: function () {\n                var series = this,\n                    yAxis = series.yAxis,\n                    xAxis = series.xAxis,\n                    startAngleRad = xAxis.startAngleRad,\n                    start,\n                    chart = series.chart,\n                    isRadial = series.xAxis.isRadial,\n                    plotHigh;\n\n                colProto.translate.apply(series);\n\n                // Set plotLow and plotHigh\n                each(series.points, function (point) {\n                    var shapeArgs = point.shapeArgs,\n                        minPointLength = series.options.minPointLength,\n                        heightDifference,\n                        height,\n                        y;\n\n                    point.plotHigh = plotHigh = yAxis.translate(point.high, 0, 1, 0, 1);\n                    point.plotLow = point.plotY;\n\n                    // adjust shape\n                    y = plotHigh;\n                    height = pick(point.rectPlotY, point.plotY) - plotHigh;\n\n                    // Adjust for minPointLength\n                    if (Math.abs(height) < minPointLength) {\n                        heightDifference = (minPointLength - height);\n                        height += heightDifference;\n                        y -= heightDifference / 2;\n\n                    // Adjust for negative ranges or reversed Y axis (#1457)\n                    } else if (height < 0) {\n                        height *= -1;\n                        y -= height;\n                    }\n\n                    if (isRadial) {\n\n                        start = point.barX + startAngleRad;\n                        point.shapeType = 'path';\n                        point.shapeArgs = {\n                            d: series.polarArc(y + height, y, start, start + point.pointWidth)\n                        };\n                    } else {\n                        shapeArgs.height = height;\n                        shapeArgs.y = y;\n\n                        point.tooltipPos = chart.inverted ? \n                            [ \n                                yAxis.len + yAxis.pos - chart.plotLeft - y - height / 2, \n                                xAxis.len + xAxis.pos - chart.plotTop - shapeArgs.x - shapeArgs.width / 2, \n                                height\n                            ] : [\n                                xAxis.left - chart.plotLeft + shapeArgs.x + shapeArgs.width / 2, \n                                yAxis.pos - chart.plotTop + y + height / 2, \n                                height\n                            ]; // don't inherit from column tooltip position - #3372\n                    }\n                });\n            },\n            directTouch: true,\n            trackerGroups: ['group', 'dataLabelsGroup'],\n            drawGraph: noop,\n            crispCol: colProto.crispCol,\n            pointAttrToOptions: colProto.pointAttrToOptions,\n            drawPoints: colProto.drawPoints,\n            drawTracker: colProto.drawTracker,\n            getColumnMetrics: colProto.getColumnMetrics,\n            animate: function () {\n                return colProto.animate.apply(this, arguments);\n            },\n            polarArc: function () {\n                return colProto.polarArc.apply(this, arguments);\n            }\n        });\n    }());\n\n    /*\n     * The GaugeSeries class\n     */\n\n\n\n    /**\n     * Extend the default options\n     */\n    defaultPlotOptions.gauge = merge(defaultPlotOptions.line, {\n        dataLabels: {\n            enabled: true,\n            defer: false,\n            y: 15,\n            borderWidth: 1,\n            borderColor: 'silver',\n            borderRadius: 3,\n            crop: false,\n            verticalAlign: 'top',\n            zIndex: 2\n        },\n        dial: {\n            // radius: '80%',\n            // backgroundColor: 'black',\n            // borderColor: 'silver',\n            // borderWidth: 0,\n            // baseWidth: 3,\n            // topWidth: 1,\n            // baseLength: '70%' // of radius\n            // rearLength: '10%'\n        },\n        pivot: {\n            //radius: 5,\n            //borderWidth: 0\n            //borderColor: 'silver',\n            //backgroundColor: 'black'\n        },\n        tooltip: {\n            headerFormat: ''\n        },\n        showInLegend: false\n    });\n\n    /**\n     * Extend the point object\n     */\n    var GaugePoint = extendClass(Point, {\n        /**\n         * Don't do any hover colors or anything\n         */\n        setState: function (state) {\n            this.state = state;\n        }\n    });\n\n\n    /**\n     * Add the series type\n     */\n    var GaugeSeries = {\n        type: 'gauge',\n        pointClass: GaugePoint,\n\n        // chart.angular will be set to true when a gauge series is present, and this will\n        // be used on the axes\n        angular: true,\n        directTouch: true, // #5063\n        drawGraph: noop,\n        fixedBox: true,\n        forceDL: true,\n        noSharedTooltip: true,\n        trackerGroups: ['group', 'dataLabelsGroup'],\n\n        /**\n         * Calculate paths etc\n         */\n        translate: function () {\n\n            var series = this,\n                yAxis = series.yAxis,\n                options = series.options,\n                center = yAxis.center;\n\n            series.generatePoints();\n\n            each(series.points, function (point) {\n\n                var dialOptions = merge(options.dial, point.dial),\n                    radius = (pInt(pick(dialOptions.radius, 80)) * center[2]) / 200,\n                    baseLength = (pInt(pick(dialOptions.baseLength, 70)) * radius) / 100,\n                    rearLength = (pInt(pick(dialOptions.rearLength, 10)) * radius) / 100,\n                    baseWidth = dialOptions.baseWidth || 3,\n                    topWidth = dialOptions.topWidth || 1,\n                    overshoot = options.overshoot,\n                    rotation = yAxis.startAngleRad + yAxis.translate(point.y, null, null, null, true);\n\n                // Handle the wrap and overshoot options\n                if (isNumber(overshoot)) {\n                    overshoot = overshoot / 180 * Math.PI;\n                    rotation = Math.max(yAxis.startAngleRad - overshoot, Math.min(yAxis.endAngleRad + overshoot, rotation));\n\n                } else if (options.wrap === false) {\n                    rotation = Math.max(yAxis.startAngleRad, Math.min(yAxis.endAngleRad, rotation));\n                }\n\n                rotation = rotation * 180 / Math.PI;\n\n                point.shapeType = 'path';\n                point.shapeArgs = {\n                    d: dialOptions.path || [\n                        'M',\n                        -rearLength, -baseWidth / 2,\n                        'L',\n                        baseLength, -baseWidth / 2,\n                        radius, -topWidth / 2,\n                        radius, topWidth / 2,\n                        baseLength, baseWidth / 2,\n                        -rearLength, baseWidth / 2,\n                        'z'\n                    ],\n                    translateX: center[0],\n                    translateY: center[1],\n                    rotation: rotation\n                };\n\n                // Positions for data label\n                point.plotX = center[0];\n                point.plotY = center[1];\n            });\n        },\n\n        /**\n         * Draw the points where each point is one needle\n         */\n        drawPoints: function () {\n\n            var series = this,\n                center = series.yAxis.center,\n                pivot = series.pivot,\n                options = series.options,\n                pivotOptions = options.pivot,\n                renderer = series.chart.renderer;\n\n            each(series.points, function (point) {\n\n                var graphic = point.graphic,\n                    shapeArgs = point.shapeArgs,\n                    d = shapeArgs.d,\n                    dialOptions = merge(options.dial, point.dial); // #1233\n\n                if (graphic) {\n                    graphic.animate(shapeArgs);\n                    shapeArgs.d = d; // animate alters it\n                } else {\n                    point.graphic = renderer[point.shapeType](shapeArgs)\n                        .attr({\n                            stroke: dialOptions.borderColor || 'none',\n                            'stroke-width': dialOptions.borderWidth || 0,\n                            fill: dialOptions.backgroundColor || 'black',\n                            rotation: shapeArgs.rotation, // required by VML when animation is false\n                            zIndex: 1\n                        })\n                        .add(series.group);\n                }\n            });\n\n            // Add or move the pivot\n            if (pivot) {\n                pivot.animate({ // #1235\n                    translateX: center[0],\n                    translateY: center[1]\n                });\n            } else {\n                series.pivot = renderer.circle(0, 0, pick(pivotOptions.radius, 5))\n                    .attr({\n                        'stroke-width': pivotOptions.borderWidth || 0,\n                        stroke: pivotOptions.borderColor || 'silver',\n                        fill: pivotOptions.backgroundColor || 'black',\n                        zIndex: 2\n                    })\n                    .translate(center[0], center[1])\n                    .add(series.group);\n            }\n        },\n\n        /**\n         * Animate the arrow up from startAngle\n         */\n        animate: function (init) {\n            var series = this;\n\n            if (!init) {\n                each(series.points, function (point) {\n                    var graphic = point.graphic;\n\n                    if (graphic) {\n                        // start value\n                        graphic.attr({\n                            rotation: series.yAxis.startAngleRad * 180 / Math.PI\n                        });\n\n                        // animate\n                        graphic.animate({\n                            rotation: point.shapeArgs.rotation\n                        }, series.options.animation);\n                    }\n                });\n\n                // delete this function to allow it only once\n                series.animate = null;\n            }\n        },\n\n        render: function () {\n            this.group = this.plotGroup(\n                'group',\n                'series',\n                this.visible ? 'visible' : 'hidden',\n                this.options.zIndex,\n                this.chart.seriesGroup\n            );\n            Series.prototype.render.call(this);\n            this.group.clip(this.chart.clipRect);\n        },\n\n        /**\n         * Extend the basic setData method by running processData and generatePoints immediately,\n         * in order to access the points from the legend.\n         */\n        setData: function (data, redraw) {\n            Series.prototype.setData.call(this, data, false);\n            this.processData();\n            this.generatePoints();\n            if (pick(redraw, true)) {\n                this.chart.redraw();\n            }\n        },\n\n        /**\n         * If the tracking module is loaded, add the point tracker\n         */\n        drawTracker: TrackerMixin && TrackerMixin.drawTrackerPoint\n    };\n    seriesTypes.gauge = extendClass(seriesTypes.line, GaugeSeries);\n\n    /* ****************************************************************************\n     * Start Box plot series code                                                  *\n     *****************************************************************************/\n\n    // Set default options\n    defaultPlotOptions.boxplot = merge(defaultPlotOptions.column, {\n        fillColor: '#FFFFFF',\n        lineWidth: 1,\n        //medianColor: null,\n        medianWidth: 2,\n        states: {\n            hover: {\n                brightness: -0.3\n            }\n        },\n        //stemColor: null,\n        //stemDashStyle: 'solid'\n        //stemWidth: null,\n        threshold: null,\n        tooltip: {\n            pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> <b> {series.name}</b><br/>' +\n                'Maximum: {point.high}<br/>' +\n                'Upper quartile: {point.q3}<br/>' +\n                'Median: {point.median}<br/>' +\n                'Lower quartile: {point.q1}<br/>' +\n                'Minimum: {point.low}<br/>'\n\n        },\n        //whiskerColor: null,\n        whiskerLength: '50%',\n        whiskerWidth: 2\n    });\n\n    // Create the series object\n    seriesTypes.boxplot = extendClass(seriesTypes.column, {\n        type: 'boxplot',\n        pointArrayMap: ['low', 'q1', 'median', 'q3', 'high'], // array point configs are mapped to this\n        toYData: function (point) { // return a plain array for speedy calculation\n            return [point.low, point.q1, point.median, point.q3, point.high];\n        },\n        pointValKey: 'high', // defines the top of the tracker\n\n        /**\n         * One-to-one mapping from options to SVG attributes\n         */\n        pointAttrToOptions: { // mapping between SVG attributes and the corresponding options\n            fill: 'fillColor',\n            stroke: 'color',\n            'stroke-width': 'lineWidth'\n        },\n\n        /**\n         * Disable data labels for box plot\n         */\n        drawDataLabels: noop,\n\n        /**\n         * Translate data points from raw values x and y to plotX and plotY\n         */\n        translate: function () {\n            var series = this,\n                yAxis = series.yAxis,\n                pointArrayMap = series.pointArrayMap;\n\n            seriesTypes.column.prototype.translate.apply(series);\n\n            // do the translation on each point dimension\n            each(series.points, function (point) {\n                each(pointArrayMap, function (key) {\n                    if (point[key] !== null) {\n                        point[key + 'Plot'] = yAxis.translate(point[key], 0, 1, 0, 1);\n                    }\n                });\n            });\n        },\n\n        /**\n         * Draw the data points\n         */\n        drawPoints: function () {\n            var series = this,  //state = series.state,\n                points = series.points,\n                options = series.options,\n                chart = series.chart,\n                renderer = chart.renderer,\n                pointAttr,\n                q1Plot,\n                q3Plot,\n                highPlot,\n                lowPlot,\n                medianPlot,\n                crispCorr,\n                crispX,\n                graphic,\n                stemPath,\n                stemAttr,\n                boxPath,\n                whiskersPath,\n                whiskersAttr,\n                medianPath,\n                medianAttr,\n                width,\n                left,\n                right,\n                halfWidth,\n                shapeArgs,\n                color,\n                doQuartiles = series.doQuartiles !== false, // error bar inherits this series type but doesn't do quartiles\n                pointWiskerLength,\n                whiskerLength = series.options.whiskerLength;\n\n\n            each(points, function (point) {\n\n                graphic = point.graphic;\n                shapeArgs = point.shapeArgs; // the box\n                stemAttr = {};\n                whiskersAttr = {};\n                medianAttr = {};\n                color = point.color || series.color;\n\n                if (point.plotY !== UNDEFINED) {\n\n                    pointAttr = point.pointAttr[point.selected ? 'selected' : ''];\n\n                    // crisp vector coordinates\n                    width = shapeArgs.width;\n                    left = mathFloor(shapeArgs.x);\n                    right = left + width;\n                    halfWidth = mathRound(width / 2);\n                    //crispX = mathRound(left + halfWidth) + crispCorr;\n                    q1Plot = mathFloor(doQuartiles ? point.q1Plot : point.lowPlot);// + crispCorr;\n                    q3Plot = mathFloor(doQuartiles ? point.q3Plot : point.lowPlot);// + crispCorr;\n                    highPlot = mathFloor(point.highPlot);// + crispCorr;\n                    lowPlot = mathFloor(point.lowPlot);// + crispCorr;\n\n                    // Stem attributes\n                    stemAttr.stroke = point.stemColor || options.stemColor || color;\n                    stemAttr['stroke-width'] = pick(point.stemWidth, options.stemWidth, options.lineWidth);\n                    stemAttr.dashstyle = point.stemDashStyle || options.stemDashStyle;\n\n                    // Whiskers attributes\n                    whiskersAttr.stroke = point.whiskerColor || options.whiskerColor || color;\n                    whiskersAttr['stroke-width'] = pick(point.whiskerWidth, options.whiskerWidth, options.lineWidth);\n\n                    // Median attributes\n                    medianAttr.stroke = point.medianColor || options.medianColor || color;\n                    medianAttr['stroke-width'] = pick(point.medianWidth, options.medianWidth, options.lineWidth);\n\n                    // The stem\n                    crispCorr = (stemAttr['stroke-width'] % 2) / 2;\n                    crispX = left + halfWidth + crispCorr;\n                    stemPath = [\n                        // stem up\n                        'M',\n                        crispX, q3Plot,\n                        'L',\n                        crispX, highPlot,\n\n                        // stem down\n                        'M',\n                        crispX, q1Plot,\n                        'L',\n                        crispX, lowPlot\n                    ];\n\n                    // The box\n                    if (doQuartiles) {\n                        crispCorr = (pointAttr['stroke-width'] % 2) / 2;\n                        crispX = mathFloor(crispX) + crispCorr;\n                        q1Plot = mathFloor(q1Plot) + crispCorr;\n                        q3Plot = mathFloor(q3Plot) + crispCorr;\n                        left += crispCorr;\n                        right += crispCorr;\n                        boxPath = [\n                            'M',\n                            left, q3Plot,\n                            'L',\n                            left, q1Plot,\n                            'L',\n                            right, q1Plot,\n                            'L',\n                            right, q3Plot,\n                            'L',\n                            left, q3Plot,\n                            'z'\n                        ];\n                    }\n\n                    // The whiskers\n                    if (whiskerLength) {\n                        crispCorr = (whiskersAttr['stroke-width'] % 2) / 2;\n                        highPlot = highPlot + crispCorr;\n                        lowPlot = lowPlot + crispCorr;\n                        pointWiskerLength = (/%$/).test(whiskerLength) ? halfWidth * parseFloat(whiskerLength) / 100 : whiskerLength / 2;\n                        whiskersPath = [\n                            // High whisker\n                            'M',\n                            crispX - pointWiskerLength,\n                            highPlot,\n                            'L',\n                            crispX + pointWiskerLength,\n                            highPlot,\n\n                            // Low whisker\n                            'M',\n                            crispX - pointWiskerLength,\n                            lowPlot,\n                            'L',\n                            crispX + pointWiskerLength,\n                            lowPlot\n                        ];\n                    }\n\n                    // The median\n                    crispCorr = (medianAttr['stroke-width'] % 2) / 2;\n                    medianPlot = mathRound(point.medianPlot) + crispCorr;\n                    medianPath = [\n                        'M',\n                        left,\n                        medianPlot,\n                        'L',\n                        right,\n                        medianPlot\n                    ];\n\n                    // Create or update the graphics\n                    if (graphic) { // update\n\n                        point.stem.animate({ d: stemPath });\n                        if (whiskerLength) {\n                            point.whiskers.animate({ d: whiskersPath });\n                        }\n                        if (doQuartiles) {\n                            point.box.animate({ d: boxPath });\n                        }\n                        point.medianShape.animate({ d: medianPath });\n\n                    } else { // create new\n                        point.graphic = graphic = renderer.g()\n                            .add(series.group);\n\n                        point.stem = renderer.path(stemPath)\n                            .attr(stemAttr)\n                            .add(graphic);\n\n                        if (whiskerLength) {\n                            point.whiskers = renderer.path(whiskersPath)\n                                .attr(whiskersAttr)\n                                .add(graphic);\n                        }\n                        if (doQuartiles) {\n                            point.box = renderer.path(boxPath)\n                                .attr(pointAttr)\n                                .add(graphic);\n                        }\n                        point.medianShape = renderer.path(medianPath)\n                            .attr(medianAttr)\n                            .add(graphic);\n                    }\n                }\n            });\n\n        },\n        setStackedPoints: noop // #3890\n\n\n    });\n\n    /* ****************************************************************************\n     * End Box plot series code                                                *\n     *****************************************************************************/\n    /* ****************************************************************************\n     * Start error bar series code                                                *\n     *****************************************************************************/\n\n    // 1 - set default options\n    defaultPlotOptions.errorbar = merge(defaultPlotOptions.boxplot, {\n        color: '#000000',\n        grouping: false,\n        linkedTo: ':previous',\n        tooltip: {\n            pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'\n        },\n        whiskerWidth: null\n    });\n\n    // 2 - Create the series object\n    seriesTypes.errorbar = extendClass(seriesTypes.boxplot, {\n        type: 'errorbar',\n        pointArrayMap: ['low', 'high'], // array point configs are mapped to this\n        toYData: function (point) { // return a plain array for speedy calculation\n            return [point.low, point.high];\n        },\n        pointValKey: 'high', // defines the top of the tracker\n        doQuartiles: false,\n        drawDataLabels: seriesTypes.arearange ? function () {\n            var valKey = this.pointValKey;\n            seriesTypes.arearange.prototype.drawDataLabels.call(this);\n            // Arearange drawDataLabels does not reset point.y to high, but to low after drawing. #4133 \n            each(this.data, function (point) {\n                point.y = point[valKey];\n            });\n        } : noop,\n\n        /**\n         * Get the width and X offset, either on top of the linked series column\n         * or standalone\n         */\n        getColumnMetrics: function () {\n            return (this.linkedParent && this.linkedParent.columnMetrics) ||\n                seriesTypes.column.prototype.getColumnMetrics.call(this);\n        }\n    });\n\n    /* ****************************************************************************\n     * End error bar series code                                                  *\n     *****************************************************************************/\n    /* ****************************************************************************\n     * Start Waterfall series code                                                *\n     *****************************************************************************/\n\n    // 1 - set default options\n    defaultPlotOptions.waterfall = merge(defaultPlotOptions.column, {\n        lineWidth: 1,\n        lineColor: '#333',\n        dashStyle: 'dot',\n        borderColor: '#333',\n        dataLabels: {\n            inside: true\n        },\n        states: {\n            hover: {\n                lineWidthPlus: 0 // #3126\n            }\n        }\n    });\n\n\n    // 2 - Create the series object\n    seriesTypes.waterfall = extendClass(seriesTypes.column, {\n        type: 'waterfall',\n\n        upColorProp: 'fill',\n\n        pointValKey: 'y',\n\n        /**\n         * Pass the null test in ColumnSeries.translate.\n         */\n        pointClass: extendClass(Point, {\n            isValid: function () {\n                return isNumber(this.y, true) || this.isSum || this.isIntermediateSum;\n            }\n        }),\n\n        /**\n         * Translate data points from raw values\n         */\n        translate: function () {\n            var series = this,\n                options = series.options,\n                yAxis = series.yAxis,\n                len,\n                i,\n                points,\n                point,\n                shapeArgs,\n                stack,\n                y,\n                yValue,\n                previousY,\n                previousIntermediate,\n                range,\n                minPointLength = pick(options.minPointLength, 5),\n                threshold = options.threshold,\n                stacking = options.stacking,\n                tooltipY;\n\n            // run column series translate\n            seriesTypes.column.prototype.translate.apply(this);\n            series.minPointLengthOffset = 0;\n\n            previousY = previousIntermediate = threshold;\n            points = series.points;\n\n            for (i = 0, len = points.length; i < len; i++) {\n                // cache current point object\n                point = points[i];\n                yValue = this.processedYData[i];\n                shapeArgs = point.shapeArgs;\n\n                // get current stack\n                stack = stacking && yAxis.stacks[(series.negStacks && yValue < threshold ? '-' : '') + series.stackKey];\n                range = stack ?\n                    stack[point.x].points[series.index + ',' + i] :\n                    [0, yValue];\n\n                // override point value for sums\n                // #3710 Update point does not propagate to sum\n                if (point.isSum) {\n                    point.y = correctFloat(yValue);\n                } else if (point.isIntermediateSum) {\n                    point.y = correctFloat(yValue - previousIntermediate); // #3840\n                }\n                // up points\n                y = mathMax(previousY, previousY + point.y) + range[0];\n                shapeArgs.y = yAxis.toPixels(y, true);\n\n\n                // sum points\n                if (point.isSum) {\n                    shapeArgs.y = yAxis.toPixels(range[1], true);\n                    shapeArgs.height = Math.min(yAxis.toPixels(range[0], true), yAxis.len) - shapeArgs.y + series.minPointLengthOffset; // #4256\n\n                } else if (point.isIntermediateSum) {\n                    shapeArgs.y = yAxis.toPixels(range[1], true);\n                    shapeArgs.height = Math.min(yAxis.toPixels(previousIntermediate, true), yAxis.len) - shapeArgs.y + series.minPointLengthOffset;\n                    previousIntermediate = range[1];\n\n                // If it's not the sum point, update previous stack end position and get\n                // shape height (#3886)\n                } else {\n                    shapeArgs.height = yValue > 0 ?\n                        yAxis.toPixels(previousY, true) - shapeArgs.y :\n                        yAxis.toPixels(previousY, true) - yAxis.toPixels(previousY - yValue, true);\n                    previousY += yValue;\n                }\n                // #3952 Negative sum or intermediate sum not rendered correctly\n                if (shapeArgs.height < 0) {\n                    shapeArgs.y += shapeArgs.height;\n                    shapeArgs.height *= -1;\n                }\n\n                point.plotY = shapeArgs.y = mathRound(shapeArgs.y) - (series.borderWidth % 2) / 2;\n                shapeArgs.height = mathMax(mathRound(shapeArgs.height), 0.001); // #3151\n                point.yBottom = shapeArgs.y + shapeArgs.height;\n\n                if (shapeArgs.height <= minPointLength) {\n                    shapeArgs.height = minPointLength;\n                    series.minPointLengthOffset += minPointLength;\n                }\n\n                shapeArgs.y -= series.minPointLengthOffset;\n\n                // Correct tooltip placement (#3014)\n                tooltipY = point.plotY + (point.negative ? shapeArgs.height : 0) - series.minPointLengthOffset;\n                if (series.chart.inverted) {\n                    point.tooltipPos[0] = yAxis.len - tooltipY;\n                } else {\n                    point.tooltipPos[1] = tooltipY;\n                }\n\n            }\n        },\n\n        /**\n         * Call default processData then override yData to reflect waterfall's extremes on yAxis\n         */\n        processData: function (force) {\n            var series = this,\n                options = series.options,\n                yData = series.yData,\n                points = series.options.data, // #3710 Update point does not propagate to sum\n                point,\n                dataLength = yData.length,\n                threshold = options.threshold || 0,\n                subSum,\n                sum,\n                dataMin,\n                dataMax,\n                y,\n                i;\n\n            sum = subSum = dataMin = dataMax = threshold;\n\n            for (i = 0; i < dataLength; i++) {\n                y = yData[i];\n                point = points && points[i] ? points[i] : {};\n\n                if (y === 'sum' || point.isSum) {\n                    yData[i] = correctFloat(sum);\n                } else if (y === 'intermediateSum' || point.isIntermediateSum) {\n                    yData[i] = correctFloat(subSum);\n                } else {\n                    sum += y;\n                    subSum += y;\n                }\n                dataMin = Math.min(sum, dataMin);\n                dataMax = Math.max(sum, dataMax);\n            }\n\n            Series.prototype.processData.call(this, force);\n\n            // Record extremes\n            series.dataMin = dataMin;\n            series.dataMax = dataMax;\n        },\n\n        /**\n         * Return y value or string if point is sum\n         */\n        toYData: function (pt) {\n            if (pt.isSum) {\n                return (pt.x === 0 ? null : 'sum'); //#3245 Error when first element is Sum or Intermediate Sum\n            }\n            if (pt.isIntermediateSum) {\n                return (pt.x === 0 ? null : 'intermediateSum'); //#3245\n            }\n            return pt.y;\n        },\n\n        /**\n         * Postprocess mapping between options and SVG attributes\n         */\n        getAttribs: function () {\n            seriesTypes.column.prototype.getAttribs.apply(this, arguments);\n\n            var series = this,\n                options = series.options,\n                stateOptions = options.states,\n                upColor = options.upColor || series.color,\n                hoverColor = Highcharts.Color(upColor).brighten(options.states.hover.brightness).get(),\n                seriesDownPointAttr = merge(series.pointAttr),\n                upColorProp = series.upColorProp;\n\n            seriesDownPointAttr[''][upColorProp] = upColor;\n            seriesDownPointAttr.hover[upColorProp] = stateOptions.hover.upColor || hoverColor;\n            seriesDownPointAttr.select[upColorProp] = stateOptions.select.upColor || upColor;\n\n            each(series.points, function (point) {\n                if (!point.options.color) {\n                    // Up color\n                    if (point.y > 0) {\n                        point.pointAttr = seriesDownPointAttr;\n                        point.color = upColor;\n\n                    // Down color (#3710, update to negative)\n                    } else {\n                        point.pointAttr = series.pointAttr;\n                    }\n                }\n            });\n        },\n\n        /**\n         * Draw columns' connector lines\n         */\n        getGraphPath: function () {\n\n            var data = this.data,\n                length = data.length,\n                lineWidth = this.options.lineWidth + this.borderWidth,\n                normalizer = mathRound(lineWidth) % 2 / 2,\n                path = [],\n                M = 'M',\n                L = 'L',\n                prevArgs,\n                pointArgs,\n                i,\n                d;\n\n            for (i = 1; i < length; i++) {\n                pointArgs = data[i].shapeArgs;\n                prevArgs = data[i - 1].shapeArgs;\n\n                d = [\n                    M,\n                    prevArgs.x + prevArgs.width, prevArgs.y + normalizer,\n                    L,\n                    pointArgs.x, prevArgs.y + normalizer\n                ];\n\n                if (data[i - 1].y < 0) {\n                    d[2] += prevArgs.height;\n                    d[5] += prevArgs.height;\n                }\n\n                path = path.concat(d);\n            }\n\n            return path;\n        },\n\n        /**\n         * Extremes are recorded in processData\n         */\n        getExtremes: noop,\n\n        drawGraph: Series.prototype.drawGraph\n    });\n\n    /* ****************************************************************************\n     * End Waterfall series code                                                  *\n     *****************************************************************************/\n    /**\n     * Set the default options for polygon\n     */\n    defaultPlotOptions.polygon = merge(defaultPlotOptions.scatter, {\n        marker: {\n            enabled: false,\n            states: {\n                hover: {\n                    enabled: false\n                }\n            }\n        },\n        stickyTracking: false,\n        tooltip: {\n            followPointer: true,\n            pointFormat: ''\n        },\n        trackByArea: true\n    });\n\n    /**\n     * The polygon series class\n     */\n    seriesTypes.polygon = extendClass(seriesTypes.scatter, {\n        type: 'polygon',\n        getGraphPath: function () {\n\n            var graphPath = Series.prototype.getGraphPath.call(this),\n                i = graphPath.length + 1;\n\n            // Close all segments\n            while (i--) {\n                if ((i === graphPath.length || graphPath[i] === 'M') && i > 0) {\n                    graphPath.splice(i, 0, 'z');\n                }\n            }\n            this.areaPath = graphPath;\n            return graphPath;\n        },\n        drawGraph: function () {\n            this.options.fillColor = this.color; // Hack into the fill logic in area.drawGraph\n            seriesTypes.area.prototype.drawGraph.call(this);\n        },\n        drawLegendSymbol: Highcharts.LegendSymbolMixin.drawRectangle,\n        drawTracker: Series.prototype.drawTracker,\n        setStackedPoints: noop // No stacking points on polygons (#5310)\n    });\n    /* ****************************************************************************\n     * Start Bubble series code                                                      *\n     *****************************************************************************/\n\n    // 1 - set default options\n    defaultPlotOptions.bubble = merge(defaultPlotOptions.scatter, {\n        dataLabels: {\n            formatter: function () { // #2945\n                return this.point.z;\n            },\n            inside: true,\n            verticalAlign: 'middle'\n        },\n        // displayNegative: true,\n        marker: {\n            // fillOpacity: 0.5,\n            lineColor: null, // inherit from series.color\n            lineWidth: 1\n        },\n        minSize: 8,\n        maxSize: '20%',\n        // negativeColor: null,\n        // sizeBy: 'area'\n        softThreshold: false,\n        states: {\n            hover: {\n                halo: {\n                    size: 5\n                }\n            }\n        },\n        tooltip: {\n            pointFormat: '({point.x}, {point.y}), Size: {point.z}'\n        },\n        turboThreshold: 0,\n        zThreshold: 0,\n        zoneAxis: 'z'\n    });\n\n    var BubblePoint = extendClass(Point, {\n        haloPath: function () {\n            return Point.prototype.haloPath.call(this, this.shapeArgs.r + this.series.options.states.hover.halo.size);\n        },\n        ttBelow: false\n    });\n\n    // 2 - Create the series object\n    seriesTypes.bubble = extendClass(seriesTypes.scatter, {\n        type: 'bubble',\n        pointClass: BubblePoint,\n        pointArrayMap: ['y', 'z'],\n        parallelArrays: ['x', 'y', 'z'],\n        trackerGroups: ['group', 'dataLabelsGroup'],\n        bubblePadding: true,\n        zoneAxis: 'z',\n\n        /**\n         * Mapping between SVG attributes and the corresponding options\n         */\n        pointAttrToOptions: {\n            stroke: 'lineColor',\n            'stroke-width': 'lineWidth',\n            fill: 'fillColor'\n        },\n\n        /**\n         * Apply the fillOpacity to all fill positions\n         */\n        applyOpacity: function (fill) {\n            var markerOptions = this.options.marker,\n                fillOpacity = pick(markerOptions.fillOpacity, 0.5);\n\n            // When called from Legend.colorizeItem, the fill isn't predefined\n            fill = fill || markerOptions.fillColor || this.color;\n\n            if (fillOpacity !== 1) {\n                fill = Color(fill).setOpacity(fillOpacity).get('rgba');\n            }\n            return fill;\n        },\n\n        /**\n         * Extend the convertAttribs method by applying opacity to the fill\n         */\n        convertAttribs: function () {\n            var obj = Series.prototype.convertAttribs.apply(this, arguments);\n\n            obj.fill = this.applyOpacity(obj.fill);\n\n            return obj;\n        },\n\n        /**\n         * Get the radius for each point based on the minSize, maxSize and each point's Z value. This\n         * must be done prior to Series.translate because the axis needs to add padding in\n         * accordance with the point sizes.\n         */\n        getRadii: function (zMin, zMax, minSize, maxSize) {\n            var len,\n                i,\n                pos,\n                zData = this.zData,\n                radii = [],\n                options = this.options,\n                sizeByArea = options.sizeBy !== 'width',\n                zThreshold = options.zThreshold,\n                zRange = zMax - zMin,\n                value,\n                radius;\n\n            // Set the shape type and arguments to be picked up in drawPoints\n            for (i = 0, len = zData.length; i < len; i++) {\n\n                value = zData[i];\n\n                // When sizing by threshold, the absolute value of z determines the size\n                // of the bubble.\n                if (options.sizeByAbsoluteValue && value !== null) {\n                    value = Math.abs(value - zThreshold);\n                    zMax = Math.max(zMax - zThreshold, Math.abs(zMin - zThreshold));\n                    zMin = 0;\n                }\n\n                if (value === null) {\n                    radius = null;\n                // Issue #4419 - if value is less than zMin, push a radius that's always smaller than the minimum size\n                } else if (value < zMin) {\n                    radius = minSize / 2 - 1;\n                } else {\n                    // Relative size, a number between 0 and 1\n                    pos = zRange > 0 ? (value - zMin) / zRange : 0.5;\n\n                    if (sizeByArea && pos >= 0) {\n                        pos = Math.sqrt(pos);\n                    }\n                    radius = math.ceil(minSize + pos * (maxSize - minSize)) / 2;\n                }\n                radii.push(radius);\n            }\n            this.radii = radii;\n        },\n\n        /**\n         * Perform animation on the bubbles\n         */\n        animate: function (init) {\n            var animation = this.options.animation;\n\n            if (!init) { // run the animation\n                each(this.points, function (point) {\n                    var graphic = point.graphic,\n                        shapeArgs = point.shapeArgs;\n\n                    if (graphic && shapeArgs) {\n                        // start values\n                        graphic.attr('r', 1);\n\n                        // animate\n                        graphic.animate({\n                            r: shapeArgs.r\n                        }, animation);\n                    }\n                });\n\n                // delete this function to allow it only once\n                this.animate = null;\n            }\n        },\n\n        /**\n         * Extend the base translate method to handle bubble size\n         */\n        translate: function () {\n\n            var i,\n                data = this.data,\n                point,\n                radius,\n                radii = this.radii;\n\n            // Run the parent method\n            seriesTypes.scatter.prototype.translate.call(this);\n\n            // Set the shape type and arguments to be picked up in drawPoints\n            i = data.length;\n\n            while (i--) {\n                point = data[i];\n                radius = radii ? radii[i] : 0; // #1737\n\n                if (isNumber(radius) && radius >= this.minPxSize / 2) {\n                    // Shape arguments\n                    point.shapeType = 'circle';\n                    point.shapeArgs = {\n                        x: point.plotX,\n                        y: point.plotY,\n                        r: radius\n                    };\n\n                    // Alignment box for the data label\n                    point.dlBox = {\n                        x: point.plotX - radius,\n                        y: point.plotY - radius,\n                        width: 2 * radius,\n                        height: 2 * radius\n                    };\n                } else { // below zThreshold or z = null\n                    point.shapeArgs = point.plotY = point.dlBox = UNDEFINED; // #1691\n                }\n            }\n        },\n\n        /**\n         * Get the series' symbol in the legend\n         *\n         * @param {Object} legend The legend object\n         * @param {Object} item The series (this) or point\n         */\n        drawLegendSymbol: function (legend, item) {\n            var renderer = this.chart.renderer,\n                radius = renderer.fontMetrics(legend.itemStyle.fontSize).f / 2;\n\n            item.legendSymbol = renderer.circle(\n                radius,\n                legend.baseline - radius,\n                radius\n            ).attr({\n                zIndex: 3\n            }).add(item.legendGroup);\n            item.legendSymbol.isMarker = true;\n\n        },\n\n        drawPoints: seriesTypes.column.prototype.drawPoints,\n        alignDataLabel: seriesTypes.column.prototype.alignDataLabel,\n        buildKDTree: noop,\n        applyZones: noop\n    });\n\n    /**\n     * Add logic to pad each axis with the amount of pixels\n     * necessary to avoid the bubbles to overflow.\n     */\n    Axis.prototype.beforePadding = function () {\n        var axis = this,\n            axisLength = this.len,\n            chart = this.chart,\n            pxMin = 0,\n            pxMax = axisLength,\n            isXAxis = this.isXAxis,\n            dataKey = isXAxis ? 'xData' : 'yData',\n            min = this.min,\n            extremes = {},\n            smallestSize = math.min(chart.plotWidth, chart.plotHeight),\n            zMin = Number.MAX_VALUE,\n            zMax = -Number.MAX_VALUE,\n            range = this.max - min,\n            transA = axisLength / range,\n            activeSeries = [];\n\n        // Handle padding on the second pass, or on redraw\n        each(this.series, function (series) {\n\n            var seriesOptions = series.options,\n                zData;\n\n            if (series.bubblePadding && (series.visible || !chart.options.chart.ignoreHiddenSeries)) {\n\n                // Correction for #1673\n                axis.allowZoomOutside = true;\n\n                // Cache it\n                activeSeries.push(series);\n\n                if (isXAxis) { // because X axis is evaluated first\n\n                    // For each series, translate the size extremes to pixel values\n                    each(['minSize', 'maxSize'], function (prop) {\n                        var length = seriesOptions[prop],\n                            isPercent = /%$/.test(length);\n\n                        length = pInt(length);\n                        extremes[prop] = isPercent ?\n                            smallestSize * length / 100 :\n                            length;\n\n                    });\n                    series.minPxSize = extremes.minSize;\n                    series.maxPxSize = extremes.maxSize;\n\n                    // Find the min and max Z\n                    zData = series.zData;\n                    if (zData.length) { // #1735\n                        zMin = pick(seriesOptions.zMin, math.min(\n                            zMin,\n                            math.max(\n                                arrayMin(zData),\n                                seriesOptions.displayNegative === false ? seriesOptions.zThreshold : -Number.MAX_VALUE\n                            )\n                        ));\n                        zMax = pick(seriesOptions.zMax, math.max(zMax, arrayMax(zData)));\n                    }\n                }\n            }\n        });\n\n        each(activeSeries, function (series) {\n\n            var data = series[dataKey],\n                i = data.length,\n                radius;\n\n            if (isXAxis) {\n                series.getRadii(zMin, zMax, series.minPxSize, series.maxPxSize);\n            }\n\n            if (range > 0) {\n                while (i--) {\n                    if (isNumber(data[i]) && axis.dataMin <= data[i] && data[i] <= axis.dataMax) {\n                        radius = series.radii[i];\n                        pxMin = Math.min(((data[i] - min) * transA) - radius, pxMin);\n                        pxMax = Math.max(((data[i] - min) * transA) + radius, pxMax);\n                    }\n                }\n            }\n        });\n\n\n        if (activeSeries.length && range > 0 && !this.isLog) {\n            pxMax -= axisLength;\n            transA *= (axisLength + pxMin - pxMax) / axisLength;\n            each([['min', 'userMin', pxMin], ['max', 'userMax', pxMax]], function (keys) {\n                if (pick(axis.options[keys[0]], axis[keys[1]]) === UNDEFINED) {\n                    axis[keys[0]] += keys[2] / transA;\n                }\n            });\n        }\n    };\n\n    /* ****************************************************************************\n     * End Bubble series code                                                     *\n     *****************************************************************************/\n\n    (function () {\n\n        /**\n         * Extensions for polar charts. Additionally, much of the geometry required for polar charts is\n         * gathered in RadialAxes.js.\n         *\n         */\n\n        var seriesProto = Series.prototype,\n            pointerProto = Pointer.prototype,\n            colProto;\n\n        /**\n         * Search a k-d tree by the point angle, used for shared tooltips in polar charts\n         */\n        seriesProto.searchPointByAngle = function (e) {\n            var series = this,\n                chart = series.chart,\n                xAxis = series.xAxis,\n                center = xAxis.pane.center,\n                plotX = e.chartX - center[0] - chart.plotLeft,\n                plotY = e.chartY - center[1] - chart.plotTop;\n\n            return this.searchKDTree({\n                clientX: 180 + (Math.atan2(plotX, plotY) * (-180 / Math.PI))\n            });\n\n        };\n\n        /**\n         * Wrap the buildKDTree function so that it searches by angle (clientX) in case of shared tooltip,\n         * and by two dimensional distance in case of non-shared.\n         */\n        wrap(seriesProto, 'buildKDTree', function (proceed) {\n            if (this.chart.polar) {\n                if (this.kdByAngle) {\n                    this.searchPoint = this.searchPointByAngle;\n                } else {\n                    this.kdDimensions = 2;\n                }\n            }\n            proceed.apply(this);\n        });\n\n        /**\n         * Translate a point's plotX and plotY from the internal angle and radius measures to\n         * true plotX, plotY coordinates\n         */\n        seriesProto.toXY = function (point) {\n            var xy,\n                chart = this.chart,\n                plotX = point.plotX,\n                plotY = point.plotY,\n                clientX;\n\n            // Save rectangular plotX, plotY for later computation\n            point.rectPlotX = plotX;\n            point.rectPlotY = plotY;\n\n            // Find the polar plotX and plotY\n            xy = this.xAxis.postTranslate(point.plotX, this.yAxis.len - plotY);\n            point.plotX = point.polarPlotX = xy.x - chart.plotLeft;\n            point.plotY = point.polarPlotY = xy.y - chart.plotTop;\n\n            // If shared tooltip, record the angle in degrees in order to align X points. Otherwise,\n            // use a standard k-d tree to get the nearest point in two dimensions.\n            if (this.kdByAngle) {\n                clientX = ((plotX / Math.PI * 180) + this.xAxis.pane.options.startAngle) % 360;\n                if (clientX < 0) { // #2665\n                    clientX += 360;\n                }\n                point.clientX = clientX;\n            } else {\n                point.clientX = point.plotX;\n            }\n        };\n\n        if (seriesTypes.spline) {\n            /**\n             * Overridden method for calculating a spline from one point to the next\n             */\n            wrap(seriesTypes.spline.prototype, 'getPointSpline', function (proceed, segment, point, i) {\n\n                var ret,\n                    smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc;\n                    denom = smoothing + 1,\n                    plotX,\n                    plotY,\n                    lastPoint,\n                    nextPoint,\n                    lastX,\n                    lastY,\n                    nextX,\n                    nextY,\n                    leftContX,\n                    leftContY,\n                    rightContX,\n                    rightContY,\n                    distanceLeftControlPoint,\n                    distanceRightControlPoint,\n                    leftContAngle,\n                    rightContAngle,\n                    jointAngle;\n\n\n                if (this.chart.polar) {\n\n                    plotX = point.plotX;\n                    plotY = point.plotY;\n                    lastPoint = segment[i - 1];\n                    nextPoint = segment[i + 1];\n\n                    // Connect ends\n                    if (this.connectEnds) {\n                        if (!lastPoint) {\n                            lastPoint = segment[segment.length - 2]; // not the last but the second last, because the segment is already connected\n                        }\n                        if (!nextPoint) {\n                            nextPoint = segment[1];\n                        }\n                    }\n\n                    // find control points\n                    if (lastPoint && nextPoint) {\n\n                        lastX = lastPoint.plotX;\n                        lastY = lastPoint.plotY;\n                        nextX = nextPoint.plotX;\n                        nextY = nextPoint.plotY;\n                        leftContX = (smoothing * plotX + lastX) / denom;\n                        leftContY = (smoothing * plotY + lastY) / denom;\n                        rightContX = (smoothing * plotX + nextX) / denom;\n                        rightContY = (smoothing * plotY + nextY) / denom;\n                        distanceLeftControlPoint = Math.sqrt(Math.pow(leftContX - plotX, 2) + Math.pow(leftContY - plotY, 2));\n                        distanceRightControlPoint = Math.sqrt(Math.pow(rightContX - plotX, 2) + Math.pow(rightContY - plotY, 2));\n                        leftContAngle = Math.atan2(leftContY - plotY, leftContX - plotX);\n                        rightContAngle = Math.atan2(rightContY - plotY, rightContX - plotX);\n                        jointAngle = (Math.PI / 2) + ((leftContAngle + rightContAngle) / 2);\n\n\n                        // Ensure the right direction, jointAngle should be in the same quadrant as leftContAngle\n                        if (Math.abs(leftContAngle - jointAngle) > Math.PI / 2) {\n                            jointAngle -= Math.PI;\n                        }\n\n                        // Find the corrected control points for a spline straight through the point\n                        leftContX = plotX + Math.cos(jointAngle) * distanceLeftControlPoint;\n                        leftContY = plotY + Math.sin(jointAngle) * distanceLeftControlPoint;\n                        rightContX = plotX + Math.cos(Math.PI + jointAngle) * distanceRightControlPoint;\n                        rightContY = plotY + Math.sin(Math.PI + jointAngle) * distanceRightControlPoint;\n\n                        // Record for drawing in next point\n                        point.rightContX = rightContX;\n                        point.rightContY = rightContY;\n\n                    }\n\n\n                    // moveTo or lineTo\n                    if (!i) {\n                        ret = ['M', plotX, plotY];\n                    } else { // curve from last point to this\n                        ret = [\n                            'C',\n                            lastPoint.rightContX || lastPoint.plotX,\n                            lastPoint.rightContY || lastPoint.plotY,\n                            leftContX || plotX,\n                            leftContY || plotY,\n                            plotX,\n                            plotY\n                        ];\n                        lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later\n                    }\n\n\n                } else {\n                    ret = proceed.call(this, segment, point, i);\n                }\n                return ret;\n            });\n        }\n\n        /**\n         * Extend translate. The plotX and plotY values are computed as if the polar chart were a\n         * cartesian plane, where plotX denotes the angle in radians and (yAxis.len - plotY) is the pixel distance from\n         * center.\n         */\n        wrap(seriesProto, 'translate', function (proceed) {\n            var chart = this.chart,\n                points,\n                i;\n\n            // Run uber method\n            proceed.call(this);\n\n            // Postprocess plot coordinates\n            if (chart.polar) {\n                this.kdByAngle = chart.tooltip && chart.tooltip.shared;\n\n                if (!this.preventPostTranslate) {\n                    points = this.points;\n                    i = points.length;\n\n                    while (i--) {\n                        // Translate plotX, plotY from angle and radius to true plot coordinates\n                        this.toXY(points[i]);\n                    }\n                }\n            }\n        });\n\n        /**\n         * Extend getSegmentPath to allow connecting ends across 0 to provide a closed circle in\n         * line-like series.\n         */\n        wrap(seriesProto, 'getGraphPath', function (proceed, points) {\n            var series = this,\n                i,\n                firstValid;\n        \n            // Connect the path\n            if (this.chart.polar) {\n                points = points || this.points;\n\n                // Append first valid point in order to connect the ends\n                for (i = 0; i < points.length; i++) {\n                    if (!points[i].isNull) {\n                        firstValid = i;\n                        break;\n                    }\n                }\n                if (this.options.connectEnds !== false && firstValid !== undefined) {\n                    this.connectEnds = true; // re-used in splines\n                    points.splice(points.length, 0, points[firstValid]);\n                }\n\n                // For area charts, pseudo points are added to the graph, now we need to translate these\n                each(points, function (point) {\n                    if (point.polarPlotY === undefined) {\n                        series.toXY(point);\n                    }\n                });\n            }\n\n            // Run uber method\n            return proceed.apply(this, [].slice.call(arguments, 1));\n    \n        });\n\n\n        function polarAnimate(proceed, init) {\n            var chart = this.chart,\n                animation = this.options.animation,\n                group = this.group,\n                markerGroup = this.markerGroup,\n                center = this.xAxis.center,\n                plotLeft = chart.plotLeft,\n                plotTop = chart.plotTop,\n                attribs;\n\n            // Specific animation for polar charts\n            if (chart.polar) {\n\n                // Enable animation on polar charts only in SVG. In VML, the scaling is different, plus animation\n                // would be so slow it would't matter.\n                if (chart.renderer.isSVG) {\n\n                    if (animation === true) {\n                        animation = {};\n                    }\n\n                    // Initialize the animation\n                    if (init) {\n\n                        // Scale down the group and place it in the center\n                        attribs = {\n                            translateX: center[0] + plotLeft,\n                            translateY: center[1] + plotTop,\n                            scaleX: 0.001, // #1499\n                            scaleY: 0.001\n                        };\n\n                        group.attr(attribs);\n                        if (markerGroup) {\n                            //markerGroup.attrSetters = group.attrSetters;\n                            markerGroup.attr(attribs);\n                        }\n\n                    // Run the animation\n                    } else {\n                        attribs = {\n                            translateX: plotLeft,\n                            translateY: plotTop,\n                            scaleX: 1,\n                            scaleY: 1\n                        };\n                        group.animate(attribs, animation);\n                        if (markerGroup) {\n                            markerGroup.animate(attribs, animation);\n                        }\n\n                        // Delete this function to allow it only once\n                        this.animate = null;\n                    }\n                }\n\n            // For non-polar charts, revert to the basic animation\n            } else {\n                proceed.call(this, init);\n            }\n        }\n\n        // Define the animate method for regular series\n        wrap(seriesProto, 'animate', polarAnimate);\n\n\n        if (seriesTypes.column) {\n\n            colProto = seriesTypes.column.prototype;\n\n            colProto.polarArc = function (low, high, start, end) {\n                var center = this.xAxis.center,\n                    len = this.yAxis.len;\n                \n                return this.chart.renderer.symbols.arc(\n                    center[0],\n                    center[1],\n                    len - high,\n                    null,\n                    {\n                        start: start,\n                        end: end,\n                        innerR: len - pick(low, len)\n                    }\n                );\n            };\n\n            /**\n            * Define the animate method for columnseries\n            */\n            wrap(colProto, 'animate', polarAnimate);\n\n\n            /**\n             * Extend the column prototype's translate method\n             */\n            wrap(colProto, 'translate', function (proceed) {\n\n                var xAxis = this.xAxis,\n                    startAngleRad = xAxis.startAngleRad,\n                    start,\n                    points,\n                    point,\n                    i;\n\n                this.preventPostTranslate = true;\n\n                // Run uber method\n                proceed.call(this);\n\n                // Postprocess plot coordinates\n                if (xAxis.isRadial) {\n                    points = this.points;\n                    i = points.length;\n                    while (i--) {\n                        point = points[i];\n                        start = point.barX + startAngleRad;\n                        point.shapeType = 'path';\n                        point.shapeArgs = {\n                            d: this.polarArc(point.yBottom, point.plotY, start, start + point.pointWidth)\n                        };\n                        // Provide correct plotX, plotY for tooltip\n                        this.toXY(point);\n                        point.tooltipPos = [point.plotX, point.plotY];\n                        point.ttBelow = point.plotY > xAxis.center[1];\n                    }\n                }\n            });\n\n\n            /**\n             * Align column data labels outside the columns. #1199.\n             */\n            wrap(colProto, 'alignDataLabel', function (proceed, point, dataLabel, options, alignTo, isNew) {\n\n                if (this.chart.polar) {\n                    var angle = point.rectPlotX / Math.PI * 180,\n                        align,\n                        verticalAlign;\n\n                    // Align nicely outside the perimeter of the columns\n                    if (options.align === null) {\n                        if (angle > 20 && angle < 160) {\n                            align = 'left'; // right hemisphere\n                        } else if (angle > 200 && angle < 340) {\n                            align = 'right'; // left hemisphere\n                        } else {\n                            align = 'center'; // top or bottom\n                        }\n                        options.align = align;\n                    }\n                    if (options.verticalAlign === null) {\n                        if (angle < 45 || angle > 315) {\n                            verticalAlign = 'bottom'; // top part\n                        } else if (angle > 135 && angle < 225) {\n                            verticalAlign = 'top'; // bottom part\n                        } else {\n                            verticalAlign = 'middle'; // left or right\n                        }\n                        options.verticalAlign = verticalAlign;\n                    }\n\n                    seriesProto.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);\n                } else {\n                    proceed.call(this, point, dataLabel, options, alignTo, isNew);\n                }\n\n            });\n        }\n\n        /**\n         * Extend getCoordinates to prepare for polar axis values\n         */\n        wrap(pointerProto, 'getCoordinates', function (proceed, e) {\n            var chart = this.chart,\n                ret = {\n                    xAxis: [],\n                    yAxis: []\n                };\n\n            if (chart.polar) {\n\n                each(chart.axes, function (axis) {\n                    var isXAxis = axis.isXAxis,\n                        center = axis.center,\n                        x = e.chartX - center[0] - chart.plotLeft,\n                        y = e.chartY - center[1] - chart.plotTop;\n\n                    ret[isXAxis ? 'xAxis' : 'yAxis'].push({\n                        axis: axis,\n                        value: axis.translate(\n                            isXAxis ?\n                                Math.PI - Math.atan2(x, y) : // angle\n                                Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)), // distance from center\n                            true\n                        )\n                    });\n                });\n\n            } else {\n                ret = proceed.call(this, e);\n            }\n\n            return ret;\n        });\n\n    }());\n\n}));\n";
},660:function(t,n){t.exports="// ==ClosureCompiler==\n// @compilation_level SIMPLE_OPTIMIZATIONS\n\n/**\n * @license Highstock JS v4.2.7 (2016-09-21)\n *\n * (c) 2009-2016 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n(function (root, factory) {\n    if (typeof module === 'object' && module.exports) {\n        module.exports = root.document ?\n            factory(root) : \n            factory;\n    } else {\n        root.Highcharts = factory(root);\n    }\n}(typeof window !== 'undefined' ? window : this, function (win) { // eslint-disable-line no-undef\n// encapsulated variables\n    var UNDEFINED,\n        doc = win.document,\n        math = Math,\n        mathRound = math.round,\n        mathFloor = math.floor,\n        mathCeil = math.ceil,\n        mathMax = math.max,\n        mathMin = math.min,\n        mathAbs = math.abs,\n        mathCos = math.cos,\n        mathSin = math.sin,\n        mathPI = math.PI,\n        deg2rad = mathPI * 2 / 360,\n\n\n        // some variables\n        userAgent = (win.navigator && win.navigator.userAgent) || '',\n        isOpera = win.opera,\n        isMS = /(msie|trident|edge)/i.test(userAgent) && !isOpera,\n        docMode8 = doc && doc.documentMode === 8,\n        isWebKit = !isMS && /AppleWebKit/.test(userAgent),\n        isFirefox = /Firefox/.test(userAgent),\n        isTouchDevice = /(Mobile|Android|Windows Phone)/.test(userAgent),\n        SVG_NS = 'http://www.w3.org/2000/svg',\n        hasSVG = doc && doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,\n        hasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4, // issue #38\n        useCanVG = doc && !hasSVG && !isMS && !!doc.createElement('canvas').getContext,\n        Renderer,\n        hasTouch,\n        symbolSizes = {},\n        idCounter = 0,\n        garbageBin,\n        defaultOptions,\n        dateFormat, // function\n        pathAnim,\n        timeUnits,\n        noop = function () {},\n        charts = [],\n        chartCount = 0,\n        PRODUCT = 'Highstock',\n        VERSION = '4.2.7',\n\n        // some constants for frequently used strings\n        DIV = 'div',\n        ABSOLUTE = 'absolute',\n        RELATIVE = 'relative',\n        HIDDEN = 'hidden',\n        PREFIX = 'highcharts-',\n        VISIBLE = 'visible',\n        PX = 'px',\n        NONE = 'none',\n        M = 'M',\n        L = 'L',\n        numRegex = /[0-9]/g,\n        NORMAL_STATE = '',\n        HOVER_STATE = 'hover',\n        SELECT_STATE = 'select',\n        marginNames = ['plotTop', 'marginRight', 'marginBottom', 'plotLeft'],\n\n        // Object for extending Axis\n        AxisPlotLineOrBandExtension,\n\n        // constants for attributes\n        STROKE_WIDTH = 'stroke-width',\n\n        // time methods, changed based on whether or not UTC is used\n        Date,  // Allow using a different Date class\n        makeTime,\n        timezoneOffset,\n        getTimezoneOffset,\n        getMinutes,\n        getHours,\n        getDay,\n        getDate,\n        getMonth,\n        getFullYear,\n        setMilliseconds,\n        setSeconds,\n        setMinutes,\n        setHours,\n        setDate,\n        setMonth,\n        setFullYear,\n\n\n        // lookup over the types and the associated classes\n        seriesTypes = {},\n        Highcharts;\n\n    /**\n     * Provide error messages for debugging, with links to online explanation\n     */\n    function error(code, stop) {\n        var msg = 'Highcharts error #' + code + ': www.highcharts.com/errors/' + code;\n        if (stop) {\n            throw new Error(msg);\n        }\n        // else ...\n        if (win.console) {\n            console.log(msg); // eslint-disable-line no-console\n        }\n    }\n\n    // The Highcharts namespace\n    Highcharts = win.Highcharts ? error(16, true) : { win: win };\n\n    Highcharts.seriesTypes = seriesTypes;\n    var timers = [],\n        getStyle,\n\n        // Previous adapter functions\n        inArray,\n        each,\n        grep,\n        offset,\n        map,\n        addEvent,\n        removeEvent,\n        fireEvent,\n        animate,\n        stop;\n\n    /**\n     * An animator object. One instance applies to one property (attribute or style prop) \n     * on one element.\n     * \n     * @param {object} elem    The element to animate. May be a DOM element or a Highcharts SVGElement wrapper.\n     * @param {object} options Animation options, including duration, easing, step and complete.\n     * @param {object} prop    The property to animate.\n     */\n    function Fx(elem, options, prop) {\n        this.options = options;\n        this.elem = elem;\n        this.prop = prop;\n    }\n    Fx.prototype = {\n    \n        /**\n         * Animating a path definition on SVGElement\n         * @returns {undefined} \n         */\n        dSetter: function () {\n            var start = this.paths[0],\n                end = this.paths[1],\n                ret = [],\n                now = this.now,\n                i = start.length,\n                startVal;\n\n            if (now === 1) { // land on the final path without adjustment points appended in the ends\n                ret = this.toD;\n\n            } else if (i === end.length && now < 1) {\n                while (i--) {\n                    startVal = parseFloat(start[i]);\n                    ret[i] =\n                        isNaN(startVal) ? // a letter instruction like M or L\n                                start[i] :\n                                now * (parseFloat(end[i] - startVal)) + startVal;\n\n                }\n            } else { // if animation is finished or length not matching, land on right value\n                ret = end;\n            }\n            this.elem.attr('d', ret);\n        },\n\n        /**\n         * Update the element with the current animation step\n         * @returns {undefined}\n         */\n        update: function () {\n            var elem = this.elem,\n                prop = this.prop, // if destroyed, it is null\n                now = this.now,\n                step = this.options.step;\n\n            // Animation setter defined from outside\n            if (this[prop + 'Setter']) {\n                this[prop + 'Setter']();\n\n            // Other animations on SVGElement\n            } else if (elem.attr) {\n                if (elem.element) {\n                    elem.attr(prop, now);\n                }\n\n            // HTML styles, raw HTML content like container size\n            } else {\n                elem.style[prop] = now + this.unit;\n            }\n        \n            if (step) {\n                step.call(elem, now, this);\n            }\n\n        },\n\n        /**\n         * Run an animation\n         */\n        run: function (from, to, unit) {\n            var self = this,\n                timer = function (gotoEnd) {\n                    return timer.stopped ? false : self.step(gotoEnd);\n                },\n                i;\n\n            this.startTime = +new Date();\n            this.start = from;\n            this.end = to;\n            this.unit = unit;\n            this.now = this.start;\n            this.pos = 0;\n\n            timer.elem = this.elem;\n\n            if (timer() && timers.push(timer) === 1) {\n                timer.timerId = setInterval(function () {\n                \n                    for (i = 0; i < timers.length; i++) {\n                        if (!timers[i]()) {\n                            timers.splice(i--, 1);\n                        }\n                    }\n\n                    if (!timers.length) {\n                        clearInterval(timer.timerId);\n                    }\n                }, 13);\n            }\n        },\n    \n        /**\n         * Run a single step in the animation\n         * @param   {Boolean} gotoEnd Whether to go to then endpoint of the animation after abort\n         * @returns {Boolean} True if animation continues\n         */\n        step: function (gotoEnd) {\n            var t = +new Date(),\n                ret,\n                done,\n                options = this.options,\n                elem = this.elem,\n                complete = options.complete,\n                duration = options.duration,\n                curAnim = options.curAnim,\n                i;\n        \n            if (elem.attr && !elem.element) { // #2616, element including flag is destroyed\n                ret = false;\n\n            } else if (gotoEnd || t >= duration + this.startTime) {\n                this.now = this.end;\n                this.pos = 1;\n                this.update();\n\n                curAnim[this.prop] = true;\n\n                done = true;\n                for (i in curAnim) {\n                    if (curAnim[i] !== true) {\n                        done = false;\n                    }\n                }\n\n                if (done && complete) {\n                    complete.call(elem);\n                }\n                ret = false;\n\n            } else {\n                this.pos = options.easing((t - this.startTime) / duration);\n                this.now = this.start + ((this.end - this.start) * this.pos);\n                this.update();\n                ret = true;\n            }\n            return ret;\n        },\n\n        /**\n         * Prepare start and end values so that the path can be animated one to one\n         */\n        initPath: function (elem, fromD, toD) {\n            fromD = fromD || '';\n            var shift,\n                startX = elem.startX,\n                endX = elem.endX,\n                bezier = fromD.indexOf('C') > -1,\n                numParams = bezier ? 7 : 3,\n                fullLength,\n                slice,\n                i,\n                start = fromD.split(' '),\n                end = toD.slice(), // copy\n                isArea = elem.isArea,\n                positionFactor = isArea ? 2 : 1,\n                reverse;\n        \n            /**\n             * In splines make move points have six parameters like bezier curves\n             */\n            function sixify(arr) {\n                i = arr.length;\n                while (i--) {\n                    if (arr[i] === M || arr[i] === L) {\n                        arr.splice(i + 1, 0, arr[i + 1], arr[i + 2], arr[i + 1], arr[i + 2]);\n                    }\n                }\n            }\n\n            /**\n             * Insert an array at the given position of another array\n             */\n            function insertSlice(arr, subArr, index) {\n                [].splice.apply(\n                    arr,\n                    [index, 0].concat(subArr)\n                );\n            }\n\n            /**\n             * If shifting points, prepend a dummy point to the end path. \n             */\n            function prepend(arr, other) {\n                while (arr.length < fullLength) {\n                \n                    // Move to, line to or curve to?\n                    arr[0] = other[fullLength - arr.length];\n\n                    // Prepend a copy of the first point\n                    insertSlice(arr, arr.slice(0, numParams), 0);\n\n                    // For areas, the bottom path goes back again to the left, so we need\n                    // to append a copy of the last point.\n                    if (isArea) {\n                        insertSlice(arr, arr.slice(arr.length - numParams), arr.length);\n                        i--;\n                    }\n                }\n                arr[0] = 'M';\n            }\n\n            /**\n             * Copy and append last point until the length matches the end length\n             */\n            function append(arr, other) {\n                var i = (fullLength - arr.length) / numParams;\n                while (i > 0 && i--) {\n\n                    // Pull out the slice that is going to be appended or inserted. In a line graph,\n                    // the positionFactor is 1, and the last point is sliced out. In an area graph,\n                    // the positionFactor is 2, causing the middle two points to be sliced out, since\n                    // an area path starts at left, follows the upper path then turns and follows the\n                    // bottom back. \n                    slice = arr.slice().splice(\n                        (arr.length / positionFactor) - numParams, \n                        numParams * positionFactor\n                    );\n\n                    // Move to, line to or curve to?\n                    slice[0] = other[fullLength - numParams - (i * numParams)];\n                \n                    // Disable first control point\n                    if (bezier) {\n                        slice[numParams - 6] = slice[numParams - 2];\n                        slice[numParams - 5] = slice[numParams - 1];\n                    }\n                \n                    // Now insert the slice, either in the middle (for areas) or at the end (for lines)\n                    insertSlice(arr, slice, arr.length / positionFactor);\n\n                    if (isArea) {\n                        i--;\n                    }\n                }\n            }\n\n            if (bezier) {\n                sixify(start);\n                sixify(end);\n            }\n\n            // For sideways animation, find out how much we need to shift to get the start path Xs\n            // to match the end path Xs.\n            if (startX && endX) {\n                for (i = 0; i < startX.length; i++) {\n                    if (startX[i] === endX[0]) { // Moving left, new points coming in on right\n                        shift = i;\n                        break;\n                    } else if (startX[0] === endX[endX.length - startX.length + i]) { // Moving right\n                        shift = i;\n                        reverse = true;\n                        break;\n                    }\n                }\n                if (shift === undefined) {\n                    start = [];\n                }\n            }\n\n            if (start.length && Highcharts.isNumber(shift)) {\n\n                // The common target length for the start and end array, where both \n                // arrays are padded in opposite ends\n                fullLength = end.length + shift * positionFactor * numParams;\n            \n                if (!reverse) {\n                    prepend(end, start);\n                    append(start, end);\n                } else {\n                    prepend(start, end);\n                    append(end, start);\n                }\n            }\n\n            return [start, end];\n        }\n    }; // End of Fx prototype\n\n\n    /**\n     * Extend an object with the members of another\n     * @param {Object} a The object to be extended\n     * @param {Object} b The object to add to the first one\n     */\n    var extend = Highcharts.extend = function (a, b) {\n        var n;\n        if (!a) {\n            a = {};\n        }\n        for (n in b) {\n            a[n] = b[n];\n        }\n        return a;\n    };\n\n    /**\n     * Deep merge two or more objects and return a third object. If the first argument is\n     * true, the contents of the second object is copied into the first object.\n     * Previously this function redirected to jQuery.extend(true), but this had two limitations.\n     * First, it deep merged arrays, which lead to workarounds in Highcharts. Second,\n     * it copied properties from extended prototypes.\n     */\n    function merge() {\n        var i,\n            args = arguments,\n            len,\n            ret = {},\n            doCopy = function (copy, original) {\n                var value, key;\n\n                // An object is replacing a primitive\n                if (typeof copy !== 'object') {\n                    copy = {};\n                }\n\n                for (key in original) {\n                    if (original.hasOwnProperty(key)) {\n                        value = original[key];\n\n                        // Copy the contents of objects, but not arrays or DOM nodes\n                        if (Highcharts.isObject(value, true) &&\n                                key !== 'renderTo' && typeof value.nodeType !== 'number') {\n                            copy[key] = doCopy(copy[key] || {}, value);\n\n                        // Primitives and arrays are copied over directly\n                        } else {\n                            copy[key] = original[key];\n                        }\n                    }\n                }\n                return copy;\n            };\n\n        // If first argument is true, copy into the existing object. Used in setOptions.\n        if (args[0] === true) {\n            ret = args[1];\n            args = Array.prototype.slice.call(args, 2);\n        }\n\n        // For each argument, extend the return\n        len = args.length;\n        for (i = 0; i < len; i++) {\n            ret = doCopy(ret, args[i]);\n        }\n\n        return ret;\n    }\n\n    /**\n     * Shortcut for parseInt\n     * @param {Object} s\n     * @param {Number} mag Magnitude\n     */\n    function pInt(s, mag) {\n        return parseInt(s, mag || 10);\n    }\n\n    /**\n     * Check for string\n     * @param {Object} s\n     */\n    function isString(s) {\n        return typeof s === 'string';\n    }\n\n    /**\n     * Check for array\n     * @param {Object} obj\n     */\n    function isArray(obj) {\n        var str = Object.prototype.toString.call(obj);\n        return str === '[object Array]' || str === '[object Array Iterator]';\n    }\n\n    /**\n     * Check for object\n     * @param {Object} obj\n     * @param {Boolean} strict Also checks that the object is not an array\n     */\n    var isObject = Highcharts.isObject = function (obj, strict) {\n        //debugger;\n        return obj && typeof obj === 'object' && (!strict || !isArray(obj));\n    };\n\n    /**\n     * Check for number\n     * @param {Object} n\n     */\n    var isNumber = Highcharts.isNumber = function isNumber(n) {\n        return typeof n === 'number' && !isNaN(n);\n    };\n\n    /**\n     * Remove last occurence of an item from an array\n     * @param {Array} arr\n     * @param {Mixed} item\n     */\n    function erase(arr, item) {\n        var i = arr.length;\n        while (i--) {\n            if (arr[i] === item) {\n                arr.splice(i, 1);\n                break;\n            }\n        }\n        //return arr;\n    }\n\n    /**\n     * Returns true if the object is not null or undefined.\n     * @param {Object} obj\n     */\n    function defined(obj) {\n        return obj !== UNDEFINED && obj !== null;\n    }\n\n    /**\n     * Set or get an attribute or an object of attributes. Can't use jQuery attr because\n     * it attempts to set expando properties on the SVG element, which is not allowed.\n     *\n     * @param {Object} elem The DOM element to receive the attribute(s)\n     * @param {String|Object} prop The property or an abject of key-value pairs\n     * @param {String} value The value if a single property is set\n     */\n    function attr(elem, prop, value) {\n        var key,\n            ret;\n\n        // if the prop is a string\n        if (isString(prop)) {\n            // set the value\n            if (defined(value)) {\n                elem.setAttribute(prop, value);\n\n            // get the value\n            } else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...\n                ret = elem.getAttribute(prop);\n            }\n\n        // else if prop is defined, it is a hash of key/value pairs\n        } else if (defined(prop) && isObject(prop)) {\n            for (key in prop) {\n                elem.setAttribute(key, prop[key]);\n            }\n        }\n        return ret;\n    }\n    /**\n     * Check if an element is an array, and if not, make it into an array.\n     */\n    function splat(obj) {\n        return isArray(obj) ? obj : [obj];\n    }\n\n    /**\n     * Set a timeout if the delay is given, otherwise perform the function synchronously\n     * @param   {Function} fn      The function to perform\n     * @param   {Number}   delay   Delay in milliseconds\n     * @param   {Ojbect}   context The context\n     * @returns {Nubmer}           An identifier for the timeout\n     */\n    function syncTimeout(fn, delay, context) {\n        if (delay) {\n            return setTimeout(fn, delay, context);\n        }\n        fn.call(0, context);\n    }\n\n\n    /**\n     * Return the first value that is defined.\n     */\n    var pick = Highcharts.pick = function () {\n        var args = arguments,\n            i,\n            arg,\n            length = args.length;\n        for (i = 0; i < length; i++) {\n            arg = args[i];\n            if (arg !== UNDEFINED && arg !== null) {\n                return arg;\n            }\n        }\n    };\n\n    /**\n     * Set CSS on a given element\n     * @param {Object} el\n     * @param {Object} styles Style object with camel case property names\n     */\n    function css(el, styles) {\n        if (isMS && !hasSVG) { // #2686\n            if (styles && styles.opacity !== UNDEFINED) {\n                styles.filter = 'alpha(opacity=' + (styles.opacity * 100) + ')';\n            }\n        }\n        extend(el.style, styles);\n    }\n\n    /**\n     * Utility function to create element with attributes and styles\n     * @param {Object} tag\n     * @param {Object} attribs\n     * @param {Object} styles\n     * @param {Object} parent\n     * @param {Object} nopad\n     */\n    function createElement(tag, attribs, styles, parent, nopad) {\n        var el = doc.createElement(tag);\n        if (attribs) {\n            extend(el, attribs);\n        }\n        if (nopad) {\n            css(el, { padding: 0, border: 'none', margin: 0 });\n        }\n        if (styles) {\n            css(el, styles);\n        }\n        if (parent) {\n            parent.appendChild(el);\n        }\n        return el;\n    }\n\n    /**\n     * Extend a prototyped class by new members\n     * @param {Object} parent\n     * @param {Object} members\n     */\n    function extendClass(Parent, members) {\n        var object = function () {\n        };\n        object.prototype = new Parent();\n        extend(object.prototype, members);\n        return object;\n    }\n\n    /**\n     * Pad a string to a given length by adding 0 to the beginning\n     * @param {Number} number\n     * @param {Number} length\n     */\n    function pad(number, length, padder) {\n        return new Array((length || 2) + 1 - String(number).length).join(padder || 0) + number;\n    }\n\n    /**\n     * Return a length based on either the integer value, or a percentage of a base.\n     */\n    function relativeLength(value, base) {\n        return (/%$/).test(value) ? base * parseFloat(value) / 100 : parseFloat(value);\n    }\n\n    /**\n     * Wrap a method with extended functionality, preserving the original function\n     * @param {Object} obj The context object that the method belongs to\n     * @param {String} method The name of the method to extend\n     * @param {Function} func A wrapper function callback. This function is called with the same arguments\n     * as the original function, except that the original function is unshifted and passed as the first\n     * argument.\n     */\n    var wrap = Highcharts.wrap = function (obj, method, func) {\n        var proceed = obj[method];\n        obj[method] = function () {\n            var args = Array.prototype.slice.call(arguments);\n            args.unshift(proceed);\n            return func.apply(this, args);\n        };\n    };\n\n\n    function getTZOffset(timestamp) {\n        return ((getTimezoneOffset && getTimezoneOffset(timestamp)) || timezoneOffset || 0) * 60000;\n    }\n\n    /**\n     * Based on http://www.php.net/manual/en/function.strftime.php\n     * @param {String} format\n     * @param {Number} timestamp\n     * @param {Boolean} capitalize\n     */\n    dateFormat = function (format, timestamp, capitalize) {\n        if (!defined(timestamp) || isNaN(timestamp)) {\n            return defaultOptions.lang.invalidDate || '';\n        }\n        format = pick(format, '%Y-%m-%d %H:%M:%S');\n\n        var date = new Date(timestamp - getTZOffset(timestamp)),\n            key, // used in for constuct below\n            // get the basic time values\n            hours = date[getHours](),\n            day = date[getDay](),\n            dayOfMonth = date[getDate](),\n            month = date[getMonth](),\n            fullYear = date[getFullYear](),\n            lang = defaultOptions.lang,\n            langWeekdays = lang.weekdays,\n            shortWeekdays = lang.shortWeekdays,\n\n            // List all format keys. Custom formats can be added from the outside.\n            replacements = extend({\n\n                // Day\n                'a': shortWeekdays ? shortWeekdays[day] : langWeekdays[day].substr(0, 3), // Short weekday, like 'Mon'\n                'A': langWeekdays[day], // Long weekday, like 'Monday'\n                'd': pad(dayOfMonth), // Two digit day of the month, 01 to 31\n                'e': pad(dayOfMonth, 2, ' '), // Day of the month, 1 through 31\n                'w': day,\n\n                // Week (none implemented)\n                //'W': weekNumber(),\n\n                // Month\n                'b': lang.shortMonths[month], // Short month, like 'Jan'\n                'B': lang.months[month], // Long month, like 'January'\n                'm': pad(month + 1), // Two digit month number, 01 through 12\n\n                // Year\n                'y': fullYear.toString().substr(2, 2), // Two digits year, like 09 for 2009\n                'Y': fullYear, // Four digits year, like 2009\n\n                // Time\n                'H': pad(hours), // Two digits hours in 24h format, 00 through 23\n                'k': hours, // Hours in 24h format, 0 through 23\n                'I': pad((hours % 12) || 12), // Two digits hours in 12h format, 00 through 11\n                'l': (hours % 12) || 12, // Hours in 12h format, 1 through 12\n                'M': pad(date[getMinutes]()), // Two digits minutes, 00 through 59\n                'p': hours < 12 ? 'AM' : 'PM', // Upper case AM or PM\n                'P': hours < 12 ? 'am' : 'pm', // Lower case AM or PM\n                'S': pad(date.getSeconds()), // Two digits seconds, 00 through  59\n                'L': pad(mathRound(timestamp % 1000), 3) // Milliseconds (naming from Ruby)\n            }, Highcharts.dateFormats);\n\n\n        // do the replaces\n        for (key in replacements) {\n            while (format.indexOf('%' + key) !== -1) { // regex would do it in one line, but this is faster\n                format = format.replace('%' + key, typeof replacements[key] === 'function' ? replacements[key](timestamp) : replacements[key]);\n            }\n        }\n\n        // Optionally capitalize the string and return\n        return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;\n    };\n\n    /**\n     * Format a single variable. Similar to sprintf, without the % prefix.\n     */\n    function formatSingle(format, val) {\n        var floatRegex = /f$/,\n            decRegex = /\\.([0-9])/,\n            lang = defaultOptions.lang,\n            decimals;\n\n        if (floatRegex.test(format)) { // float\n            decimals = format.match(decRegex);\n            decimals = decimals ? decimals[1] : -1;\n            if (val !== null) {\n                val = Highcharts.numberFormat(\n                    val,\n                    decimals,\n                    lang.decimalPoint,\n                    format.indexOf(',') > -1 ? lang.thousandsSep : ''\n                );\n            }\n        } else {\n            val = dateFormat(format, val);\n        }\n        return val;\n    }\n\n    /**\n     * Format a string according to a subset of the rules of Python's String.format method.\n     */\n    function format(str, ctx) {\n        var splitter = '{',\n            isInside = false,\n            segment,\n            valueAndFormat,\n            path,\n            i,\n            len,\n            ret = [],\n            val,\n            index;\n\n        while ((index = str.indexOf(splitter)) !== -1) {\n\n            segment = str.slice(0, index);\n            if (isInside) { // we're on the closing bracket looking back\n\n                valueAndFormat = segment.split(':');\n                path = valueAndFormat.shift().split('.'); // get first and leave format\n                len = path.length;\n                val = ctx;\n\n                // Assign deeper paths\n                for (i = 0; i < len; i++) {\n                    val = val[path[i]];\n                }\n\n                // Format the replacement\n                if (valueAndFormat.length) {\n                    val = formatSingle(valueAndFormat.join(':'), val);\n                }\n\n                // Push the result and advance the cursor\n                ret.push(val);\n\n            } else {\n                ret.push(segment);\n\n            }\n            str = str.slice(index + 1); // the rest\n            isInside = !isInside; // toggle\n            splitter = isInside ? '}' : '{'; // now look for next matching bracket\n        }\n        ret.push(str);\n        return ret.join('');\n    }\n\n    /**\n     * Get the magnitude of a number\n     */\n    function getMagnitude(num) {\n        return math.pow(10, mathFloor(math.log(num) / math.LN10));\n    }\n\n    /**\n     * Take an interval and normalize it to multiples of 1, 2, 2.5 and 5\n     * @param {Number} interval\n     * @param {Array} multiples\n     * @param {Number} magnitude\n     * @param {Object} options\n     */\n    function normalizeTickInterval(interval, multiples, magnitude, allowDecimals, preventExceed) {\n        var normalized,\n            i,\n            retInterval = interval;\n\n        // round to a tenfold of 1, 2, 2.5 or 5\n        magnitude = pick(magnitude, 1);\n        normalized = interval / magnitude;\n\n        // multiples for a linear scale\n        if (!multiples) {\n            multiples = [1, 2, 2.5, 5, 10];\n\n            // the allowDecimals option\n            if (allowDecimals === false) {\n                if (magnitude === 1) {\n                    multiples = [1, 2, 5, 10];\n                } else if (magnitude <= 0.1) {\n                    multiples = [1 / magnitude];\n                }\n            }\n        }\n\n        // normalize the interval to the nearest multiple\n        for (i = 0; i < multiples.length; i++) {\n            retInterval = multiples[i];\n            if ((preventExceed && retInterval * magnitude >= interval) || // only allow tick amounts smaller than natural\n                    (!preventExceed && (normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2))) {\n                break;\n            }\n        }\n\n        // multiply back to the correct magnitude\n        retInterval *= magnitude;\n\n        return retInterval;\n    }\n\n\n    /**\n     * Utility method that sorts an object array and keeping the order of equal items.\n     * ECMA script standard does not specify the behaviour when items are equal.\n     */\n    function stableSort(arr, sortFunction) {\n        var length = arr.length,\n            sortValue,\n            i;\n\n        // Add index to each item\n        for (i = 0; i < length; i++) {\n            arr[i].safeI = i; // stable sort index\n        }\n\n        arr.sort(function (a, b) {\n            sortValue = sortFunction(a, b);\n            return sortValue === 0 ? a.safeI - b.safeI : sortValue;\n        });\n\n        // Remove index from items\n        for (i = 0; i < length; i++) {\n            delete arr[i].safeI; // stable sort index\n        }\n    }\n\n    /**\n     * Non-recursive method to find the lowest member of an array. Math.min raises a maximum\n     * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This\n     * method is slightly slower, but safe.\n     */\n    function arrayMin(data) {\n        var i = data.length,\n            min = data[0];\n\n        while (i--) {\n            if (data[i] < min) {\n                min = data[i];\n            }\n        }\n        return min;\n    }\n\n    /**\n     * Non-recursive method to find the lowest member of an array. Math.min raises a maximum\n     * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This\n     * method is slightly slower, but safe.\n     */\n    function arrayMax(data) {\n        var i = data.length,\n            max = data[0];\n\n        while (i--) {\n            if (data[i] > max) {\n                max = data[i];\n            }\n        }\n        return max;\n    }\n\n    /**\n     * Utility method that destroys any SVGElement or VMLElement that are properties on the given object.\n     * It loops all properties and invokes destroy if there is a destroy method. The property is\n     * then delete'ed.\n     * @param {Object} The object to destroy properties on\n     * @param {Object} Exception, do not destroy this property, only delete it.\n     */\n    function destroyObjectProperties(obj, except) {\n        var n;\n        for (n in obj) {\n            // If the object is non-null and destroy is defined\n            if (obj[n] && obj[n] !== except && obj[n].destroy) {\n                // Invoke the destroy\n                obj[n].destroy();\n            }\n\n            // Delete the property from the object.\n            delete obj[n];\n        }\n    }\n\n\n    /**\n     * Discard an element by moving it to the bin and delete\n     * @param {Object} The HTML node to discard\n     */\n    function discardElement(element) {\n        // create a garbage bin element, not part of the DOM\n        if (!garbageBin) {\n            garbageBin = createElement(DIV);\n        }\n\n        // move the node and empty bin\n        if (element) {\n            garbageBin.appendChild(element);\n        }\n        garbageBin.innerHTML = '';\n    }\n\n    /**\n     * Fix JS round off float errors\n     * @param {Number} num\n     */\n    function correctFloat(num, prec) {\n        return parseFloat(\n            num.toPrecision(prec || 14)\n        );\n    }\n\n    /**\n     * Set the global animation to either a given value, or fall back to the\n     * given chart's animation option\n     * @param {Object} animation\n     * @param {Object} chart\n     */\n    function setAnimation(animation, chart) {\n        chart.renderer.globalAnimation = pick(animation, chart.animation);\n    }\n\n    /**\n     * Get the animation in object form, where a disabled animation is always\n     * returned with duration: 0\n     */\n    function animObject(animation) {\n        return isObject(animation) ? merge(animation) : { duration: animation ? 500 : 0 };\n    }\n\n    /**\n     * The time unit lookup\n     */\n    timeUnits = {\n        millisecond: 1,\n        second: 1000,\n        minute: 60000,\n        hour: 3600000,\n        day: 24 * 3600000,\n        week: 7 * 24 * 3600000,\n        month: 28 * 24 * 3600000,\n        year: 364 * 24 * 3600000\n    };\n\n\n    /**\n     * Format a number and return a string based on input settings\n     * @param {Number} number The input number to format\n     * @param {Number} decimals The amount of decimals\n     * @param {String} decimalPoint The decimal point, defaults to the one given in the lang options\n     * @param {String} thousandsSep The thousands separator, defaults to the one given in the lang options\n     */\n    Highcharts.numberFormat = function (number, decimals, decimalPoint, thousandsSep) {\n\n        number = +number || 0;\n        decimals = +decimals;\n\n        var lang = defaultOptions.lang,\n            origDec = (number.toString().split('.')[1] || '').length,\n            decimalComponent,\n            strinteger,\n            thousands,\n            absNumber = Math.abs(number),\n            ret;\n\n        if (decimals === -1) {\n            decimals = Math.min(origDec, 20); // Preserve decimals. Not huge numbers (#3793).\n        } else if (!isNumber(decimals)) {\n            decimals = 2;\n        }\n\n        // A string containing the positive integer component of the number\n        strinteger = String(pInt(absNumber.toFixed(decimals)));\n\n        // Leftover after grouping into thousands. Can be 0, 1 or 3.\n        thousands = strinteger.length > 3 ? strinteger.length % 3 : 0;\n\n        // Language\n        decimalPoint = pick(decimalPoint, lang.decimalPoint);\n        thousandsSep = pick(thousandsSep, lang.thousandsSep);\n\n        // Start building the return\n        ret = number < 0 ? '-' : '';\n\n        // Add the leftover after grouping into thousands. For example, in the number 42 000 000,\n        // this line adds 42.\n        ret += thousands ? strinteger.substr(0, thousands) + thousandsSep : '';\n\n        // Add the remaining thousands groups, joined by the thousands separator\n        ret += strinteger.substr(thousands).replace(/(\\d{3})(?=\\d)/g, '$1' + thousandsSep);\n\n        // Add the decimal point and the decimal component\n        if (decimals) {\n            // Get the decimal component, and add power to avoid rounding errors with float numbers (#4573)\n            decimalComponent = Math.abs(absNumber - strinteger + Math.pow(10, -Math.max(decimals, origDec) - 1));\n            ret += decimalPoint + decimalComponent.toFixed(decimals).slice(2);\n        }\n\n        return ret;\n    };\n\n    /**\n     * Easing definition\n     * @param   {Number} pos Current position, ranging from 0 to 1\n     */\n    Math.easeInOutSine = function (pos) {\n        return -0.5 * (Math.cos(Math.PI * pos) - 1);\n    };\n\n    /**\n     * Internal method to return CSS value for given element and property\n     */\n    getStyle = function (el, prop) {\n\n        var style;\n\n        // For width and height, return the actual inner pixel size (#4913)\n        if (prop === 'width') {\n            return Math.min(el.offsetWidth, el.scrollWidth) - getStyle(el, 'padding-left') - getStyle(el, 'padding-right');\n        } else if (prop === 'height') {\n            return Math.min(el.offsetHeight, el.scrollHeight) - getStyle(el, 'padding-top') - getStyle(el, 'padding-bottom');\n        }\n\n        // Otherwise, get the computed style\n        style = win.getComputedStyle(el, undefined);\n        return style && pInt(style.getPropertyValue(prop));\n    };\n\n    /**\n     * Return the index of an item in an array, or -1 if not found\n     */\n    inArray = function (item, arr) {\n        return arr.indexOf ? arr.indexOf(item) : [].indexOf.call(arr, item);\n    };\n\n    /**\n     * Filter an array\n     */\n    grep = function (elements, callback) {\n        return [].filter.call(elements, callback);\n    };\n\n    /**\n     * Map an array\n     */\n    map = function (arr, fn) {\n        var results = [],\n            i = 0,\n            len = arr.length;\n\n        for (; i < len; i++) {\n            results[i] = fn.call(arr[i], arr[i], i, arr);\n        }\n\n        return results;\n    };\n\n    /**\n     * Get the element's offset position, corrected by overflow:auto.\n     */\n    offset = function (el) {\n        var docElem = doc.documentElement,\n            box = el.getBoundingClientRect();\n\n        return {\n            top: box.top  + (win.pageYOffset || docElem.scrollTop)  - (docElem.clientTop  || 0),\n            left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)\n        };\n    };\n\n    /**\n     * Stop running animation.\n     * A possible extension to this would be to stop a single property, when\n     * we want to continue animating others. Then assign the prop to the timer\n     * in the Fx.run method, and check for the prop here. This would be an improvement\n     * in all cases where we stop the animation from .attr. Instead of stopping\n     * everything, we can just stop the actual attributes we're setting.\n     */\n    stop = function (el) {\n\n        var i = timers.length;\n\n        // Remove timers related to this element (#4519)\n        while (i--) {\n            if (timers[i].elem === el) {\n                timers[i].stopped = true; // #4667\n            }\n        }\n    };\n\n    /**\n     * Utility for iterating over an array.\n     * @param {Array} arr\n     * @param {Function} fn\n     */\n    each = function (arr, fn) { // modern browsers\n        return Array.prototype.forEach.call(arr, fn);\n    };\n\n    /**\n     * Add an event listener\n     */\n    addEvent = function (el, type, fn) {\n    \n        var events = el.hcEvents = el.hcEvents || {};\n\n        function wrappedFn(e) {\n            e.target = e.srcElement || win; // #2820\n            fn.call(el, e);\n        }\n\n        // Handle DOM events in modern browsers\n        if (el.addEventListener) {\n            el.addEventListener(type, fn, false);\n\n        // Handle old IE implementation\n        } else if (el.attachEvent) {\n\n            if (!el.hcEventsIE) {\n                el.hcEventsIE = {};\n            }\n\n            // Link wrapped fn with original fn, so we can get this in removeEvent\n            el.hcEventsIE[fn.toString()] = wrappedFn;\n\n            el.attachEvent('on' + type, wrappedFn);\n        }\n\n        if (!events[type]) {\n            events[type] = [];\n        }\n\n        events[type].push(fn);\n    };\n\n    /**\n     * Remove event added with addEvent\n     */\n    removeEvent = function (el, type, fn) {\n    \n        var events,\n            hcEvents = el.hcEvents,\n            index;\n\n        function removeOneEvent(type, fn) {\n            if (el.removeEventListener) {\n                el.removeEventListener(type, fn, false);\n            } else if (el.attachEvent) {\n                fn = el.hcEventsIE[fn.toString()];\n                el.detachEvent('on' + type, fn);\n            }\n        }\n\n        function removeAllEvents() {\n            var types,\n                len,\n                n;\n\n            if (!el.nodeName) {\n                return; // break on non-DOM events\n            }\n\n            if (type) {\n                types = {};\n                types[type] = true;\n            } else {\n                types = hcEvents;\n            }\n\n            for (n in types) {\n                if (hcEvents[n]) {\n                    len = hcEvents[n].length;\n                    while (len--) {\n                        removeOneEvent(n, hcEvents[n][len]);\n                    }\n                }\n            }\n        }\n\n        if (hcEvents) {\n            if (type) {\n                events = hcEvents[type] || [];\n                if (fn) {\n                    index = inArray(fn, events);\n                    if (index > -1) {\n                        events.splice(index, 1);\n                        hcEvents[type] = events;\n                    }\n                    removeOneEvent(type, fn);\n\n                } else {\n                    removeAllEvents();\n                    hcEvents[type] = [];\n                }\n            } else {\n                removeAllEvents();\n                el.hcEvents = {};\n            }\n        }\n    };\n\n    /**\n     * Fire an event on a custom object\n     */\n    fireEvent = function (el, type, eventArguments, defaultFunction) {\n        var e,\n            hcEvents = el.hcEvents,\n            events,\n            len,\n            i,\n            fn;\n\n        eventArguments = eventArguments || {};\n\n        if (doc.createEvent && (el.dispatchEvent || el.fireEvent)) {\n            e = doc.createEvent('Events');\n            e.initEvent(type, true, true);\n            e.target = el;\n\n            extend(e, eventArguments);\n\n            if (el.dispatchEvent) {\n                el.dispatchEvent(e);\n            } else {\n                el.fireEvent(type, e);\n            }\n\n        } else if (hcEvents) {\n        \n            events = hcEvents[type] || [];\n            len = events.length;\n\n            // Attach a simple preventDefault function to skip default handler if called. \n            // The built-in defaultPrevented property is not overwritable (#5112)\n            if (!eventArguments.preventDefault) {\n                eventArguments.preventDefault = function () {\n                    eventArguments.defaultPrevented = true;\n                };\n            }\n\n            eventArguments.target = el;\n\n            // If the type is not set, we're running a custom event (#2297). If it is set,\n            // we're running a browser event, and setting it will cause en error in\n            // IE8 (#2465).\n            if (!eventArguments.type) {\n                eventArguments.type = type;\n            }\n        \n            for (i = 0; i < len; i++) {\n                fn = events[i];\n\n                // If the event handler return false, prevent the default handler from executing\n                if (fn && fn.call(el, eventArguments) === false) {\n                    eventArguments.preventDefault();\n                }\n            }\n        }\n            \n        // Run the default if not prevented\n        if (defaultFunction && !eventArguments.defaultPrevented) {\n            defaultFunction(eventArguments);\n        }\n    };\n\n    /**\n     * The global animate method, which uses Fx to create individual animators.\n     */\n    animate = function (el, params, opt) {\n        var start,\n            unit = '',\n            end,\n            fx,\n            args,\n            prop;\n\n        if (!isObject(opt)) { // Number or undefined/null\n            args = arguments;\n            opt = {\n                duration: args[2],\n                easing: args[3],\n                complete: args[4]\n            };\n        }\n        if (!isNumber(opt.duration)) {\n            opt.duration = 400;\n        }\n        opt.easing = typeof opt.easing === 'function' ? opt.easing : (Math[opt.easing] || Math.easeInOutSine);\n        opt.curAnim = merge(params);\n\n        for (prop in params) {\n            fx = new Fx(el, opt, prop);\n            end = null;\n\n            if (prop === 'd') {\n                fx.paths = fx.initPath(\n                    el,\n                    el.d,\n                    params.d\n                );\n                fx.toD = params.d;\n                start = 0;\n                end = 1;\n            } else if (el.attr) {\n                start = el.attr(prop);\n            } else {\n                start = parseFloat(getStyle(el, prop)) || 0;\n                if (prop !== 'opacity') {\n                    unit = 'px';\n                }\n            }\n\n            if (!end) {\n                end = params[prop];\n            }\n            if (end.match && end.match('px')) {\n                end = end.replace(/px/g, ''); // #4351\n            }\n            fx.run(start, end, unit);\n        }\n    };\n\n    /**\n     * Register Highcharts as a plugin in jQuery\n     */\n    if (win.jQuery) {\n        win.jQuery.fn.highcharts = function () {\n            var args = [].slice.call(arguments);\n\n            if (this[0]) { // this[0] is the renderTo div\n\n                // Create the chart\n                if (args[0]) {\n                    new Highcharts[ // eslint-disable-line no-new\n                        isString(args[0]) ? args.shift() : 'Chart' // Constructor defaults to Chart\n                    ](this[0], args[0], args[1]);\n                    return this;\n                }\n\n                // When called without parameters or with the return argument, return an existing chart\n                return charts[attr(this[0], 'data-highcharts-chart')];\n            }\n        };\n    }\n\n\n    /**\n     * Compatibility section to add support for legacy IE. This can be removed if old IE \n     * support is not needed.\n     */\n    if (doc && !doc.defaultView) {\n        getStyle = function (el, prop) {\n            var val,\n                alias = { width: 'clientWidth', height: 'clientHeight' }[prop];\n            \n            if (el.style[prop]) {\n                return pInt(el.style[prop]);\n            }\n            if (prop === 'opacity') {\n                prop = 'filter';\n            }\n\n            // Getting the rendered width and height\n            if (alias) {\n                el.style.zoom = 1;\n                return Math.max(el[alias] - 2 * getStyle(el, 'padding'), 0);\n            }\n        \n            val = el.currentStyle[prop.replace(/\\-(\\w)/g, function (a, b) {\n                return b.toUpperCase();\n            })];\n            if (prop === 'filter') {\n                val = val.replace(\n                    /alpha\\(opacity=([0-9]+)\\)/, \n                    function (a, b) { \n                        return b / 100; \n                    }\n                );\n            }\n        \n            return val === '' ? 1 : pInt(val);\n        };\n    }\n\n    if (!Array.prototype.forEach) {\n        each = function (arr, fn) { // legacy\n            var i = 0, \n                len = arr.length;\n            for (; i < len; i++) {\n                if (fn.call(arr[i], arr[i], i, arr) === false) {\n                    return i;\n                }\n            }\n        };\n    }\n\n    if (!Array.prototype.indexOf) {\n        inArray = function (item, arr) {\n            var len, \n                i = 0;\n\n            if (arr) {\n                len = arr.length;\n            \n                for (; i < len; i++) {\n                    if (arr[i] === item) {\n                        return i;\n                    }\n                }\n            }\n\n            return -1;\n        };\n    }\n\n    if (!Array.prototype.filter) {\n        grep = function (elements, fn) {\n            var ret = [],\n                i = 0,\n                length = elements.length;\n\n            for (; i < length; i++) {\n                if (fn(elements[i], i)) {\n                    ret.push(elements[i]);\n                }\n            }\n\n            return ret;\n        };\n    }\n\n    //--- End compatibility section ---\n\n    // Expose utilities\n    Highcharts.Fx = Fx;\n    Highcharts.inArray = inArray;\n    Highcharts.each = each;\n    Highcharts.grep = grep;\n    Highcharts.offset = offset;\n    Highcharts.map = map;\n    Highcharts.addEvent = addEvent;\n    Highcharts.removeEvent = removeEvent;\n    Highcharts.fireEvent = fireEvent;\n    Highcharts.animate = animate;\n    Highcharts.animObject = animObject;\n    Highcharts.stop = stop;\n\n    /* ****************************************************************************\n     * Handle the options                                                         *\n     *****************************************************************************/\n    defaultOptions = {\n        colors: ['#7cb5ec', '#434348', '#90ed7d', '#f7a35c',\n                '#8085e9', '#f15c80', '#e4d354', '#2b908f', '#f45b5b', '#91e8e1'],\n        symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],\n        lang: {\n            loading: 'Loading...',\n            months: ['January', 'February', 'March', 'April', 'May', 'June', 'July',\n                    'August', 'September', 'October', 'November', 'December'],\n            shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n            weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n            // invalidDate: '',\n            decimalPoint: '.',\n            numericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'], // SI prefixes used in axis labels\n            resetZoom: 'Reset zoom',\n            resetZoomTitle: 'Reset zoom level 1:1',\n            thousandsSep: ' '\n        },\n        global: {\n            useUTC: true,\n            //timezoneOffset: 0,\n            canvasToolsURL: 'http://code.highcharts.com/modules/canvas-tools.js',\n            VMLRadialGradientURL: 'http://code.highcharts.com/stock/4.2.7/gfx/vml-radial-gradient.png'\n        },\n        chart: {\n            //animation: true,\n            //alignTicks: false,\n            //reflow: true,\n            //className: null,\n            //events: { load, selection },\n            //margin: [null],\n            //marginTop: null,\n            //marginRight: null,\n            //marginBottom: null,\n            //marginLeft: null,\n            borderColor: '#4572A7',\n            //borderWidth: 0,\n            borderRadius: 0,\n            defaultSeriesType: 'line',\n            ignoreHiddenSeries: true,\n            //inverted: false,\n            //shadow: false,\n            spacing: [10, 10, 15, 10],\n            //spacingTop: 10,\n            //spacingRight: 10,\n            //spacingBottom: 15,\n            //spacingLeft: 10,\n            //style: {\n            //    fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Verdana, Arial, Helvetica, sans-serif', // default font\n            //    fontSize: '12px'\n            //},\n            backgroundColor: '#FFFFFF',\n            //plotBackgroundColor: null,\n            plotBorderColor: '#C0C0C0',\n            //plotBorderWidth: 0,\n            //plotShadow: false,\n            //zoomType: ''\n            resetZoomButton: {\n                theme: {\n                    zIndex: 20\n                },\n                position: {\n                    align: 'right',\n                    x: -10,\n                    //verticalAlign: 'top',\n                    y: 10\n                }\n                // relativeTo: 'plot'\n            },\n            width: null,\n            height: null\n        },\n        title: {\n            text: 'Chart title',\n            align: 'center',\n            // floating: false,\n            margin: 15,\n            // x: 0,\n            // verticalAlign: 'top',\n            // y: null,\n            style: {\n                color: '#333333',\n                fontSize: '18px'\n            },\n            widthAdjust: -44\n\n        },\n        subtitle: {\n            text: '',\n            align: 'center',\n            // floating: false\n            // x: 0,\n            // verticalAlign: 'top',\n            // y: null,\n            style: {\n                color: '#555555'\n            },\n            widthAdjust: -44\n        },\n\n        plotOptions: {\n            line: { // base series options\n                allowPointSelect: false,\n                showCheckbox: false,\n                animation: {\n                    duration: 1000\n                },\n                //connectNulls: false,\n                //cursor: 'default',\n                //clip: true,\n                //dashStyle: null,\n                //enableMouseTracking: true,\n                events: {},\n                //legendIndex: 0,\n                //linecap: 'round',\n                lineWidth: 2,\n                //shadow: false,\n                // stacking: null,\n                marker: {\n                    //enabled: true,\n                    //symbol: null,\n                    lineWidth: 0,\n                    radius: 4,\n                    lineColor: '#FFFFFF',\n                    //fillColor: null,\n                    states: { // states for a single point\n                        hover: {\n                            enabled: true,\n                            lineWidthPlus: 1,\n                            radiusPlus: 2\n                        },\n                        select: {\n                            fillColor: '#FFFFFF',\n                            lineColor: '#000000',\n                            lineWidth: 2\n                        }\n                    }\n                },\n                point: {\n                    events: {}\n                },\n                dataLabels: {\n                    align: 'center',\n                    // defer: true,\n                    // enabled: false,\n                    formatter: function () {\n                        return this.y === null ? '' : Highcharts.numberFormat(this.y, -1);\n                    },\n                    style: {\n                        color: 'contrast',\n                        fontSize: '11px',\n                        fontWeight: 'bold',\n                        textShadow: '0 0 6px contrast, 0 0 3px contrast'\n                    },\n                    verticalAlign: 'bottom', // above singular point\n                    x: 0,\n                    y: 0,\n                    // backgroundColor: undefined,\n                    // borderColor: undefined,\n                    // borderRadius: undefined,\n                    // borderWidth: undefined,\n                    padding: 5\n                    // shadow: false\n                },\n                cropThreshold: 300, // draw points outside the plot area when the number of points is less than this\n                pointRange: 0,\n                //pointStart: 0,\n                //pointInterval: 1,\n                //showInLegend: null, // auto: true for standalone series, false for linked series\n                softThreshold: true,\n                states: { // states for the entire series\n                    hover: {\n                        //enabled: false,\n                        lineWidthPlus: 1,\n                        marker: {\n                            // lineWidth: base + 1,\n                            // radius: base + 1\n                        },\n                        halo: {\n                            size: 10,\n                            opacity: 0.25\n                        }\n                    },\n                    select: {\n                        marker: {}\n                    }\n                },\n                stickyTracking: true,\n                //tooltip: {\n                    //pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.y}</b>'\n                    //valueDecimals: null,\n                    //xDateFormat: '%A, %b %e, %Y',\n                    //valuePrefix: '',\n                    //ySuffix: ''\n                //}\n                turboThreshold: 1000\n                // zIndex: null\n            }\n        },\n        labels: {\n            //items: [],\n            style: {\n                //font: defaultFont,\n                position: ABSOLUTE,\n                color: '#3E576F'\n            }\n        },\n        legend: {\n            enabled: true,\n            align: 'center',\n            //floating: false,\n            layout: 'horizontal',\n            labelFormatter: function () {\n                return this.name;\n            },\n            //borderWidth: 0,\n            borderColor: '#909090',\n            borderRadius: 0,\n            navigation: {\n                // animation: true,\n                activeColor: '#274b6d',\n                // arrowSize: 12\n                inactiveColor: '#CCC'\n                // style: {} // text styles\n            },\n            // margin: 20,\n            // reversed: false,\n            shadow: false,\n            // backgroundColor: null,\n            /*style: {\n                padding: '5px'\n            },*/\n            itemStyle: {\n                color: '#333333',\n                fontSize: '12px',\n                fontWeight: 'bold'\n            },\n            itemHoverStyle: {\n                //cursor: 'pointer', removed as of #601\n                color: '#000'\n            },\n            itemHiddenStyle: {\n                color: '#CCC'\n            },\n            itemCheckboxStyle: {\n                position: ABSOLUTE,\n                width: '13px', // for IE precision\n                height: '13px'\n            },\n            // itemWidth: undefined,\n            // symbolRadius: 0,\n            // symbolWidth: 16,\n            symbolPadding: 5,\n            verticalAlign: 'bottom',\n            // width: undefined,\n            x: 0,\n            y: 0,\n            title: {\n                //text: null,\n                style: {\n                    fontWeight: 'bold'\n                }\n            }\n        },\n\n        loading: {\n            // hideDuration: 100,\n            labelStyle: {\n                fontWeight: 'bold',\n                position: RELATIVE,\n                top: '45%'\n            },\n            // showDuration: 0,\n            style: {\n                position: ABSOLUTE,\n                backgroundColor: 'white',\n                opacity: 0.5,\n                textAlign: 'center'\n            }\n        },\n\n        tooltip: {\n            enabled: true,\n            animation: hasSVG,\n            //crosshairs: null,\n            backgroundColor: 'rgba(249, 249, 249, .85)',\n            borderWidth: 1,\n            borderRadius: 3,\n            dateTimeLabelFormats: {\n                millisecond: '%A, %b %e, %H:%M:%S.%L',\n                second: '%A, %b %e, %H:%M:%S',\n                minute: '%A, %b %e, %H:%M',\n                hour: '%A, %b %e, %H:%M',\n                day: '%A, %b %e, %Y',\n                week: 'Week from %A, %b %e, %Y',\n                month: '%B %Y',\n                year: '%Y'\n            },\n            footerFormat: '',\n            //formatter: defaultFormatter,\n            headerFormat: '<span style=\"font-size: 10px\">{point.key}</span><br/>',\n            pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.y}</b><br/>',\n            shadow: true,\n            //shape: 'callout',\n            //shared: false,\n            snap: isTouchDevice ? 25 : 10,\n            style: {\n                color: '#333333',\n                cursor: 'default',\n                fontSize: '12px',\n                padding: '8px',\n                pointerEvents: 'none', // #1686 http://caniuse.com/#feat=pointer-events\n                whiteSpace: 'nowrap'\n            }\n            //xDateFormat: '%A, %b %e, %Y',\n            //valueDecimals: null,\n            //valuePrefix: '',\n            //valueSuffix: ''\n        },\n\n        credits: {\n            enabled: true,\n            text: 'Highcharts.com',\n            href: 'http://www.highcharts.com',\n            position: {\n                align: 'right',\n                x: -10,\n                verticalAlign: 'bottom',\n                y: -5\n            },\n            style: {\n                cursor: 'pointer',\n                color: '#909090',\n                fontSize: '9px'\n            }\n        }\n    };\n\n\n\n    /**\n     * Set the time methods globally based on the useUTC option. Time method can be either\n     * local time or UTC (default).\n     */\n    function setTimeMethods() {\n        var globalOptions = defaultOptions.global,\n            useUTC = globalOptions.useUTC,\n            GET = useUTC ? 'getUTC' : 'get',\n            SET = useUTC ? 'setUTC' : 'set';\n\n\n        Date = globalOptions.Date || win.Date;\n        timezoneOffset = useUTC && globalOptions.timezoneOffset;\n        getTimezoneOffset = useUTC && globalOptions.getTimezoneOffset;\n        makeTime = function (year, month, date, hours, minutes, seconds) {\n            var d;\n            if (useUTC) {\n                d = Date.UTC.apply(0, arguments);\n                d += getTZOffset(d);\n            } else {\n                d = new Date(\n                    year,\n                    month,\n                    pick(date, 1),\n                    pick(hours, 0),\n                    pick(minutes, 0),\n                    pick(seconds, 0)\n                ).getTime();\n            }\n            return d;\n        };\n        getMinutes =      GET + 'Minutes';\n        getHours =        GET + 'Hours';\n        getDay =          GET + 'Day';\n        getDate =         GET + 'Date';\n        getMonth =        GET + 'Month';\n        getFullYear =     GET + 'FullYear';\n        setMilliseconds = SET + 'Milliseconds';\n        setSeconds =      SET + 'Seconds';\n        setMinutes =      SET + 'Minutes';\n        setHours =        SET + 'Hours';\n        setDate =         SET + 'Date';\n        setMonth =        SET + 'Month';\n        setFullYear =     SET + 'FullYear';\n\n    }\n\n    /**\n     * Merge the default options with custom options and return the new options structure\n     * @param {Object} options The new custom options\n     */\n    function setOptions(options) {\n\n        // Copy in the default options\n        defaultOptions = merge(true, defaultOptions, options);\n\n        // Apply UTC\n        setTimeMethods();\n\n        return defaultOptions;\n    }\n\n    /**\n     * Get the updated default options. Until 3.0.7, merely exposing defaultOptions for outside modules\n     * wasn't enough because the setOptions method created a new object.\n     */\n    function getOptions() {\n        return defaultOptions;\n    }\n\n\n\n\n\n\n    // Series defaults\n    var defaultPlotOptions = defaultOptions.plotOptions,\n        defaultSeriesOptions = defaultPlotOptions.line;\n\n    // set the default time methods\n    setTimeMethods();\n\n\n    /**\n     * Handle color operations. The object methods are chainable.\n     * @param {String} input The input color in either rbga or hex format\n     */\n    function Color(input) {\n        // Backwards compatibility, allow instanciation without new\n        if (!(this instanceof Color)) {\n            return new Color(input);\n        }\n        // Initialize\n        this.init(input);\n    }\n    Color.prototype = {\n\n        // Collection of parsers. This can be extended from the outside by pushing parsers\n        // to Highcharts.Colors.prototype.parsers.\n        parsers: [{\n            // RGBA color\n            regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n            parse: function (result) {\n                return [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];\n            }\n        }, {\n            // HEX color\n            regex: /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/,\n            parse: function (result) {\n                return [pInt(result[1], 16), pInt(result[2], 16), pInt(result[3], 16), 1];\n            }\n        }, {\n            // RGB color\n            regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n            parse: function (result) {\n                return [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];\n            }\n        }],\n\n        /**\n         * Parse the input color to rgba array\n         * @param {String} input\n         */\n        init: function (input) {\n            var result,\n                rgba,\n                i,\n                parser;\n\n            this.input = input;\n\n            // Gradients\n            if (input && input.stops) {\n                this.stops = map(input.stops, function (stop) {\n                    return new Color(stop[1]);\n                });\n\n            // Solid colors\n            } else {\n                i = this.parsers.length;\n                while (i-- && !rgba) {\n                    parser = this.parsers[i];\n                    result = parser.regex.exec(input);\n                    if (result) {\n                        rgba = parser.parse(result);\n                    }\n                }\n            }\n            this.rgba = rgba || [];\n        },\n\n        /**\n         * Return the color a specified format\n         * @param {String} format\n         */\n        get: function (format) {\n            var input = this.input,\n                rgba = this.rgba,\n                ret;\n\n            if (this.stops) {\n                ret = merge(input);\n                ret.stops = [].concat(ret.stops);\n                each(this.stops, function (stop, i) {\n                    ret.stops[i] = [ret.stops[i][0], stop.get(format)];\n                });\n\n            // it's NaN if gradient colors on a column chart\n            } else if (rgba && isNumber(rgba[0])) {\n                if (format === 'rgb' || (!format && rgba[3] === 1)) {\n                    ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';\n                } else if (format === 'a') {\n                    ret = rgba[3];\n                } else {\n                    ret = 'rgba(' + rgba.join(',') + ')';\n                }\n            } else {\n                ret = input;\n            }\n            return ret;\n        },\n\n        /**\n         * Brighten the color\n         * @param {Number} alpha\n         */\n        brighten: function (alpha) {\n            var i, \n                rgba = this.rgba;\n\n            if (this.stops) {\n                each(this.stops, function (stop) {\n                    stop.brighten(alpha);\n                });\n\n            } else if (isNumber(alpha) && alpha !== 0) {\n                for (i = 0; i < 3; i++) {\n                    rgba[i] += pInt(alpha * 255);\n\n                    if (rgba[i] < 0) {\n                        rgba[i] = 0;\n                    }\n                    if (rgba[i] > 255) {\n                        rgba[i] = 255;\n                    }\n                }\n            }\n            return this;\n        },\n\n        /**\n         * Set the color's opacity to a given alpha value\n         * @param {Number} alpha\n         */\n        setOpacity: function (alpha) {\n            this.rgba[3] = alpha;\n            return this;\n        }\n    };\n\n\n    /**\n     * A wrapper object for SVG elements\n     */\n    function SVGElement() {}\n\n    SVGElement.prototype = {\n\n        // Default base for animation\n        opacity: 1,\n        // For labels, these CSS properties are applied to the <text> node directly\n        textProps: ['direction', 'fontSize', 'fontWeight', 'fontFamily', 'fontStyle', 'color',\n            'lineHeight', 'width', 'textDecoration', 'textOverflow', 'textShadow'],\n\n        /**\n         * Initialize the SVG renderer\n         * @param {Object} renderer\n         * @param {String} nodeName\n         */\n        init: function (renderer, nodeName) {\n            var wrapper = this;\n            wrapper.element = nodeName === 'span' ?\n                    createElement(nodeName) :\n                    doc.createElementNS(SVG_NS, nodeName);\n            wrapper.renderer = renderer;\n        },\n\n        /**\n         * Animate a given attribute\n         * @param {Object} params\n         * @param {Number} options Options include duration, easing, step and complete\n         * @param {Function} complete Function to perform at the end of animation\n         */\n        animate: function (params, options, complete) {\n            var animOptions = pick(options, this.renderer.globalAnimation, true);\n            stop(this); // stop regardless of animation actually running, or reverting to .attr (#607)\n            if (animOptions) {\n                if (complete) { // allows using a callback with the global animation without overwriting it\n                    animOptions.complete = complete;\n                }\n                animate(this, params, animOptions);\n            } else {\n                this.attr(params, null, complete);\n            }\n            return this;\n        },\n\n        /**\n         * Build an SVG gradient out of a common JavaScript configuration object\n         */\n        colorGradient: function (color, prop, elem) {\n            var renderer = this.renderer,\n                colorObject,\n                gradName,\n                gradAttr,\n                radAttr,\n                gradients,\n                gradientObject,\n                stops,\n                stopColor,\n                stopOpacity,\n                radialReference,\n                n,\n                id,\n                key = [],\n                value;\n\n            // Apply linear or radial gradients\n            if (color.linearGradient) {\n                gradName = 'linearGradient';\n            } else if (color.radialGradient) {\n                gradName = 'radialGradient';\n            }\n\n            if (gradName) {\n                gradAttr = color[gradName];\n                gradients = renderer.gradients;\n                stops = color.stops;\n                radialReference = elem.radialReference;\n\n                // Keep < 2.2 kompatibility\n                if (isArray(gradAttr)) {\n                    color[gradName] = gradAttr = {\n                        x1: gradAttr[0],\n                        y1: gradAttr[1],\n                        x2: gradAttr[2],\n                        y2: gradAttr[3],\n                        gradientUnits: 'userSpaceOnUse'\n                    };\n                }\n\n                // Correct the radial gradient for the radial reference system\n                if (gradName === 'radialGradient' && radialReference && !defined(gradAttr.gradientUnits)) {\n                    radAttr = gradAttr; // Save the radial attributes for updating\n                    gradAttr = merge(gradAttr,\n                        renderer.getRadialAttr(radialReference, radAttr),\n                        { gradientUnits: 'userSpaceOnUse' }\n                        );\n                }\n\n                // Build the unique key to detect whether we need to create a new element (#1282)\n                for (n in gradAttr) {\n                    if (n !== 'id') {\n                        key.push(n, gradAttr[n]);\n                    }\n                }\n                for (n in stops) {\n                    key.push(stops[n]);\n                }\n                key = key.join(',');\n\n                // Check if a gradient object with the same config object is created within this renderer\n                if (gradients[key]) {\n                    id = gradients[key].attr('id');\n\n                } else {\n\n                    // Set the id and create the element\n                    gradAttr.id = id = PREFIX + idCounter++;\n                    gradients[key] = gradientObject = renderer.createElement(gradName)\n                        .attr(gradAttr)\n                        .add(renderer.defs);\n\n                    gradientObject.radAttr = radAttr;\n\n                    // The gradient needs to keep a list of stops to be able to destroy them\n                    gradientObject.stops = [];\n                    each(stops, function (stop) {\n                        var stopObject;\n                        if (stop[1].indexOf('rgba') === 0) {\n                            colorObject = Color(stop[1]);\n                            stopColor = colorObject.get('rgb');\n                            stopOpacity = colorObject.get('a');\n                        } else {\n                            stopColor = stop[1];\n                            stopOpacity = 1;\n                        }\n                        stopObject = renderer.createElement('stop').attr({\n                            offset: stop[0],\n                            'stop-color': stopColor,\n                            'stop-opacity': stopOpacity\n                        }).add(gradientObject);\n\n                        // Add the stop element to the gradient\n                        gradientObject.stops.push(stopObject);\n                    });\n                }\n\n                // Set the reference to the gradient object\n                value = 'url(' + renderer.url + '#' + id + ')';\n                elem.setAttribute(prop, value);\n                elem.gradient = key;\n\n                // Allow the color to be concatenated into tooltips formatters etc. (#2995)\n                color.toString = function () {\n                    return value;\n                };\n            }\n        },\n\n        /**\n         * Apply a polyfill to the text-stroke CSS property, by copying the text element\n         * and apply strokes to the copy.\n         *\n         * Contrast checks at http://jsfiddle.net/highcharts/43soe9m1/2/\n         */\n        applyTextShadow: function (textShadow) {\n            var elem = this.element,\n                tspans,\n                hasContrast = textShadow.indexOf('contrast') !== -1,\n                styles = {},\n                forExport = this.renderer.forExport,\n                // IE10 and IE11 report textShadow in elem.style even though it doesn't work. Check\n                // this again with new IE release. In exports, the rendering is passed to PhantomJS.\n                supports = forExport || (elem.style.textShadow !== UNDEFINED && !isMS);\n\n            // When the text shadow is set to contrast, use dark stroke for light text and vice versa\n            if (hasContrast) {\n                styles.textShadow = textShadow = textShadow.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));\n            }\n\n            // Safari with retina displays as well as PhantomJS bug (#3974). Firefox does not tolerate this,\n            // it removes the text shadows.\n            if (isWebKit || forExport) {\n                styles.textRendering = 'geometricPrecision';\n            }\n\n            /* Selective side-by-side testing in supported browser (http://jsfiddle.net/highcharts/73L1ptrh/)\n            if (elem.textContent.indexOf('2.') === 0) {\n                elem.style['text-shadow'] = 'none';\n                supports = false;\n            }\n            // */\n\n            // No reason to polyfill, we've got native support\n            if (supports) {\n                this.css(styles); // Apply altered textShadow or textRendering workaround\n            } else {\n\n                this.fakeTS = true; // Fake text shadow\n\n                // In order to get the right y position of the clones,\n                // copy over the y setter\n                this.ySetter = this.xSetter;\n\n                tspans = [].slice.call(elem.getElementsByTagName('tspan'));\n                each(textShadow.split(/\\s?,\\s?/g), function (textShadow) {\n                    var firstChild = elem.firstChild,\n                        color,\n                        strokeWidth;\n\n                    textShadow = textShadow.split(' ');\n                    color = textShadow[textShadow.length - 1];\n\n                    // Approximately tune the settings to the text-shadow behaviour\n                    strokeWidth = textShadow[textShadow.length - 2];\n\n                    if (strokeWidth) {\n                        each(tspans, function (tspan, y) {\n                            var clone;\n\n                            // Let the first line start at the correct X position\n                            if (y === 0) {\n                                tspan.setAttribute('x', elem.getAttribute('x'));\n                                y = elem.getAttribute('y');\n                                tspan.setAttribute('y', y || 0);\n                                if (y === null) {\n                                    elem.setAttribute('y', 0);\n                                }\n                            }\n\n                            // Create the clone and apply shadow properties\n                            clone = tspan.cloneNode(1);\n                            attr(clone, {\n                                'class': PREFIX + 'text-shadow',\n                                'fill': color,\n                                'stroke': color,\n                                'stroke-opacity': 1 / mathMax(pInt(strokeWidth), 3),\n                                'stroke-width': strokeWidth,\n                                'stroke-linejoin': 'round'\n                            });\n                            elem.insertBefore(clone, firstChild);\n                        });\n                    }\n                });\n            }\n        },\n\n        /**\n         * Set or get a given attribute\n         * @param {Object|String} hash\n         * @param {Mixed|Undefined} val\n         */\n        attr: function (hash, val, complete) {\n            var key,\n                value,\n                element = this.element,\n                hasSetSymbolSize,\n                ret = this,\n                skipAttr,\n                setter;\n\n            // single key-value pair\n            if (typeof hash === 'string' && val !== UNDEFINED) {\n                key = hash;\n                hash = {};\n                hash[key] = val;\n            }\n\n            // used as a getter: first argument is a string, second is undefined\n            if (typeof hash === 'string') {\n                ret = (this[hash + 'Getter'] || this._defaultGetter).call(this, hash, element);\n\n            // setter\n            } else {\n\n                for (key in hash) {\n                    value = hash[key];\n                    skipAttr = false;\n\n\n\n                    if (this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(key)) {\n                        if (!hasSetSymbolSize) {\n                            this.symbolAttr(hash);\n                            hasSetSymbolSize = true;\n                        }\n                        skipAttr = true;\n                    }\n\n                    if (this.rotation && (key === 'x' || key === 'y')) {\n                        this.doTransform = true;\n                    }\n\n                    if (!skipAttr) {\n                        setter = this[key + 'Setter'] || this._defaultSetter;\n                        setter.call(this, value, key, element);\n\n                        // Let the shadow follow the main element\n                        if (this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(key)) {\n                            this.updateShadows(key, value, setter);\n                        }\n                    }\n                }\n\n                // Update transform. Do this outside the loop to prevent redundant updating for batch setting\n                // of attributes.\n                if (this.doTransform) {\n                    this.updateTransform();\n                    this.doTransform = false;\n                }\n\n            }\n\n            // In accordance with animate, run a complete callback\n            if (complete) {\n                complete();\n            }\n\n            return ret;\n        },\n\n        /**\n         * Update the shadow elements with new attributes\n         * @param   {String}        key    The attribute name\n         * @param   {String|Number} value  The value of the attribute\n         * @param   {Function}      setter The setter function, inherited from the parent wrapper\n         * @returns {undefined}\n         */\n        updateShadows: function (key, value, setter) {\n            var shadows = this.shadows,\n                i = shadows.length;\n\n            while (i--) {\n                setter.call(\n                    shadows[i], \n                    key === 'height' ?\n                        Math.max(value - (shadows[i].cutHeight || 0), 0) :\n                        key === 'd' ? this.d : value, \n                    key, \n                    shadows[i]\n                );\n            }\n        },\n\n        /**\n         * Add a class name to an element\n         */\n        addClass: function (className) {\n            var element = this.element,\n                currentClassName = attr(element, 'class') || '';\n\n            if (currentClassName.indexOf(className) === -1) {\n                attr(element, 'class', currentClassName + ' ' + className);\n            }\n            return this;\n        },\n        /* hasClass and removeClass are not (yet) needed\n        hasClass: function (className) {\n            return attr(this.element, 'class').indexOf(className) !== -1;\n        },\n        removeClass: function (className) {\n            attr(this.element, 'class', attr(this.element, 'class').replace(className, ''));\n            return this;\n        },\n        */\n\n        /**\n         * If one of the symbol size affecting parameters are changed,\n         * check all the others only once for each call to an element's\n         * .attr() method\n         * @param {Object} hash\n         */\n        symbolAttr: function (hash) {\n            var wrapper = this;\n\n            each(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR', 'anchorX', 'anchorY'], function (key) {\n                wrapper[key] = pick(hash[key], wrapper[key]);\n            });\n\n            wrapper.attr({\n                d: wrapper.renderer.symbols[wrapper.symbolName](\n                    wrapper.x,\n                    wrapper.y,\n                    wrapper.width,\n                    wrapper.height,\n                    wrapper\n                )\n            });\n        },\n\n        /**\n         * Apply a clipping path to this object\n         * @param {String} id\n         */\n        clip: function (clipRect) {\n            return this.attr('clip-path', clipRect ? 'url(' + this.renderer.url + '#' + clipRect.id + ')' : NONE);\n        },\n\n        /**\n         * Calculate the coordinates needed for drawing a rectangle crisply and return the\n         * calculated attributes\n         * @param {Number} strokeWidth\n         * @param {Number} x\n         * @param {Number} y\n         * @param {Number} width\n         * @param {Number} height\n         */\n        crisp: function (rect) {\n\n            var wrapper = this,\n                key,\n                attribs = {},\n                normalizer,\n                strokeWidth = wrapper.strokeWidth || 0;\n\n            normalizer = mathRound(strokeWidth) % 2 / 2; // mathRound because strokeWidth can sometimes have roundoff errors\n\n            // normalize for crisp edges\n            rect.x = mathFloor(rect.x || wrapper.x || 0) + normalizer;\n            rect.y = mathFloor(rect.y || wrapper.y || 0) + normalizer;\n            rect.width = mathFloor((rect.width || wrapper.width || 0) - 2 * normalizer);\n            rect.height = mathFloor((rect.height || wrapper.height || 0) - 2 * normalizer);\n            rect.strokeWidth = strokeWidth;\n\n            for (key in rect) {\n                if (wrapper[key] !== rect[key]) { // only set attribute if changed\n                    wrapper[key] = attribs[key] = rect[key];\n                }\n            }\n\n            return attribs;\n        },\n\n        /**\n         * Set styles for the element\n         * @param {Object} styles\n         */\n        css: function (styles) {\n            var elemWrapper = this,\n                oldStyles = elemWrapper.styles,\n                newStyles = {},\n                elem = elemWrapper.element,\n                textWidth,\n                n,\n                serializedCss = '',\n                hyphenate,\n                hasNew = !oldStyles;\n\n            // convert legacy\n            if (styles && styles.color) {\n                styles.fill = styles.color;\n            }\n\n            // Filter out existing styles to increase performance (#2640)\n            if (oldStyles) {\n                for (n in styles) {\n                    if (styles[n] !== oldStyles[n]) {\n                        newStyles[n] = styles[n];\n                        hasNew = true;\n                    }\n                }\n            }\n            if (hasNew) {\n                textWidth = elemWrapper.textWidth =\n                    (styles && styles.width && elem.nodeName.toLowerCase() === 'text' && pInt(styles.width)) ||\n                    elemWrapper.textWidth; // #3501\n\n                // Merge the new styles with the old ones\n                if (oldStyles) {\n                    styles = extend(\n                        oldStyles,\n                        newStyles\n                    );\n                }\n\n                // store object\n                elemWrapper.styles = styles;\n\n                if (textWidth && (useCanVG || (!hasSVG && elemWrapper.renderer.forExport))) {\n                    delete styles.width;\n                }\n\n                // serialize and set style attribute\n                if (isMS && !hasSVG) {\n                    css(elemWrapper.element, styles);\n                } else {\n                    hyphenate = function (a, b) {\n                        return '-' + b.toLowerCase();\n                    };\n                    for (n in styles) {\n                        serializedCss += n.replace(/([A-Z])/g, hyphenate) + ':' + styles[n] + ';';\n                    }\n                    attr(elem, 'style', serializedCss); // #1881\n                }\n\n\n                // re-build text\n                if (textWidth && elemWrapper.added) {\n                    elemWrapper.renderer.buildText(elemWrapper);\n                }\n            }\n\n            return elemWrapper;\n        },\n\n        /**\n         * Add an event listener\n         * @param {String} eventType\n         * @param {Function} handler\n         */\n        on: function (eventType, handler) {\n            var svgElement = this,\n                element = svgElement.element;\n\n            // touch\n            if (hasTouch && eventType === 'click') {\n                element.ontouchstart = function (e) {\n                    svgElement.touchEventFired = Date.now();\n                    e.preventDefault();\n                    handler.call(element, e);\n                };\n                element.onclick = function (e) {\n                    if (userAgent.indexOf('Android') === -1 || Date.now() - (svgElement.touchEventFired || 0) > 1100) { // #2269\n                        handler.call(element, e);\n                    }\n                };\n            } else {\n                // simplest possible event model for internal use\n                element['on' + eventType] = handler;\n            }\n            return this;\n        },\n\n        /**\n         * Set the coordinates needed to draw a consistent radial gradient across\n         * pie slices regardless of positioning inside the chart. The format is\n         * [centerX, centerY, diameter] in pixels.\n         */\n        setRadialReference: function (coordinates) {\n            var existingGradient = this.renderer.gradients[this.element.gradient];\n\n            this.element.radialReference = coordinates;\n\n            // On redrawing objects with an existing gradient, the gradient needs\n            // to be repositioned (#3801)\n            if (existingGradient && existingGradient.radAttr) {\n                existingGradient.animate(\n                    this.renderer.getRadialAttr(\n                        coordinates,\n                        existingGradient.radAttr\n                    )\n                );\n            }\n\n            return this;\n        },\n\n        /**\n         * Move an object and its children by x and y values\n         * @param {Number} x\n         * @param {Number} y\n         */\n        translate: function (x, y) {\n            return this.attr({\n                translateX: x,\n                translateY: y\n            });\n        },\n\n        /**\n         * Invert a group, rotate and flip\n         */\n        invert: function () {\n            var wrapper = this;\n            wrapper.inverted = true;\n            wrapper.updateTransform();\n            return wrapper;\n        },\n\n        /**\n         * Private method to update the transform attribute based on internal\n         * properties\n         */\n        updateTransform: function () {\n            var wrapper = this,\n                translateX = wrapper.translateX || 0,\n                translateY = wrapper.translateY || 0,\n                scaleX = wrapper.scaleX,\n                scaleY = wrapper.scaleY,\n                inverted = wrapper.inverted,\n                rotation = wrapper.rotation,\n                element = wrapper.element,\n                transform;\n\n            // flipping affects translate as adjustment for flipping around the group's axis\n            if (inverted) {\n                translateX += wrapper.attr('width');\n                translateY += wrapper.attr('height');\n            }\n\n            // Apply translate. Nearly all transformed elements have translation, so instead\n            // of checking for translate = 0, do it always (#1767, #1846).\n            transform = ['translate(' + translateX + ',' + translateY + ')'];\n\n            // apply rotation\n            if (inverted) {\n                transform.push('rotate(90) scale(-1,1)');\n            } else if (rotation) { // text rotation\n                transform.push('rotate(' + rotation + ' ' + (element.getAttribute('x') || 0) + ' ' + (element.getAttribute('y') || 0) + ')');\n\n                // Delete bBox memo when the rotation changes\n                //delete wrapper.bBox;\n            }\n\n            // apply scale\n            if (defined(scaleX) || defined(scaleY)) {\n                transform.push('scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')');\n            }\n\n            if (transform.length) {\n                element.setAttribute('transform', transform.join(' '));\n            }\n        },\n        /**\n         * Bring the element to the front\n         */\n        toFront: function () {\n            var element = this.element;\n            element.parentNode.appendChild(element);\n            return this;\n        },\n\n\n        /**\n         * Break down alignment options like align, verticalAlign, x and y\n         * to x and y relative to the chart.\n         *\n         * @param {Object} alignOptions\n         * @param {Boolean} alignByTranslate\n         * @param {String[Object} box The box to align to, needs a width and height. When the\n         *        box is a string, it refers to an object in the Renderer. For example, when\n         *        box is 'spacingBox', it refers to Renderer.spacingBox which holds width, height\n         *        x and y properties.\n         *\n         */\n        align: function (alignOptions, alignByTranslate, box) {\n            var align,\n                vAlign,\n                x,\n                y,\n                attribs = {},\n                alignTo,\n                renderer = this.renderer,\n                alignedObjects = renderer.alignedObjects;\n\n            // First call on instanciate\n            if (alignOptions) {\n                this.alignOptions = alignOptions;\n                this.alignByTranslate = alignByTranslate;\n                if (!box || isString(box)) { // boxes other than renderer handle this internally\n                    this.alignTo = alignTo = box || 'renderer';\n                    erase(alignedObjects, this); // prevent duplicates, like legendGroup after resize\n                    alignedObjects.push(this);\n                    box = null; // reassign it below\n                }\n\n            // When called on resize, no arguments are supplied\n            } else {\n                alignOptions = this.alignOptions;\n                alignByTranslate = this.alignByTranslate;\n                alignTo = this.alignTo;\n            }\n\n            box = pick(box, renderer[alignTo], renderer);\n\n            // Assign variables\n            align = alignOptions.align;\n            vAlign = alignOptions.verticalAlign;\n            x = (box.x || 0) + (alignOptions.x || 0); // default: left align\n            y = (box.y || 0) + (alignOptions.y || 0); // default: top align\n\n            // Align\n            if (align === 'right' || align === 'center') {\n                x += (box.width - (alignOptions.width || 0)) /\n                        { right: 1, center: 2 }[align];\n            }\n            attribs[alignByTranslate ? 'translateX' : 'x'] = mathRound(x);\n\n\n            // Vertical align\n            if (vAlign === 'bottom' || vAlign === 'middle') {\n                y += (box.height - (alignOptions.height || 0)) /\n                        ({ bottom: 1, middle: 2 }[vAlign] || 1);\n\n            }\n            attribs[alignByTranslate ? 'translateY' : 'y'] = mathRound(y);\n\n            // Animate only if already placed\n            this[this.placed ? 'animate' : 'attr'](attribs);\n            this.placed = true;\n            this.alignAttr = attribs;\n\n            return this;\n        },\n\n        /**\n         * Get the bounding box (width, height, x and y) for the element\n         */\n        getBBox: function (reload, rot) {\n            var wrapper = this,\n                bBox, // = wrapper.bBox,\n                renderer = wrapper.renderer,\n                width,\n                height,\n                rotation,\n                rad,\n                element = wrapper.element,\n                styles = wrapper.styles,\n                textStr = wrapper.textStr,\n                textShadow,\n                elemStyle = element.style,\n                toggleTextShadowShim,\n                cache = renderer.cache,\n                cacheKeys = renderer.cacheKeys,\n                cacheKey;\n\n            rotation = pick(rot, wrapper.rotation);\n            rad = rotation * deg2rad;\n\n            if (textStr !== UNDEFINED) {\n\n                cacheKey = \n\n                    // Since numbers are monospaced, and numerical labels appear a lot in a chart,\n                    // we assume that a label of n characters has the same bounding box as others\n                    // of the same length.\n                    textStr.toString().replace(numRegex, '0') + \n\n                    // Properties that affect bounding box\n                    ['', rotation || 0, styles && styles.fontSize, element.style.width].join(',');\n\n            }\n\n            if (cacheKey && !reload) {\n                bBox = cache[cacheKey];\n            }\n\n            // No cache found\n            if (!bBox) {\n\n                // SVG elements\n                if (element.namespaceURI === SVG_NS || renderer.forExport) {\n                    try { // Fails in Firefox if the container has display: none.\n\n                        // When the text shadow shim is used, we need to hide the fake shadows\n                        // to get the correct bounding box (#3872)\n                        toggleTextShadowShim = this.fakeTS && function (display) {\n                            each(element.querySelectorAll('.' + PREFIX + 'text-shadow'), function (tspan) {\n                                tspan.style.display = display;\n                            });\n                        };\n\n                        // Workaround for #3842, Firefox reporting wrong bounding box for shadows\n                        if (isFirefox && elemStyle.textShadow) {\n                            textShadow = elemStyle.textShadow;\n                            elemStyle.textShadow = '';\n                        } else if (toggleTextShadowShim) {\n                            toggleTextShadowShim(NONE);\n                        }\n\n                        bBox = element.getBBox ?\n                            // SVG: use extend because IE9 is not allowed to change width and height in case\n                            // of rotation (below)\n                            extend({}, element.getBBox()) :\n                            // Canvas renderer and legacy IE in export mode\n                            {\n                                width: element.offsetWidth,\n                                height: element.offsetHeight\n                            };\n\n                        // #3842\n                        if (textShadow) {\n                            elemStyle.textShadow = textShadow;\n                        } else if (toggleTextShadowShim) {\n                            toggleTextShadowShim('');\n                        }\n                    } catch (e) {}\n\n                    // If the bBox is not set, the try-catch block above failed. The other condition\n                    // is for Opera that returns a width of -Infinity on hidden elements.\n                    if (!bBox || bBox.width < 0) {\n                        bBox = { width: 0, height: 0 };\n                    }\n\n\n                // VML Renderer or useHTML within SVG\n                } else {\n\n                    bBox = wrapper.htmlGetBBox();\n\n                }\n\n                // True SVG elements as well as HTML elements in modern browsers using the .useHTML option\n                // need to compensated for rotation\n                if (renderer.isSVG) {\n                    width = bBox.width;\n                    height = bBox.height;\n\n                    // Workaround for wrong bounding box in IE9 and IE10 (#1101, #1505, #1669, #2568)\n                    if (isMS && styles && styles.fontSize === '11px' && height.toPrecision(3) === '16.9') {\n                        bBox.height = height = 14;\n                    }\n\n                    // Adjust for rotated text\n                    if (rotation) {\n                        bBox.width = mathAbs(height * mathSin(rad)) + mathAbs(width * mathCos(rad));\n                        bBox.height = mathAbs(height * mathCos(rad)) + mathAbs(width * mathSin(rad));\n                    }\n                }\n\n                // Cache it. When loading a chart in a hidden iframe in Firefox and IE/Edge, the\n                // bounding box height is 0, so don't cache it (#5620).\n                if (cacheKey && bBox.height > 0) {\n\n                    // Rotate (#4681)\n                    while (cacheKeys.length > 250) {\n                        delete cache[cacheKeys.shift()];\n                    }\n\n                    if (!cache[cacheKey]) {\n                        cacheKeys.push(cacheKey);\n                    }\n                    cache[cacheKey] = bBox;\n                }\n            }\n            return bBox;\n        },\n\n        /**\n         * Show the element\n         */\n        show: function (inherit) {\n            return this.attr({ visibility: inherit ? 'inherit' : VISIBLE });\n        },\n\n        /**\n         * Hide the element\n         */\n        hide: function () {\n            return this.attr({ visibility: HIDDEN });\n        },\n\n        fadeOut: function (duration) {\n            var elemWrapper = this;\n            elemWrapper.animate({\n                opacity: 0\n            }, {\n                duration: duration || 150,\n                complete: function () {\n                    elemWrapper.attr({ y: -9999 }); // #3088, assuming we're only using this for tooltips\n                }\n            });\n        },\n\n        /**\n         * Add the element\n         * @param {Object|Undefined} parent Can be an element, an element wrapper or undefined\n         *    to append the element to the renderer.box.\n         */\n        add: function (parent) {\n\n            var renderer = this.renderer,\n                element = this.element,\n                inserted;\n\n            if (parent) {\n                this.parentGroup = parent;\n            }\n\n            // mark as inverted\n            this.parentInverted = parent && parent.inverted;\n\n            // build formatted text\n            if (this.textStr !== undefined) {\n                renderer.buildText(this);\n            }\n\n            // Mark as added\n            this.added = true;\n\n            // If we're adding to renderer root, or other elements in the group\n            // have a z index, we need to handle it\n            if (!parent || parent.handleZ || this.zIndex) {\n                inserted = this.zIndexSetter();\n            }\n\n            // If zIndex is not handled, append at the end\n            if (!inserted) {\n                (parent ? parent.element : renderer.box).appendChild(element);\n            }\n\n            // fire an event for internal hooks\n            if (this.onAdd) {\n                this.onAdd();\n            }\n\n            return this;\n        },\n\n        /**\n         * Removes a child either by removeChild or move to garbageBin.\n         * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.\n         */\n        safeRemoveChild: function (element) {\n            var parentNode = element.parentNode;\n            if (parentNode) {\n                parentNode.removeChild(element);\n            }\n        },\n\n        /**\n         * Destroy the element and element wrapper\n         */\n        destroy: function () {\n            var wrapper = this,\n                element = wrapper.element || {},\n                shadows = wrapper.shadows,\n                parentToClean = wrapper.renderer.isSVG && element.nodeName === 'SPAN' && wrapper.parentGroup,\n                grandParent,\n                key,\n                i;\n\n            // remove events\n            element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;\n            stop(wrapper); // stop running animations\n\n            if (wrapper.clipPath) {\n                wrapper.clipPath = wrapper.clipPath.destroy();\n            }\n\n            // Destroy stops in case this is a gradient object\n            if (wrapper.stops) {\n                for (i = 0; i < wrapper.stops.length; i++) {\n                    wrapper.stops[i] = wrapper.stops[i].destroy();\n                }\n                wrapper.stops = null;\n            }\n\n            // remove element\n            wrapper.safeRemoveChild(element);\n\n            // destroy shadows\n            if (shadows) {\n                each(shadows, function (shadow) {\n                    wrapper.safeRemoveChild(shadow);\n                });\n            }\n\n            // In case of useHTML, clean up empty containers emulating SVG groups (#1960, #2393, #2697).\n            while (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {\n                grandParent = parentToClean.parentGroup;\n                wrapper.safeRemoveChild(parentToClean.div);\n                delete parentToClean.div;\n                parentToClean = grandParent;\n            }\n\n            // remove from alignObjects\n            if (wrapper.alignTo) {\n                erase(wrapper.renderer.alignedObjects, wrapper);\n            }\n\n            for (key in wrapper) {\n                delete wrapper[key];\n            }\n\n            return null;\n        },\n\n        /**\n         * Add a shadow to the element. Must be done after the element is added to the DOM\n         * @param {Boolean|Object} shadowOptions\n         */\n        shadow: function (shadowOptions, group, cutOff) {\n            var shadows = [],\n                i,\n                shadow,\n                element = this.element,\n                strokeWidth,\n                shadowWidth,\n                shadowElementOpacity,\n\n                // compensate for inverted plot area\n                transform;\n\n\n            if (shadowOptions) {\n                shadowWidth = pick(shadowOptions.width, 3);\n                shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;\n                transform = this.parentInverted ?\n                        '(-1,-1)' :\n                        '(' + pick(shadowOptions.offsetX, 1) + ', ' + pick(shadowOptions.offsetY, 1) + ')';\n                for (i = 1; i <= shadowWidth; i++) {\n                    shadow = element.cloneNode(0);\n                    strokeWidth = (shadowWidth * 2) + 1 - (2 * i);\n                    attr(shadow, {\n                        'isShadow': 'true',\n                        'stroke': shadowOptions.color || 'black',\n                        'stroke-opacity': shadowElementOpacity * i,\n                        'stroke-width': strokeWidth,\n                        'transform': 'translate' + transform,\n                        'fill': NONE\n                    });\n                    if (cutOff) {\n                        attr(shadow, 'height', mathMax(attr(shadow, 'height') - strokeWidth, 0));\n                        shadow.cutHeight = strokeWidth;\n                    }\n\n                    if (group) {\n                        group.element.appendChild(shadow);\n                    } else {\n                        element.parentNode.insertBefore(shadow, element);\n                    }\n\n                    shadows.push(shadow);\n                }\n\n                this.shadows = shadows;\n            }\n            return this;\n\n        },\n\n        xGetter: function (key) {\n            if (this.element.nodeName === 'circle') {\n                key = { x: 'cx', y: 'cy' }[key] || key;\n            }\n            return this._defaultGetter(key);\n        },\n\n        /**\n         * Get the current value of an attribute or pseudo attribute, used mainly\n         * for animation.\n         */\n        _defaultGetter: function (key) {\n            var ret = pick(this[key], this.element ? this.element.getAttribute(key) : null, 0);\n\n            if (/^[\\-0-9\\.]+$/.test(ret)) { // is numerical\n                ret = parseFloat(ret);\n            }\n            return ret;\n        },\n\n\n        dSetter: function (value, key, element) {\n            if (value && value.join) { // join path\n                value = value.join(' ');\n            }\n            if (/(NaN| {2}|^$)/.test(value)) {\n                value = 'M 0 0';\n            }\n            element.setAttribute(key, value);\n\n            this[key] = value;\n        },\n        dashstyleSetter: function (value) {\n            var i,\n                strokeWidth = this['stroke-width'];\n        \n            // If \"inherit\", like maps in IE, assume 1 (#4981). With HC5 and the new strokeWidth \n            // function, we should be able to use that instead.\n            if (strokeWidth === 'inherit') {\n                strokeWidth = 1;\n            }\n            value = value && value.toLowerCase();\n            if (value) {\n                value = value\n                    .replace('shortdashdotdot', '3,1,1,1,1,1,')\n                    .replace('shortdashdot', '3,1,1,1')\n                    .replace('shortdot', '1,1,')\n                    .replace('shortdash', '3,1,')\n                    .replace('longdash', '8,3,')\n                    .replace(/dot/g, '1,3,')\n                    .replace('dash', '4,3,')\n                    .replace(/,$/, '')\n                    .split(','); // ending comma\n\n                i = value.length;\n                while (i--) {\n                    value[i] = pInt(value[i]) * strokeWidth;\n                }\n                value = value.join(',')\n                    .replace(/NaN/g, 'none'); // #3226\n                this.element.setAttribute('stroke-dasharray', value);\n            }\n        },\n        alignSetter: function (value) {\n            this.element.setAttribute('text-anchor', { left: 'start', center: 'middle', right: 'end' }[value]);\n        },\n        titleSetter: function (value) {\n            var titleNode = this.element.getElementsByTagName('title')[0];\n            if (!titleNode) {\n                titleNode = doc.createElementNS(SVG_NS, 'title');\n                this.element.appendChild(titleNode);\n            }\n\n            // Remove text content if it exists\n            if (titleNode.firstChild) {\n                titleNode.removeChild(titleNode.firstChild);\n            }\n\n            titleNode.appendChild(\n                doc.createTextNode(\n                    (String(pick(value), '')).replace(/<[^>]*>/g, '') // #3276, #3895\n                )\n            );\n        },\n        textSetter: function (value) {\n            if (value !== this.textStr) {\n                // Delete bBox memo when the text changes\n                delete this.bBox;\n\n                this.textStr = value;\n                if (this.added) {\n                    this.renderer.buildText(this);\n                }\n            }\n        },\n        fillSetter: function (value, key, element) {\n            if (typeof value === 'string') {\n                element.setAttribute(key, value);\n            } else if (value) {\n                this.colorGradient(value, key, element);\n            }\n        },\n        visibilitySetter: function (value, key, element) {\n            // IE9-11 doesn't handle visibilty:inherit well, so we remove the attribute instead (#2881, #3909)\n            if (value === 'inherit') {\n                element.removeAttribute(key);\n            } else {\n                element.setAttribute(key, value);\n            }\n        },\n        zIndexSetter: function (value, key) {\n            var renderer = this.renderer,\n                parentGroup = this.parentGroup,\n                parentWrapper = parentGroup || renderer,\n                parentNode = parentWrapper.element || renderer.box,\n                childNodes,\n                otherElement,\n                otherZIndex,\n                element = this.element,\n                inserted,\n                run = this.added,\n                i;\n\n            if (defined(value)) {\n                element.zIndex = value; // So we can read it for other elements in the group\n                value = +value;\n                if (this[key] === value) { // Only update when needed (#3865)\n                    run = false;\n                }\n                this[key] = value;\n            }\n\n            // Insert according to this and other elements' zIndex. Before .add() is called,\n            // nothing is done. Then on add, or by later calls to zIndexSetter, the node\n            // is placed on the right place in the DOM.\n            if (run) {\n                value = this.zIndex;\n\n                if (value && parentGroup) {\n                    parentGroup.handleZ = true;\n                }\n\n                childNodes = parentNode.childNodes;\n                for (i = 0; i < childNodes.length && !inserted; i++) {\n                    otherElement = childNodes[i];\n                    otherZIndex = otherElement.zIndex;\n                    if (otherElement !== element && (\n                            // Insert before the first element with a higher zIndex\n                            pInt(otherZIndex) > value ||\n                            // If no zIndex given, insert before the first element with a zIndex\n                            (!defined(value) && defined(otherZIndex))\n\n                        )) {\n                        parentNode.insertBefore(element, otherElement);\n                        inserted = true;\n                    }\n                }\n                if (!inserted) {\n                    parentNode.appendChild(element);\n                }\n            }\n            return inserted;\n        },\n        _defaultSetter: function (value, key, element) {\n            element.setAttribute(key, value);\n        }\n    };\n\n    // Some shared setters and getters\n    SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;\n    SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter =\n            SVGElement.prototype.rotationSetter = SVGElement.prototype.verticalAlignSetter =\n            SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = function (value, key) {\n                this[key] = value;\n                this.doTransform = true;\n            };\n\n    // These setters both set the key on the instance itself plus as an attribute\n    SVGElement.prototype.opacitySetter = SVGElement.prototype.displaySetter = function (value, key, element) {\n        this[key] = value;\n        element.setAttribute(key, value);\n    };\n    \n\n    // WebKit and Batik have problems with a stroke-width of zero, so in this case we remove the\n    // stroke attribute altogether. #1270, #1369, #3065, #3072.\n    SVGElement.prototype['stroke-widthSetter'] = SVGElement.prototype.strokeSetter = function (value, key, element) {\n        this[key] = value;\n        // Only apply the stroke attribute if the stroke width is defined and larger than 0\n        if (this.stroke && this['stroke-width']) {\n            this.strokeWidth = this['stroke-width'];\n            SVGElement.prototype.fillSetter.call(this, this.stroke, 'stroke', element); // use prototype as instance may be overridden\n            element.setAttribute('stroke-width', this['stroke-width']);\n            this.hasStroke = true;\n        } else if (key === 'stroke-width' && value === 0 && this.hasStroke) {\n            element.removeAttribute('stroke');\n            this.hasStroke = false;\n        }\n    };\n\n\n    /**\n     * The default SVG renderer\n     */\n    var SVGRenderer = function () {\n        this.init.apply(this, arguments);\n    };\n    SVGRenderer.prototype = {\n        Element: SVGElement,\n        /**\n         * Initialize the SVGRenderer\n         * @param {Object} container\n         * @param {Number} width\n         * @param {Number} height\n         * @param {Boolean} forExport\n         */\n        init: function (container, width, height, style, forExport, allowHTML) {\n            var renderer = this,\n                boxWrapper,\n                element,\n                desc;\n\n            boxWrapper = renderer.createElement('svg')\n                .attr({\n                    version: '1.1'\n                })\n                .css(this.getStyle(style));\n            element = boxWrapper.element;\n            container.appendChild(element);\n\n            // For browsers other than IE, add the namespace attribute (#1978)\n            if (container.innerHTML.indexOf('xmlns') === -1) {\n                attr(element, 'xmlns', SVG_NS);\n            }\n\n            // object properties\n            renderer.isSVG = true;\n            renderer.box = element;\n            renderer.boxWrapper = boxWrapper;\n            renderer.alignedObjects = [];\n\n            // Page url used for internal references. #24, #672, #1070\n            renderer.url = (isFirefox || isWebKit) && doc.getElementsByTagName('base').length ?\n                    win.location.href\n                        .replace(/#.*?$/, '') // remove the hash\n                        .replace(/([\\('\\)])/g, '\\\\$1') // escape parantheses and quotes\n                        .replace(/ /g, '%20') : // replace spaces (needed for Safari only)\n                    '';\n\n            // Add description\n            desc = this.createElement('desc').add();\n            desc.element.appendChild(doc.createTextNode('Created with ' + PRODUCT + ' ' + VERSION));\n\n\n            renderer.defs = this.createElement('defs').add();\n            renderer.allowHTML = allowHTML;\n            renderer.forExport = forExport;\n            renderer.gradients = {}; // Object where gradient SvgElements are stored\n            renderer.cache = {}; // Cache for numerical bounding boxes\n            renderer.cacheKeys = [];\n            renderer.imgCount = 0;\n\n            renderer.setSize(width, height, false);\n\n\n\n            // Issue 110 workaround:\n            // In Firefox, if a div is positioned by percentage, its pixel position may land\n            // between pixels. The container itself doesn't display this, but an SVG element\n            // inside this container will be drawn at subpixel precision. In order to draw\n            // sharp lines, this must be compensated for. This doesn't seem to work inside\n            // iframes though (like in jsFiddle).\n            var subPixelFix, rect;\n            if (isFirefox && container.getBoundingClientRect) {\n                renderer.subPixelFix = subPixelFix = function () {\n                    css(container, { left: 0, top: 0 });\n                    rect = container.getBoundingClientRect();\n                    css(container, {\n                        left: (mathCeil(rect.left) - rect.left) + PX,\n                        top: (mathCeil(rect.top) - rect.top) + PX\n                    });\n                };\n\n                // run the fix now\n                subPixelFix();\n\n                // run it on resize\n                addEvent(win, 'resize', subPixelFix);\n            }\n        },\n\n        getStyle: function (style) {\n            this.style = extend({\n                fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif', // default font\n                fontSize: '12px'\n            }, style);\n            return this.style;\n        },\n\n        /**\n         * Detect whether the renderer is hidden. This happens when one of the parent elements\n         * has display: none. #608.\n         */\n        isHidden: function () {\n            return !this.boxWrapper.getBBox().width;\n        },\n\n        /**\n         * Destroys the renderer and its allocated members.\n         */\n        destroy: function () {\n            var renderer = this,\n                rendererDefs = renderer.defs;\n            renderer.box = null;\n            renderer.boxWrapper = renderer.boxWrapper.destroy();\n\n            // Call destroy on all gradient elements\n            destroyObjectProperties(renderer.gradients || {});\n            renderer.gradients = null;\n\n            // Defs are null in VMLRenderer\n            // Otherwise, destroy them here.\n            if (rendererDefs) {\n                renderer.defs = rendererDefs.destroy();\n            }\n\n            // Remove sub pixel fix handler\n            // We need to check that there is a handler, otherwise all functions that are registered for event 'resize' are removed\n            // See issue #982\n            if (renderer.subPixelFix) {\n                removeEvent(win, 'resize', renderer.subPixelFix);\n            }\n\n            renderer.alignedObjects = null;\n\n            return null;\n        },\n\n        /**\n         * Create a wrapper for an SVG element\n         * @param {Object} nodeName\n         */\n        createElement: function (nodeName) {\n            var wrapper = new this.Element();\n            wrapper.init(this, nodeName);\n            return wrapper;\n        },\n\n        /**\n         * Dummy function for use in canvas renderer\n         */\n        draw: function () {},\n\n        /**\n         * Get converted radial gradient attributes\n         */\n        getRadialAttr: function (radialReference, gradAttr) {\n            return {\n                cx: (radialReference[0] - radialReference[2] / 2) + gradAttr.cx * radialReference[2],\n                cy: (radialReference[1] - radialReference[2] / 2) + gradAttr.cy * radialReference[2],\n                r: gradAttr.r * radialReference[2]\n            };\n        },\n\n        /**\n         * Parse a simple HTML string into SVG tspans\n         *\n         * @param {Object} textNode The parent text SVG node\n         */\n        buildText: function (wrapper) {\n            var textNode = wrapper.element,\n                renderer = this,\n                forExport = renderer.forExport,\n                textStr = pick(wrapper.textStr, '').toString(),\n                hasMarkup = textStr.indexOf('<') !== -1,\n                lines,\n                childNodes = textNode.childNodes,\n                styleRegex,\n                hrefRegex,\n                wasTooLong,\n                parentX = attr(textNode, 'x'),\n                textStyles = wrapper.styles,\n                width = wrapper.textWidth,\n                textLineHeight = textStyles && textStyles.lineHeight,\n                textShadow = textStyles && textStyles.textShadow,\n                ellipsis = textStyles && textStyles.textOverflow === 'ellipsis',\n                i = childNodes.length,\n                tempParent = width && !wrapper.added && this.box,\n                getLineHeight = function (tspan) {\n                    return textLineHeight ?\n                            pInt(textLineHeight) :\n                            renderer.fontMetrics(\n                                /(px|em)$/.test(tspan && tspan.style.fontSize) ?\n                                        tspan.style.fontSize :\n                                        ((textStyles && textStyles.fontSize) || renderer.style.fontSize || 12),\n                                tspan\n                            ).h;\n                },\n                unescapeAngleBrackets = function (inputStr) {\n                    return inputStr.replace(/&lt;/g, '<').replace(/&gt;/g, '>');\n                };\n\n            /// remove old text\n            while (i--) {\n                textNode.removeChild(childNodes[i]);\n            }\n\n            // Skip tspans, add text directly to text node. The forceTSpan is a hook\n            // used in text outline hack.\n            if (!hasMarkup && !textShadow && !ellipsis && !width && textStr.indexOf(' ') === -1) {\n                textNode.appendChild(doc.createTextNode(unescapeAngleBrackets(textStr)));\n\n            // Complex strings, add more logic\n            } else {\n\n                styleRegex = /<.*style=\"([^\"]+)\".*>/;\n                hrefRegex = /<.*href=\"(http[^\"]+)\".*>/;\n\n                if (tempParent) {\n                    tempParent.appendChild(textNode); // attach it to the DOM to read offset width\n                }\n\n                if (hasMarkup) {\n                    lines = textStr\n                        .replace(/<(b|strong)>/g, '<span style=\"font-weight:bold\">')\n                        .replace(/<(i|em)>/g, '<span style=\"font-style:italic\">')\n                        .replace(/<a/g, '<span')\n                        .replace(/<\\/(b|strong|i|em|a)>/g, '</span>')\n                        .split(/<br.*?>/g);\n\n                } else {\n                    lines = [textStr];\n                }\n\n\n                // Trim empty lines (#5261)\n                lines = grep(lines, function (line) {\n                    return line !== '';\n                });\n\n\n                // build the lines\n                each(lines, function buildTextLines(line, lineNo) {\n                    var spans,\n                        spanNo = 0;\n                    line = line\n                        .replace(/^\\s+|\\s+$/g, '') // Trim to prevent useless/costly process on the spaces (#5258)\n                        .replace(/<span/g, '|||<span')\n                        .replace(/<\\/span>/g, '</span>|||');\n                    spans = line.split('|||');\n\n                    each(spans, function buildTextSpans(span) {\n                        if (span !== '' || spans.length === 1) {\n                            var attributes = {},\n                                tspan = doc.createElementNS(SVG_NS, 'tspan'),\n                                spanStyle; // #390\n                            if (styleRegex.test(span)) {\n                                spanStyle = span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2');\n                                attr(tspan, 'style', spanStyle);\n                            }\n                            if (hrefRegex.test(span) && !forExport) { // Not for export - #1529\n                                attr(tspan, 'onclick', 'location.href=\\\"' + span.match(hrefRegex)[1] + '\\\"');\n                                css(tspan, { cursor: 'pointer' });\n                            }\n\n                            span = unescapeAngleBrackets(span.replace(/<(.|\\n)*?>/g, '') || ' ');\n\n                            // Nested tags aren't supported, and cause crash in Safari (#1596)\n                            if (span !== ' ') {\n\n                                // add the text node\n                                tspan.appendChild(doc.createTextNode(span));\n\n                                if (!spanNo) { // first span in a line, align it to the left\n                                    if (lineNo && parentX !== null) {\n                                        attributes.x = parentX;\n                                    }\n                                } else {\n                                    attributes.dx = 0; // #16\n                                }\n\n                                // add attributes\n                                attr(tspan, attributes);\n\n                                // Append it\n                                textNode.appendChild(tspan);\n\n                                // first span on subsequent line, add the line height\n                                if (!spanNo && lineNo) {\n\n                                    // allow getting the right offset height in exporting in IE\n                                    if (!hasSVG && forExport) {\n                                        css(tspan, { display: 'block' });\n                                    }\n\n                                    // Set the line height based on the font size of either\n                                    // the text element or the tspan element\n                                    attr(\n                                        tspan,\n                                        'dy',\n                                        getLineHeight(tspan)\n                                    );\n                                }\n\n                                /*if (width) {\n                                    renderer.breakText(wrapper, width);\n                                }*/\n\n                                // Check width and apply soft breaks or ellipsis\n                                if (width) {\n                                    var words = span.replace(/([^\\^])-/g, '$1- ').split(' '), // #1273\n                                        noWrap = textStyles.whiteSpace === 'nowrap',\n                                        hasWhiteSpace = spans.length > 1 || lineNo || (words.length > 1 && !noWrap),\n                                        tooLong,\n                                        actualWidth,\n                                        rest = [],\n                                        dy = getLineHeight(tspan),\n                                        softLineNo = 1,\n                                        rotation = wrapper.rotation,\n                                        wordStr = span, // for ellipsis\n                                        cursor = wordStr.length, // binary search cursor\n                                        bBox;\n\n                                    while ((hasWhiteSpace || ellipsis) && (words.length || rest.length)) {\n                                        wrapper.rotation = 0; // discard rotation when computing box\n                                        bBox = wrapper.getBBox(true);\n                                        actualWidth = bBox.width;\n\n                                        // Old IE cannot measure the actualWidth for SVG elements (#2314)\n                                        if (!hasSVG && renderer.forExport) {\n                                            actualWidth = renderer.measureSpanWidth(tspan.firstChild.data, wrapper.styles);\n                                        }\n\n                                        tooLong = actualWidth > width;\n\n                                        // For ellipsis, do a binary search for the correct string length\n                                        if (wasTooLong === undefined) {\n                                            wasTooLong = tooLong; // First time\n                                        }\n                                        if (ellipsis && wasTooLong) {\n                                            cursor /= 2;\n\n                                            if (wordStr === '' || (!tooLong && cursor < 0.5)) {\n                                                words = []; // All ok, break out\n                                            } else {\n                                                wordStr = span.substring(0, wordStr.length + (tooLong ? -1 : 1) * mathCeil(cursor));\n                                                words = [wordStr + (width > 3 ? '\\u2026' : '')];\n                                                tspan.removeChild(tspan.firstChild);\n                                            }\n\n                                        // Looping down, this is the first word sequence that is not too long,\n                                        // so we can move on to build the next line.\n                                        } else if (!tooLong || words.length === 1) {\n                                            words = rest;\n                                            rest = [];\n\n                                            if (words.length && !noWrap) {\n                                                softLineNo++;\n\n                                                tspan = doc.createElementNS(SVG_NS, 'tspan');\n                                                attr(tspan, {\n                                                    dy: dy,\n                                                    x: parentX\n                                                });\n                                                if (spanStyle) { // #390\n                                                    attr(tspan, 'style', spanStyle);\n                                                }\n                                                textNode.appendChild(tspan);\n                                            }\n                                            if (actualWidth > width) { // a single word is pressing it out\n                                                width = actualWidth;\n                                            }\n                                        } else { // append to existing line tspan\n                                            tspan.removeChild(tspan.firstChild);\n                                            rest.unshift(words.pop());\n                                        }\n                                        if (words.length) {\n                                            tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));\n                                        }\n                                    }\n                                    wrapper.rotation = rotation;\n                                }\n\n                                spanNo++;\n                            }\n                        }\n                    });\n                });\n\n                if (wasTooLong) {\n                    wrapper.attr('title', wrapper.textStr);\n                }\n                if (tempParent) {\n                    tempParent.removeChild(textNode); // attach it to the DOM to read offset width\n                }\n\n                // Apply the text shadow\n                if (textShadow && wrapper.applyTextShadow) {\n                    wrapper.applyTextShadow(textShadow);\n                }\n            }\n        },\n\n\n\n        /*\n        breakText: function (wrapper, width) {\n            var bBox = wrapper.getBBox(),\n                node = wrapper.element,\n                textLength = node.textContent.length,\n                pos = mathRound(width * textLength / bBox.width), // try this position first, based on average character width\n                increment = 0,\n                finalPos;\n\n            if (bBox.width > width) {\n                while (finalPos === undefined) {\n                    textLength = node.getSubStringLength(0, pos);\n\n                    if (textLength <= width) {\n                        if (increment === -1) {\n                            finalPos = pos;\n                        } else {\n                            increment = 1;\n                        }\n                    } else {\n                        if (increment === 1) {\n                            finalPos = pos - 1;\n                        } else {\n                            increment = -1;\n                        }\n                    }\n                    pos += increment;\n                }\n            }\n            console.log('width', width, 'stringWidth', node.getSubStringLength(0, finalPos))\n        },\n        */\n\n        /**\n         * Returns white for dark colors and black for bright colors\n         */\n        getContrast: function (color) {\n            color = Color(color).rgba;\n            return color[0] + color[1] + color[2] > 384 ? '#000000' : '#FFFFFF';\n        },\n\n        /**\n         * Create a button with preset states\n         * @param {String} text\n         * @param {Number} x\n         * @param {Number} y\n         * @param {Function} callback\n         * @param {Object} normalState\n         * @param {Object} hoverState\n         * @param {Object} pressedState\n         */\n        button: function (text, x, y, callback, normalState, hoverState, pressedState, disabledState, shape) {\n            var label = this.label(text, x, y, shape, null, null, null, null, 'button'),\n                curState = 0,\n                stateOptions,\n                stateStyle,\n                normalStyle,\n                hoverStyle,\n                pressedStyle,\n                disabledStyle,\n                verticalGradient = { x1: 0, y1: 0, x2: 0, y2: 1 };\n\n            // Normal state - prepare the attributes\n            normalState = merge({\n                'stroke-width': 1,\n                stroke: '#CCCCCC',\n                fill: {\n                    linearGradient: verticalGradient,\n                    stops: [\n                        [0, '#FEFEFE'],\n                        [1, '#F6F6F6']\n                    ]\n                },\n                r: 2,\n                padding: 5,\n                style: {\n                    color: 'black'\n                }\n            }, normalState);\n            normalStyle = normalState.style;\n            delete normalState.style;\n\n            // Hover state\n            hoverState = merge(normalState, {\n                stroke: '#68A',\n                fill: {\n                    linearGradient: verticalGradient,\n                    stops: [\n                        [0, '#FFF'],\n                        [1, '#ACF']\n                    ]\n                }\n            }, hoverState);\n            hoverStyle = hoverState.style;\n            delete hoverState.style;\n\n            // Pressed state\n            pressedState = merge(normalState, {\n                stroke: '#68A',\n                fill: {\n                    linearGradient: verticalGradient,\n                    stops: [\n                        [0, '#9BD'],\n                        [1, '#CDF']\n                    ]\n                }\n            }, pressedState);\n            pressedStyle = pressedState.style;\n            delete pressedState.style;\n\n            // Disabled state\n            disabledState = merge(normalState, {\n                style: {\n                    color: '#CCC'\n                }\n            }, disabledState);\n            disabledStyle = disabledState.style;\n            delete disabledState.style;\n\n            // Add the events. IE9 and IE10 need mouseover and mouseout to funciton (#667).\n            addEvent(label.element, isMS ? 'mouseover' : 'mouseenter', function () {\n                if (curState !== 3) {\n                    label.attr(hoverState)\n                        .css(hoverStyle);\n                }\n            });\n            addEvent(label.element, isMS ? 'mouseout' : 'mouseleave', function () {\n                if (curState !== 3) {\n                    stateOptions = [normalState, hoverState, pressedState][curState];\n                    stateStyle = [normalStyle, hoverStyle, pressedStyle][curState];\n                    label.attr(stateOptions)\n                        .css(stateStyle);\n                }\n            });\n\n            label.setState = function (state) {\n                label.state = curState = state;\n                if (!state) {\n                    label.attr(normalState)\n                        .css(normalStyle);\n                } else if (state === 2) {\n                    label.attr(pressedState)\n                        .css(pressedStyle);\n                } else if (state === 3) {\n                    label.attr(disabledState)\n                        .css(disabledStyle);\n                }\n            };\n\n            return label\n                .on('click', function (e) {\n                    if (curState !== 3) {\n                        callback.call(label, e);\n                    }\n                })\n                .attr(normalState)\n                .css(extend({ cursor: 'default' }, normalStyle));\n        },\n\n        /**\n         * Make a straight line crisper by not spilling out to neighbour pixels\n         * @param {Array} points\n         * @param {Number} width\n         */\n        crispLine: function (points, width) {\n            // points format: [M, 0, 0, L, 100, 0]\n            // normalize to a crisp line\n            if (points[1] === points[4]) {\n                // Substract due to #1129. Now bottom and left axis gridlines behave the same.\n                points[1] = points[4] = mathRound(points[1]) - (width % 2 / 2);\n            }\n            if (points[2] === points[5]) {\n                points[2] = points[5] = mathRound(points[2]) + (width % 2 / 2);\n            }\n            return points;\n        },\n\n\n        /**\n         * Draw a path\n         * @param {Array} path An SVG path in array form\n         */\n        path: function (path) {\n            var attr = {\n                fill: NONE\n            };\n            if (isArray(path)) {\n                attr.d = path;\n            } else if (isObject(path)) { // attributes\n                extend(attr, path);\n            }\n            return this.createElement('path').attr(attr);\n        },\n\n        /**\n         * Draw and return an SVG circle\n         * @param {Number} x The x position\n         * @param {Number} y The y position\n         * @param {Number} r The radius\n         */\n        circle: function (x, y, r) {\n            var attr = isObject(x) ? x : { x: x, y: y, r: r },\n                wrapper = this.createElement('circle');\n\n            // Setting x or y translates to cx and cy\n            wrapper.xSetter = wrapper.ySetter = function (value, key, element) {\n                element.setAttribute('c' + key, value);\n            };\n\n            return wrapper.attr(attr);\n        },\n\n        /**\n         * Draw and return an arc\n         * @param {Number} x X position\n         * @param {Number} y Y position\n         * @param {Number} r Radius\n         * @param {Number} innerR Inner radius like used in donut charts\n         * @param {Number} start Starting angle\n         * @param {Number} end Ending angle\n         */\n        arc: function (x, y, r, innerR, start, end) {\n            var arc;\n\n            if (isObject(x)) {\n                y = x.y;\n                r = x.r;\n                innerR = x.innerR;\n                start = x.start;\n                end = x.end;\n                x = x.x;\n            }\n\n            // Arcs are defined as symbols for the ability to set\n            // attributes in attr and animate\n            arc = this.symbol('arc', x || 0, y || 0, r || 0, r || 0, {\n                innerR: innerR || 0,\n                start: start || 0,\n                end: end || 0\n            });\n            arc.r = r; // #959\n            return arc;\n        },\n\n        /**\n         * Draw and return a rectangle\n         * @param {Number} x Left position\n         * @param {Number} y Top position\n         * @param {Number} width\n         * @param {Number} height\n         * @param {Number} r Border corner radius\n         * @param {Number} strokeWidth A stroke width can be supplied to allow crisp drawing\n         */\n        rect: function (x, y, width, height, r, strokeWidth) {\n\n            r = isObject(x) ? x.r : r;\n\n            var wrapper = this.createElement('rect'),\n                attribs = isObject(x) ? x : x === UNDEFINED ? {} : {\n                    x: x,\n                    y: y,\n                    width: mathMax(width, 0),\n                    height: mathMax(height, 0)\n                };\n\n            if (strokeWidth !== UNDEFINED) {\n                wrapper.strokeWidth = strokeWidth;\n                attribs = wrapper.crisp(attribs);\n            }\n\n            if (r) {\n                attribs.r = r;\n            }\n\n            wrapper.rSetter = function (value, key, element) {\n                attr(element, {\n                    rx: value,\n                    ry: value\n                });\n            };\n\n            return wrapper.attr(attribs);\n        },\n\n        /**\n         * Resize the box and re-align all aligned elements\n         * @param {Object} width\n         * @param {Object} height\n         * @param {Boolean} animate\n         *\n         */\n        setSize: function (width, height, animate) {\n            var renderer = this,\n                alignedObjects = renderer.alignedObjects,\n                i = alignedObjects.length;\n\n            renderer.width = width;\n            renderer.height = height;\n\n            renderer.boxWrapper[pick(animate, true) ? 'animate' : 'attr']({\n                width: width,\n                height: height\n            });\n\n            while (i--) {\n                alignedObjects[i].align();\n            }\n        },\n\n        /**\n         * Create a group\n         * @param {String} name The group will be given a class name of 'highcharts-{name}'.\n         *     This can be used for styling and scripting.\n         */\n        g: function (name) {\n            var elem = this.createElement('g');\n            return defined(name) ? elem.attr({ 'class': PREFIX + name }) : elem;\n        },\n\n        /**\n         * Display an image\n         * @param {String} src\n         * @param {Number} x\n         * @param {Number} y\n         * @param {Number} width\n         * @param {Number} height\n         */\n        image: function (src, x, y, width, height) {\n            var attribs = {\n                    preserveAspectRatio: NONE\n                },\n                elemWrapper;\n\n            // optional properties\n            if (arguments.length > 1) {\n                extend(attribs, {\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n            }\n\n            elemWrapper = this.createElement('image').attr(attribs);\n\n            // set the href in the xlink namespace\n            if (elemWrapper.element.setAttributeNS) {\n                elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',\n                    'href', src);\n            } else {\n                // could be exporting in IE\n                // using href throws \"not supported\" in ie7 and under, requries regex shim to fix later\n                elemWrapper.element.setAttribute('hc-svg-href', src);\n            }\n            return elemWrapper;\n        },\n\n        /**\n         * Draw a symbol out of pre-defined shape paths from the namespace 'symbol' object.\n         *\n         * @param {Object} symbol\n         * @param {Object} x\n         * @param {Object} y\n         * @param {Object} radius\n         * @param {Object} options\n         */\n        symbol: function (symbol, x, y, width, height, options) {\n\n            var ren = this,\n                obj,\n\n                // get the symbol definition function\n                symbolFn = this.symbols[symbol],\n\n                // check if there's a path defined for this symbol\n                path = symbolFn && symbolFn(\n                    mathRound(x),\n                    mathRound(y),\n                    width,\n                    height,\n                    options\n                ),\n                imageRegex = /^url\\((.*?)\\)$/,\n                imageSrc,\n                imageSize,\n                centerImage;\n\n            if (path) {\n\n                obj = this.path(path);\n                // expando properties for use in animate and attr\n                extend(obj, {\n                    symbolName: symbol,\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n                if (options) {\n                    extend(obj, options);\n                }\n\n\n            // image symbols\n            } else if (imageRegex.test(symbol)) {\n\n                // On image load, set the size and position\n                centerImage = function (img, size) {\n                    if (img.element) { // it may be destroyed in the meantime (#1390)\n                        img.attr({\n                            width: size[0],\n                            height: size[1]\n                        });\n\n                        if (!img.alignByTranslate) { // #185\n                            img.translate(\n                                mathRound((width - size[0]) / 2), // #1378\n                                mathRound((height - size[1]) / 2)\n                            );\n                        }\n                    }\n                };\n\n                imageSrc = symbol.match(imageRegex)[1];\n                imageSize = symbolSizes[imageSrc] || (options && options.width && options.height && [options.width, options.height]);\n\n                // Ireate the image synchronously, add attribs async\n                obj = this.image(imageSrc)\n                    .attr({\n                        x: x,\n                        y: y\n                    });\n                obj.isImg = true;\n\n                if (imageSize) {\n                    centerImage(obj, imageSize);\n                } else {\n                    // Initialize image to be 0 size so export will still function if there's no cached sizes.\n                    obj.attr({ width: 0, height: 0 });\n\n                    // Create a dummy JavaScript image to get the width and height. Due to a bug in IE < 8,\n                    // the created element must be assigned to a variable in order to load (#292).\n                    createElement('img', {\n                        onload: function () {\n\n                            var chart = charts[ren.chartIndex];\n\n                            // Special case for SVGs on IE11, the width is not accessible until the image is\n                            // part of the DOM (#2854).\n                            if (this.width === 0) {\n                                css(this, {\n                                    position: ABSOLUTE,\n                                    top: '-999em'\n                                });\n                                doc.body.appendChild(this);\n                            }\n\n                            // Center the image\n                            centerImage(obj, symbolSizes[imageSrc] = [this.width, this.height]);\n\n                            // Clean up after #2854 workaround.\n                            if (this.parentNode) {\n                                this.parentNode.removeChild(this);\n                            }\n\n                            // Fire the load event when all external images are loaded\n                            ren.imgCount--;\n                            if (!ren.imgCount && chart && chart.onload) {\n                                chart.onload();\n                            }\n                        },\n                        src: imageSrc\n                    });\n                    this.imgCount++;\n                }\n            }\n\n            return obj;\n        },\n\n        /**\n         * An extendable collection of functions for defining symbol paths.\n         */\n        symbols: {\n            'circle': function (x, y, w, h) {\n                var cpw = 0.166 * w;\n                return [\n                    M, x + w / 2, y,\n                    'C', x + w + cpw, y, x + w + cpw, y + h, x + w / 2, y + h,\n                    'C', x - cpw, y + h, x - cpw, y, x + w / 2, y,\n                    'Z'\n                ];\n            },\n\n            'square': function (x, y, w, h) {\n                return [\n                    M, x, y,\n                    L, x + w, y,\n                    x + w, y + h,\n                    x, y + h,\n                    'Z'\n                ];\n            },\n\n            'triangle': function (x, y, w, h) {\n                return [\n                    M, x + w / 2, y,\n                    L, x + w, y + h,\n                    x, y + h,\n                    'Z'\n                ];\n            },\n\n            'triangle-down': function (x, y, w, h) {\n                return [\n                    M, x, y,\n                    L, x + w, y,\n                    x + w / 2, y + h,\n                    'Z'\n                ];\n            },\n            'diamond': function (x, y, w, h) {\n                return [\n                    M, x + w / 2, y,\n                    L, x + w, y + h / 2,\n                    x + w / 2, y + h,\n                    x, y + h / 2,\n                    'Z'\n                ];\n            },\n            'arc': function (x, y, w, h, options) {\n                var start = options.start,\n                    radius = options.r || w || h,\n                    end = options.end - 0.001, // to prevent cos and sin of start and end from becoming equal on 360 arcs (related: #1561)\n                    innerRadius = options.innerR,\n                    open = options.open,\n                    cosStart = mathCos(start),\n                    sinStart = mathSin(start),\n                    cosEnd = mathCos(end),\n                    sinEnd = mathSin(end),\n                    longArc = options.end - start < mathPI ? 0 : 1;\n\n                return [\n                    M,\n                    x + radius * cosStart,\n                    y + radius * sinStart,\n                    'A', // arcTo\n                    radius, // x radius\n                    radius, // y radius\n                    0, // slanting\n                    longArc, // long or short arc\n                    1, // clockwise\n                    x + radius * cosEnd,\n                    y + radius * sinEnd,\n                    open ? M : L,\n                    x + innerRadius * cosEnd,\n                    y + innerRadius * sinEnd,\n                    'A', // arcTo\n                    innerRadius, // x radius\n                    innerRadius, // y radius\n                    0, // slanting\n                    longArc, // long or short arc\n                    0, // clockwise\n                    x + innerRadius * cosStart,\n                    y + innerRadius * sinStart,\n\n                    open ? '' : 'Z' // close\n                ];\n            },\n\n            /**\n             * Callout shape used for default tooltips, also used for rounded rectangles in VML\n             */\n            callout: function (x, y, w, h, options) {\n                var arrowLength = 6,\n                    halfDistance = 6,\n                    r = mathMin((options && options.r) || 0, w, h),\n                    safeDistance = r + halfDistance,\n                    anchorX = options && options.anchorX,\n                    anchorY = options && options.anchorY,\n                    path;\n\n                path = [\n                    'M', x + r, y,\n                    'L', x + w - r, y, // top side\n                    'C', x + w, y, x + w, y, x + w, y + r, // top-right corner\n                    'L', x + w, y + h - r, // right side\n                    'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-right corner\n                    'L', x + r, y + h, // bottom side\n                    'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner\n                    'L', x, y + r, // left side\n                    'C', x, y, x, y, x + r, y // top-right corner\n                ];\n\n                if (anchorX && anchorX > w && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace right side\n                    path.splice(13, 3,\n                        'L', x + w, anchorY - halfDistance,\n                        x + w + arrowLength, anchorY,\n                        x + w, anchorY + halfDistance,\n                        x + w, y + h - r\n                        );\n                } else if (anchorX && anchorX < 0 && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace left side\n                    path.splice(33, 3,\n                        'L', x, anchorY + halfDistance,\n                        x - arrowLength, anchorY,\n                        x, anchorY - halfDistance,\n                        x, y + r\n                        );\n                } else if (anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace bottom\n                    path.splice(23, 3,\n                        'L', anchorX + halfDistance, y + h,\n                        anchorX, y + h + arrowLength,\n                        anchorX - halfDistance, y + h,\n                        x + r, y + h\n                        );\n                } else if (anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace top\n                    path.splice(3, 3,\n                        'L', anchorX - halfDistance, y,\n                        anchorX, y - arrowLength,\n                        anchorX + halfDistance, y,\n                        w - r, y\n                        );\n                }\n                return path;\n            }\n        },\n\n        /**\n         * Define a clipping rectangle\n         * @param {String} id\n         * @param {Number} x\n         * @param {Number} y\n         * @param {Number} width\n         * @param {Number} height\n         */\n        clipRect: function (x, y, width, height) {\n            var wrapper,\n                id = PREFIX + idCounter++,\n\n                clipPath = this.createElement('clipPath').attr({\n                    id: id\n                }).add(this.defs);\n\n            wrapper = this.rect(x, y, width, height, 0).add(clipPath);\n            wrapper.id = id;\n            wrapper.clipPath = clipPath;\n            wrapper.count = 0;\n\n            return wrapper;\n        },\n\n\n\n\n\n        /**\n         * Add text to the SVG object\n         * @param {String} str\n         * @param {Number} x Left position\n         * @param {Number} y Top position\n         * @param {Boolean} useHTML Use HTML to render the text\n         */\n        text: function (str, x, y, useHTML) {\n\n            // declare variables\n            var renderer = this,\n                fakeSVG = useCanVG || (!hasSVG && renderer.forExport),\n                wrapper,\n                attr = {};\n\n            if (useHTML && (renderer.allowHTML || !renderer.forExport)) {\n                return renderer.html(str, x, y);\n            }\n\n            attr.x = Math.round(x || 0); // X is always needed for line-wrap logic\n            if (y) {\n                attr.y = Math.round(y);\n            }\n            if (str || str === 0) {\n                attr.text = str;\n            }\n\n            wrapper = renderer.createElement('text')\n                .attr(attr);\n\n            // Prevent wrapping from creating false offsetWidths in export in legacy IE (#1079, #1063)\n            if (fakeSVG) {\n                wrapper.css({\n                    position: ABSOLUTE\n                });\n            }\n\n            if (!useHTML) {\n                wrapper.xSetter = function (value, key, element) {\n                    var tspans = element.getElementsByTagName('tspan'),\n                        tspan,\n                        parentVal = element.getAttribute(key),\n                        i;\n                    for (i = 0; i < tspans.length; i++) {\n                        tspan = tspans[i];\n                        // If the x values are equal, the tspan represents a linebreak\n                        if (tspan.getAttribute(key) === parentVal) {\n                            tspan.setAttribute(key, value);\n                        }\n                    }\n                    element.setAttribute(key, value);\n                };\n            }\n\n            return wrapper;\n        },\n\n        /**\n         * Utility to return the baseline offset and total line height from the font size\n         */\n        fontMetrics: function (fontSize, elem) {\n            var lineHeight,\n                baseline,\n                style;\n\n            fontSize = fontSize || this.style.fontSize;\n            if (!fontSize && elem && win.getComputedStyle) {\n                elem = elem.element || elem; // SVGElement\n                style = win.getComputedStyle(elem, '');\n                fontSize = style && style.fontSize; // #4309, the style doesn't exist inside a hidden iframe in Firefox\n            }\n            fontSize = /px/.test(fontSize) ? pInt(fontSize) : /em/.test(fontSize) ? parseFloat(fontSize) * 12 : 12;\n\n            // Empirical values found by comparing font size and bounding box height.\n            // Applies to the default font family. http://jsfiddle.net/highcharts/7xvn7/\n            lineHeight = fontSize < 24 ? fontSize + 3 : mathRound(fontSize * 1.2);\n            baseline = mathRound(lineHeight * 0.8);\n\n            return {\n                h: lineHeight,\n                b: baseline,\n                f: fontSize\n            };\n        },\n\n        /**\n         * Correct X and Y positioning of a label for rotation (#1764)\n         */\n        rotCorr: function (baseline, rotation, alterY) {\n            var y = baseline;\n            if (rotation && alterY) {\n                y = mathMax(y * mathCos(rotation * deg2rad), 4);\n            }\n            return {\n                x: (-baseline / 3) * mathSin(rotation * deg2rad),\n                y: y\n            };\n        },\n\n        /**\n         * Add a label, a text item that can hold a colored or gradient background\n         * as well as a border and shadow.\n         * @param {string} str\n         * @param {Number} x\n         * @param {Number} y\n         * @param {String} shape\n         * @param {Number} anchorX In case the shape has a pointer, like a flag, this is the\n         *    coordinates it should be pinned to\n         * @param {Number} anchorY\n         * @param {Boolean} baseline Whether to position the label relative to the text baseline,\n         *    like renderer.text, or to the upper border of the rectangle.\n         * @param {String} className Class name for the group\n         */\n        label: function (str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {\n\n            var renderer = this,\n                wrapper = renderer.g(className),\n                text = renderer.text('', 0, 0, useHTML)\n                    .attr({\n                        zIndex: 1\n                    }),\n                    //.add(wrapper),\n                box,\n                bBox,\n                alignFactor = 0,\n                padding = 3,\n                paddingLeft = 0,\n                width,\n                height,\n                wrapperX,\n                wrapperY,\n                crispAdjust = 0,\n                deferredAttr = {},\n                baselineOffset,\n                hasBGImage = /^url\\((.*?)\\)$/.test(shape),\n                needsBox = hasBGImage,\n                updateBoxSize,\n                updateTextPadding,\n                boxAttr;\n\n            /**\n             * This function runs after the label is added to the DOM (when the bounding box is\n             * available), and after the text of the label is updated to detect the new bounding\n             * box and reflect it in the border box.\n             */\n            updateBoxSize = function () {\n                var boxX,\n                    boxY,\n                    style = text.element.style;\n\n                bBox = (width === undefined || height === undefined || wrapper.styles.textAlign) && defined(text.textStr) &&\n                    text.getBBox(); //#3295 && 3514 box failure when string equals 0\n                wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;\n                wrapper.height = (height || bBox.height || 0) + 2 * padding;\n\n                // update the label-scoped y offset\n                baselineOffset = padding + renderer.fontMetrics(style && style.fontSize, text).b;\n\n\n                if (needsBox) {\n\n                    if (!box) {\n                        // create the border box if it is not already present\n                        boxX = crispAdjust;\n                        boxY = (baseline ? -baselineOffset : 0) + crispAdjust;\n                        wrapper.box = box = renderer.symbols[shape] || hasBGImage ? // Symbol definition exists (#5324)\n                                renderer.symbol(shape, boxX, boxY, wrapper.width, wrapper.height, deferredAttr) :\n                                renderer.rect(boxX, boxY, wrapper.width, wrapper.height, 0, deferredAttr[STROKE_WIDTH]);\n\n                        if (!box.isImg) { // #4324, fill \"none\" causes it to be ignored by mouse events in IE\n                            box.attr('fill', NONE);\n                        }\n                        box.add(wrapper);\n                    }\n\n                    // apply the box attributes\n                    if (!box.isImg) { // #1630\n                        box.attr(extend({\n                            width: mathRound(wrapper.width),\n                            height: mathRound(wrapper.height)\n                        }, deferredAttr));\n                    }\n                    deferredAttr = null;\n                }\n            };\n\n            /**\n             * This function runs after setting text or padding, but only if padding is changed\n             */\n            updateTextPadding = function () {\n                var styles = wrapper.styles,\n                    textAlign = styles && styles.textAlign,\n                    x = paddingLeft + padding,\n                    y;\n\n                // determin y based on the baseline\n                y = baseline ? 0 : baselineOffset;\n\n                // compensate for alignment\n                if (defined(width) && bBox && (textAlign === 'center' || textAlign === 'right')) {\n                    x += { center: 0.5, right: 1 }[textAlign] * (width - bBox.width);\n                }\n\n                // update if anything changed\n                if (x !== text.x || y !== text.y) {\n                    text.attr('x', x);\n                    if (y !== UNDEFINED) {\n                        text.attr('y', y);\n                    }\n                }\n\n                // record current values\n                text.x = x;\n                text.y = y;\n            };\n\n            /**\n             * Set a box attribute, or defer it if the box is not yet created\n             * @param {Object} key\n             * @param {Object} value\n             */\n            boxAttr = function (key, value) {\n                if (box) {\n                    box.attr(key, value);\n                } else {\n                    deferredAttr[key] = value;\n                }\n            };\n\n            /**\n             * After the text element is added, get the desired size of the border box\n             * and add it before the text in the DOM.\n             */\n            wrapper.onAdd = function () {\n                text.add(wrapper);\n                wrapper.attr({\n                    text: (str || str === 0) ? str : '', // alignment is available now // #3295: 0 not rendered if given as a value\n                    x: x,\n                    y: y\n                });\n\n                if (box && defined(anchorX)) {\n                    wrapper.attr({\n                        anchorX: anchorX,\n                        anchorY: anchorY\n                    });\n                }\n            };\n\n            /*\n             * Add specific attribute setters.\n             */\n\n            // only change local variables\n            wrapper.widthSetter = function (value) {\n                width = value;\n            };\n            wrapper.heightSetter = function (value) {\n                height = value;\n            };\n            wrapper.paddingSetter =  function (value) {\n                if (defined(value) && value !== padding) {\n                    padding = wrapper.padding = value;\n                    updateTextPadding();\n                }\n            };\n            wrapper.paddingLeftSetter =  function (value) {\n                if (defined(value) && value !== paddingLeft) {\n                    paddingLeft = value;\n                    updateTextPadding();\n                }\n            };\n\n\n            // change local variable and prevent setting attribute on the group\n            wrapper.alignSetter = function (value) {\n                value = { left: 0, center: 0.5, right: 1 }[value];\n                if (value !== alignFactor) {\n                    alignFactor = value;\n                    if (bBox) { // Bounding box exists, means we're dynamically changing\n                        wrapper.attr({ x: wrapperX }); // #5134\n                    }\n                }\n            };\n\n            // apply these to the box and the text alike\n            wrapper.textSetter = function (value) {\n                if (value !== UNDEFINED) {\n                    text.textSetter(value);\n                }\n                updateBoxSize();\n                updateTextPadding();\n            };\n\n            // apply these to the box but not to the text\n            wrapper['stroke-widthSetter'] = function (value, key) {\n                if (value) {\n                    needsBox = true;\n                }\n                crispAdjust = value % 2 / 2;\n                boxAttr(key, value);\n            };\n            wrapper.strokeSetter = wrapper.fillSetter = wrapper.rSetter = function (value, key) {\n                if (key === 'fill' && value) {\n                    needsBox = true;\n                }\n                boxAttr(key, value);\n            };\n            wrapper.anchorXSetter = function (value, key) {\n                anchorX = value;\n                boxAttr(key, mathRound(value) - crispAdjust - wrapperX);\n            };\n            wrapper.anchorYSetter = function (value, key) {\n                anchorY = value;\n                boxAttr(key, value - wrapperY);\n            };\n\n            // rename attributes\n            wrapper.xSetter = function (value) {\n                wrapper.x = value; // for animation getter\n                if (alignFactor) {\n                    value -= alignFactor * ((width || bBox.width) + 2 * padding);\n                }\n                wrapperX = mathRound(value);\n                wrapper.attr('translateX', wrapperX);\n            };\n            wrapper.ySetter = function (value) {\n                wrapperY = wrapper.y = mathRound(value);\n                wrapper.attr('translateY', wrapperY);\n            };\n\n            // Redirect certain methods to either the box or the text\n            var baseCss = wrapper.css;\n            return extend(wrapper, {\n                /**\n                 * Pick up some properties and apply them to the text instead of the wrapper\n                 */\n                css: function (styles) {\n                    if (styles) {\n                        var textStyles = {};\n                        styles = merge(styles); // create a copy to avoid altering the original object (#537)\n                        each(wrapper.textProps, function (prop) {\n                            if (styles[prop] !== UNDEFINED) {\n                                textStyles[prop] = styles[prop];\n                                delete styles[prop];\n                            }\n                        });\n                        text.css(textStyles);\n                    }\n                    return baseCss.call(wrapper, styles);\n                },\n                /**\n                 * Return the bounding box of the box, not the group\n                 */\n                getBBox: function () {\n                    return {\n                        width: bBox.width + 2 * padding,\n                        height: bBox.height + 2 * padding,\n                        x: bBox.x - padding,\n                        y: bBox.y - padding\n                    };\n                },\n                /**\n                 * Apply the shadow to the box\n                 */\n                shadow: function (b) {\n                    if (box) {\n                        box.shadow(b);\n                    }\n                    return wrapper;\n                },\n                /**\n                 * Destroy and release memory.\n                 */\n                destroy: function () {\n\n                    // Added by button implementation\n                    removeEvent(wrapper.element, 'mouseenter');\n                    removeEvent(wrapper.element, 'mouseleave');\n\n                    if (text) {\n                        text = text.destroy();\n                    }\n                    if (box) {\n                        box = box.destroy();\n                    }\n                    // Call base implementation to destroy the rest\n                    SVGElement.prototype.destroy.call(wrapper);\n\n                    // Release local pointers (#1298)\n                    wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = null;\n                }\n            });\n        }\n    }; // end SVGRenderer\n\n\n    // general renderer\n    Renderer = SVGRenderer;\n    // extend SvgElement for useHTML option\n    extend(SVGElement.prototype, {\n        /**\n         * Apply CSS to HTML elements. This is used in text within SVG rendering and\n         * by the VML renderer\n         */\n        htmlCss: function (styles) {\n            var wrapper = this,\n                element = wrapper.element,\n                textWidth = styles && element.tagName === 'SPAN' && styles.width;\n\n            if (textWidth) {\n                delete styles.width;\n                wrapper.textWidth = textWidth;\n                wrapper.updateTransform();\n            }\n            if (styles && styles.textOverflow === 'ellipsis') {\n                styles.whiteSpace = 'nowrap';\n                styles.overflow = 'hidden';\n            }\n            wrapper.styles = extend(wrapper.styles, styles);\n            css(wrapper.element, styles);\n\n            return wrapper;\n        },\n\n        /**\n         * VML and useHTML method for calculating the bounding box based on offsets\n         * @param {Boolean} refresh Whether to force a fresh value from the DOM or to\n         * use the cached value\n         *\n         * @return {Object} A hash containing values for x, y, width and height\n         */\n\n        htmlGetBBox: function () {\n            var wrapper = this,\n                element = wrapper.element;\n\n            // faking getBBox in exported SVG in legacy IE\n            // faking getBBox in exported SVG in legacy IE (is this a duplicate of the fix for #1079?)\n            if (element.nodeName === 'text') {\n                element.style.position = ABSOLUTE;\n            }\n\n            return {\n                x: element.offsetLeft,\n                y: element.offsetTop,\n                width: element.offsetWidth,\n                height: element.offsetHeight\n            };\n        },\n\n        /**\n         * VML override private method to update elements based on internal\n         * properties based on SVG transform\n         */\n        htmlUpdateTransform: function () {\n            // aligning non added elements is expensive\n            if (!this.added) {\n                this.alignOnAdd = true;\n                return;\n            }\n\n            var wrapper = this,\n                renderer = wrapper.renderer,\n                elem = wrapper.element,\n                translateX = wrapper.translateX || 0,\n                translateY = wrapper.translateY || 0,\n                x = wrapper.x || 0,\n                y = wrapper.y || 0,\n                align = wrapper.textAlign || 'left',\n                alignCorrection = { left: 0, center: 0.5, right: 1 }[align],\n                shadows = wrapper.shadows,\n                styles = wrapper.styles;\n\n            // apply translate\n            css(elem, {\n                marginLeft: translateX,\n                marginTop: translateY\n            });\n            if (shadows) { // used in labels/tooltip\n                each(shadows, function (shadow) {\n                    css(shadow, {\n                        marginLeft: translateX + 1,\n                        marginTop: translateY + 1\n                    });\n                });\n            }\n\n            // apply inversion\n            if (wrapper.inverted) { // wrapper is a group\n                each(elem.childNodes, function (child) {\n                    renderer.invertChild(child, elem);\n                });\n            }\n\n            if (elem.tagName === 'SPAN') {\n\n                var rotation = wrapper.rotation,\n                    baseline,\n                    textWidth = pInt(wrapper.textWidth),\n                    whiteSpace = styles && styles.whiteSpace,\n                    currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth, wrapper.textAlign].join(',');\n\n                if (currentTextTransform !== wrapper.cTT) { // do the calculations and DOM access only if properties changed\n\n\n                    baseline = renderer.fontMetrics(elem.style.fontSize).b;\n\n                    // Renderer specific handling of span rotation\n                    if (defined(rotation)) {\n                        wrapper.setSpanRotation(rotation, alignCorrection, baseline);\n                    }\n\n                    // Reset multiline/ellipsis in order to read width (#4928, #5417)\n                    css(elem, {\n                        width: '',\n                        whiteSpace: whiteSpace || 'nowrap'\n                    });\n\n                    // Update textWidth\n                    if (elem.offsetWidth > textWidth && /[ \\-]/.test(elem.textContent || elem.innerText)) { // #983, #1254\n                        css(elem, {\n                            width: textWidth + PX,\n                            display: 'block',\n                            whiteSpace: whiteSpace || 'normal' // #3331\n                        });\n                    }\n\n\n                    wrapper.getSpanCorrection(elem.offsetWidth, baseline, alignCorrection, rotation, align);\n                }\n\n                // apply position with correction\n                css(elem, {\n                    left: (x + (wrapper.xCorr || 0)) + PX,\n                    top: (y + (wrapper.yCorr || 0)) + PX\n                });\n\n                // force reflow in webkit to apply the left and top on useHTML element (#1249)\n                if (isWebKit) {\n                    baseline = elem.offsetHeight; // assigned to baseline for lint purpose\n                }\n\n                // record current text transform\n                wrapper.cTT = currentTextTransform;\n            }\n        },\n\n        /**\n         * Set the rotation of an individual HTML span\n         */\n        setSpanRotation: function (rotation, alignCorrection, baseline) {\n            var rotationStyle = {},\n                cssTransformKey = isMS ? '-ms-transform' : isWebKit ? '-webkit-transform' : isFirefox ? 'MozTransform' : isOpera ? '-o-transform' : '';\n\n            rotationStyle[cssTransformKey] = rotationStyle.transform = 'rotate(' + rotation + 'deg)';\n            rotationStyle[cssTransformKey + (isFirefox ? 'Origin' : '-origin')] = rotationStyle.transformOrigin = (alignCorrection * 100) + '% ' + baseline + 'px';\n            css(this.element, rotationStyle);\n        },\n\n        /**\n         * Get the correction in X and Y positioning as the element is rotated.\n         */\n        getSpanCorrection: function (width, baseline, alignCorrection) {\n            this.xCorr = -width * alignCorrection;\n            this.yCorr = -baseline;\n        }\n    });\n\n    // Extend SvgRenderer for useHTML option.\n    extend(SVGRenderer.prototype, {\n        /**\n         * Create HTML text node. This is used by the VML renderer as well as the SVG\n         * renderer through the useHTML option.\n         *\n         * @param {String} str\n         * @param {Number} x\n         * @param {Number} y\n         */\n        html: function (str, x, y) {\n            var wrapper = this.createElement('span'),\n                element = wrapper.element,\n                renderer = wrapper.renderer,\n                isSVG = renderer.isSVG,\n                addSetters = function (element, style) {\n                    // These properties are set as attributes on the SVG group, and as\n                    // identical CSS properties on the div. (#3542)\n                    each(['display', 'opacity', 'visibility'], function (prop) {\n                        wrap(element, prop + 'Setter', function (proceed, value, key, elem) {\n                            proceed.call(this, value, key, elem);\n                            style[key] = value;\n                        });\n                    });            \n                };\n\n            // Text setter\n            wrapper.textSetter = function (value) {\n                if (value !== element.innerHTML) {\n                    delete this.bBox;\n                }\n                element.innerHTML = this.textStr = value;\n                wrapper.htmlUpdateTransform();\n            };\n\n            // Add setters for the element itself (#4938)\n            if (isSVG) { // #4938, only for HTML within SVG\n                addSetters(wrapper, wrapper.element.style);\n            }\n\n            // Various setters which rely on update transform\n            wrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = function (value, key) {\n                if (key === 'align') {\n                    key = 'textAlign'; // Do not overwrite the SVGElement.align method. Same as VML.\n                }\n                wrapper[key] = value;\n                wrapper.htmlUpdateTransform();\n            };\n\n            // Set the default attributes\n            wrapper\n                .attr({\n                    text: str,\n                    x: mathRound(x),\n                    y: mathRound(y)\n                })\n                .css({\n                    position: ABSOLUTE,\n                    fontFamily: this.style.fontFamily,\n                    fontSize: this.style.fontSize\n                });\n\n            // Keep the whiteSpace style outside the wrapper.styles collection\n            element.style.whiteSpace = 'nowrap';\n\n            // Use the HTML specific .css method\n            wrapper.css = wrapper.htmlCss;\n\n            // This is specific for HTML within SVG\n            if (isSVG) {\n                wrapper.add = function (svgGroupWrapper) {\n\n                    var htmlGroup,\n                        container = renderer.box.parentNode,\n                        parentGroup,\n                        parents = [];\n\n                    this.parentGroup = svgGroupWrapper;\n\n                    // Create a mock group to hold the HTML elements\n                    if (svgGroupWrapper) {\n                        htmlGroup = svgGroupWrapper.div;\n                        if (!htmlGroup) {\n\n                            // Read the parent chain into an array and read from top down\n                            parentGroup = svgGroupWrapper;\n                            while (parentGroup) {\n\n                                parents.push(parentGroup);\n\n                                // Move up to the next parent group\n                                parentGroup = parentGroup.parentGroup;\n                            }\n\n                            // Ensure dynamically updating position when any parent is translated\n                            each(parents.reverse(), function (parentGroup) {\n                                var htmlGroupStyle,\n                                    cls = attr(parentGroup.element, 'class');\n\n                                if (cls) {\n                                    cls = { className: cls };\n                                } // else null\n\n                                // Create a HTML div and append it to the parent div to emulate\n                                // the SVG group structure\n                                htmlGroup = parentGroup.div = parentGroup.div || createElement(DIV, cls, {\n                                    position: ABSOLUTE,\n                                    left: (parentGroup.translateX || 0) + PX,\n                                    top: (parentGroup.translateY || 0) + PX,\n                                    display: parentGroup.display,\n                                    opacity: parentGroup.opacity, // #5075\n                                    pointerEvents: parentGroup.styles && parentGroup.styles.pointerEvents // #5595\n                                }, htmlGroup || container); // the top group is appended to container\n\n                                // Shortcut\n                                htmlGroupStyle = htmlGroup.style;\n\n                                // Set listeners to update the HTML div's position whenever the SVG group\n                                // position is changed\n                                extend(parentGroup, {\n                                    translateXSetter: function (value, key) {\n                                        htmlGroupStyle.left = value + PX;\n                                        parentGroup[key] = value;\n                                        parentGroup.doTransform = true;\n                                    },\n                                    translateYSetter: function (value, key) {\n                                        htmlGroupStyle.top = value + PX;\n                                        parentGroup[key] = value;\n                                        parentGroup.doTransform = true;\n                                    }\n                                });\n                                addSetters(parentGroup, htmlGroupStyle);\n                            });\n\n                        }\n                    } else {\n                        htmlGroup = container;\n                    }\n\n                    htmlGroup.appendChild(element);\n\n                    // Shared with VML:\n                    wrapper.added = true;\n                    if (wrapper.alignOnAdd) {\n                        wrapper.htmlUpdateTransform();\n                    }\n\n                    return wrapper;\n                };\n            }\n            return wrapper;\n        }\n    });\n\n\n    /* ****************************************************************************\n     *                                                                            *\n     * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *\n     *                                                                            *\n     * For applications and websites that don't need IE support, like platform    *\n     * targeted mobile apps and web apps, this code can be removed.               *\n     *                                                                            *\n     *****************************************************************************/\n\n    /**\n     * @constructor\n     */\n    var VMLRenderer, VMLElement;\n    if (!hasSVG && !useCanVG) {\n\n    /**\n     * The VML element wrapper.\n     */\n    VMLElement = {\n\n        /**\n         * Initialize a new VML element wrapper. It builds the markup as a string\n         * to minimize DOM traffic.\n         * @param {Object} renderer\n         * @param {Object} nodeName\n         */\n        init: function (renderer, nodeName) {\n            var wrapper = this,\n                markup =  ['<', nodeName, ' filled=\"f\" stroked=\"f\"'],\n                style = ['position: ', ABSOLUTE, ';'],\n                isDiv = nodeName === DIV;\n\n            // divs and shapes need size\n            if (nodeName === 'shape' || isDiv) {\n                style.push('left:0;top:0;width:1px;height:1px;');\n            }\n            style.push('visibility: ', isDiv ? HIDDEN : VISIBLE);\n\n            markup.push(' style=\"', style.join(''), '\"/>');\n\n            // create element with default attributes and style\n            if (nodeName) {\n                markup = isDiv || nodeName === 'span' || nodeName === 'img' ?\n                    markup.join('')    :\n                    renderer.prepVML(markup);\n                wrapper.element = createElement(markup);\n            }\n\n            wrapper.renderer = renderer;\n        },\n\n        /**\n         * Add the node to the given parent\n         * @param {Object} parent\n         */\n        add: function (parent) {\n            var wrapper = this,\n                renderer = wrapper.renderer,\n                element = wrapper.element,\n                box = renderer.box,\n                inverted = parent && parent.inverted,\n\n                // get the parent node\n                parentNode = parent ?\n                    parent.element || parent :\n                    box;\n\n            if (parent) {\n                this.parentGroup = parent;\n            }\n\n            // if the parent group is inverted, apply inversion on all children\n            if (inverted) { // only on groups\n                renderer.invertChild(element, parentNode);\n            }\n\n            // append it\n            parentNode.appendChild(element);\n\n            // align text after adding to be able to read offset\n            wrapper.added = true;\n            if (wrapper.alignOnAdd && !wrapper.deferUpdateTransform) {\n                wrapper.updateTransform();\n            }\n\n            // fire an event for internal hooks\n            if (wrapper.onAdd) {\n                wrapper.onAdd();\n            }\n\n            return wrapper;\n        },\n\n        /**\n         * VML always uses htmlUpdateTransform\n         */\n        updateTransform: SVGElement.prototype.htmlUpdateTransform,\n\n        /**\n         * Set the rotation of a span with oldIE's filter\n         */\n        setSpanRotation: function () {\n            // Adjust for alignment and rotation. Rotation of useHTML content is not yet implemented\n            // but it can probably be implemented for Firefox 3.5+ on user request. FF3.5+\n            // has support for CSS3 transform. The getBBox method also needs to be updated\n            // to compensate for the rotation, like it currently does for SVG.\n            // Test case: http://jsfiddle.net/highcharts/Ybt44/\n\n            var rotation = this.rotation,\n                costheta = mathCos(rotation * deg2rad),\n                sintheta = mathSin(rotation * deg2rad);\n\n            css(this.element, {\n                filter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,\n                    ', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,\n                    ', sizingMethod=\\'auto expand\\')'].join('') : NONE\n            });\n        },\n\n        /**\n         * Get the positioning correction for the span after rotating.\n         */\n        getSpanCorrection: function (width, baseline, alignCorrection, rotation, align) {\n\n            var costheta = rotation ? mathCos(rotation * deg2rad) : 1,\n                sintheta = rotation ? mathSin(rotation * deg2rad) : 0,\n                height = pick(this.elemHeight, this.element.offsetHeight),\n                quad,\n                nonLeft = align && align !== 'left';\n\n            // correct x and y\n            this.xCorr = costheta < 0 && -width;\n            this.yCorr = sintheta < 0 && -height;\n\n            // correct for baseline and corners spilling out after rotation\n            quad = costheta * sintheta < 0;\n            this.xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);\n            this.yCorr -= costheta * baseline * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);\n            // correct for the length/height of the text\n            if (nonLeft) {\n                this.xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);\n                if (rotation) {\n                    this.yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);\n                }\n                css(this.element, {\n                    textAlign: align\n                });\n            }\n        },\n\n        /**\n         * Converts a subset of an SVG path definition to its VML counterpart. Takes an array\n         * as the parameter and returns a string.\n         */\n        pathToVML: function (value) {\n            // convert paths\n            var i = value.length,\n                path = [];\n\n            while (i--) {\n\n                // Multiply by 10 to allow subpixel precision.\n                // Substracting half a pixel seems to make the coordinates\n                // align with SVG, but this hasn't been tested thoroughly\n                if (isNumber(value[i])) {\n                    path[i] = mathRound(value[i] * 10) - 5;\n                } else if (value[i] === 'Z') { // close the path\n                    path[i] = 'x';\n                } else {\n                    path[i] = value[i];\n\n                    // When the start X and end X coordinates of an arc are too close,\n                    // they are rounded to the same value above. In this case, substract or\n                    // add 1 from the end X and Y positions. #186, #760, #1371, #1410.\n                    if (value.isArc && (value[i] === 'wa' || value[i] === 'at')) {\n                        // Start and end X\n                        if (path[i + 5] === path[i + 7]) {\n                            path[i + 7] += value[i + 7] > value[i + 5] ? 1 : -1;\n                        }\n                        // Start and end Y\n                        if (path[i + 6] === path[i + 8]) {\n                            path[i + 8] += value[i + 8] > value[i + 6] ? 1 : -1;\n                        }\n                    }\n                }\n            }\n\n\n            // Loop up again to handle path shortcuts (#2132)\n            /*while (i++ < path.length) {\n                if (path[i] === 'H') { // horizontal line to\n                    path[i] = 'L';\n                    path.splice(i + 2, 0, path[i - 1]);\n                } else if (path[i] === 'V') { // vertical line to\n                    path[i] = 'L';\n                    path.splice(i + 1, 0, path[i - 2]);\n                }\n            }*/\n            return path.join(' ') || 'x';\n        },\n\n        /**\n         * Set the element's clipping to a predefined rectangle\n         *\n         * @param {String} id The id of the clip rectangle\n         */\n        clip: function (clipRect) {\n            var wrapper = this,\n                clipMembers,\n                cssRet;\n\n            if (clipRect) {\n                clipMembers = clipRect.members;\n                erase(clipMembers, wrapper); // Ensure unique list of elements (#1258)\n                clipMembers.push(wrapper);\n                wrapper.destroyClip = function () {\n                    erase(clipMembers, wrapper);\n                };\n                cssRet = clipRect.getCSS(wrapper);\n\n            } else {\n                if (wrapper.destroyClip) {\n                    wrapper.destroyClip();\n                }\n                cssRet = { clip: docMode8 ? 'inherit' : 'rect(auto)' }; // #1214\n            }\n\n            return wrapper.css(cssRet);\n\n        },\n\n        /**\n         * Set styles for the element\n         * @param {Object} styles\n         */\n        css: SVGElement.prototype.htmlCss,\n\n        /**\n         * Removes a child either by removeChild or move to garbageBin.\n         * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.\n         */\n        safeRemoveChild: function (element) {\n            // discardElement will detach the node from its parent before attaching it\n            // to the garbage bin. Therefore it is important that the node is attached and have parent.\n            if (element.parentNode) {\n                discardElement(element);\n            }\n        },\n\n        /**\n         * Extend element.destroy by removing it from the clip members array\n         */\n        destroy: function () {\n            if (this.destroyClip) {\n                this.destroyClip();\n            }\n\n            return SVGElement.prototype.destroy.apply(this);\n        },\n\n        /**\n         * Add an event listener. VML override for normalizing event parameters.\n         * @param {String} eventType\n         * @param {Function} handler\n         */\n        on: function (eventType, handler) {\n            // simplest possible event model for internal use\n            this.element['on' + eventType] = function () {\n                var evt = win.event;\n                evt.target = evt.srcElement;\n                handler(evt);\n            };\n            return this;\n        },\n\n        /**\n         * In stacked columns, cut off the shadows so that they don't overlap\n         */\n        cutOffPath: function (path, length) {\n\n            var len;\n\n            path = path.split(/[ ,]/);\n            len = path.length;\n\n            if (len === 9 || len === 11) {\n                path[len - 4] = path[len - 2] = pInt(path[len - 2]) - 10 * length;\n            }\n            return path.join(' ');\n        },\n\n        /**\n         * Apply a drop shadow by copying elements and giving them different strokes\n         * @param {Boolean|Object} shadowOptions\n         */\n        shadow: function (shadowOptions, group, cutOff) {\n            var shadows = [],\n                i,\n                element = this.element,\n                renderer = this.renderer,\n                shadow,\n                elemStyle = element.style,\n                markup,\n                path = element.path,\n                strokeWidth,\n                modifiedPath,\n                shadowWidth,\n                shadowElementOpacity;\n\n            // some times empty paths are not strings\n            if (path && typeof path.value !== 'string') {\n                path = 'x';\n            }\n            modifiedPath = path;\n\n            if (shadowOptions) {\n                shadowWidth = pick(shadowOptions.width, 3);\n                shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;\n                for (i = 1; i <= 3; i++) {\n\n                    strokeWidth = (shadowWidth * 2) + 1 - (2 * i);\n\n                    // Cut off shadows for stacked column items\n                    if (cutOff) {\n                        modifiedPath = this.cutOffPath(path.value, strokeWidth + 0.5);\n                    }\n\n                    markup = ['<shape isShadow=\"true\" strokeweight=\"', strokeWidth,\n                        '\" filled=\"false\" path=\"', modifiedPath,\n                        '\" coordsize=\"10 10\" style=\"', element.style.cssText, '\" />'];\n\n                    shadow = createElement(renderer.prepVML(markup),\n                        null, {\n                            left: pInt(elemStyle.left) + pick(shadowOptions.offsetX, 1),\n                            top: pInt(elemStyle.top) + pick(shadowOptions.offsetY, 1)\n                        }\n                    );\n                    if (cutOff) {\n                        shadow.cutOff = strokeWidth + 1;\n                    }\n\n                    // apply the opacity\n                    markup = ['<stroke color=\"', shadowOptions.color || 'black', '\" opacity=\"', shadowElementOpacity * i, '\"/>'];\n                    createElement(renderer.prepVML(markup), null, null, shadow);\n\n\n                    // insert it\n                    if (group) {\n                        group.element.appendChild(shadow);\n                    } else {\n                        element.parentNode.insertBefore(shadow, element);\n                    }\n\n                    // record it\n                    shadows.push(shadow);\n\n                }\n\n                this.shadows = shadows;\n            }\n            return this;\n        },\n        updateShadows: noop, // Used in SVG only\n\n        setAttr: function (key, value) {\n            if (docMode8) { // IE8 setAttribute bug\n                this.element[key] = value;\n            } else {\n                this.element.setAttribute(key, value);\n            }\n        },\n        classSetter: function (value) {\n            // IE8 Standards mode has problems retrieving the className unless set like this\n            this.element.className = value;\n        },\n        dashstyleSetter: function (value, key, element) {\n            var strokeElem = element.getElementsByTagName('stroke')[0] ||\n                createElement(this.renderer.prepVML(['<stroke/>']), null, null, element);\n            strokeElem[key] = value || 'solid';\n            this[key] = value; /* because changing stroke-width will change the dash length\n                and cause an epileptic effect */\n        },\n        dSetter: function (value, key, element) {\n            var i,\n                shadows = this.shadows;\n            value = value || [];\n            this.d = value.join && value.join(' '); // used in getter for animation\n\n            element.path = value = this.pathToVML(value);\n\n            // update shadows\n            if (shadows) {\n                i = shadows.length;\n                while (i--) {\n                    shadows[i].path = shadows[i].cutOff ? this.cutOffPath(value, shadows[i].cutOff) : value;\n                }\n            }\n            this.setAttr(key, value);\n        },\n        fillSetter: function (value, key, element) {\n            var nodeName = element.nodeName;\n            if (nodeName === 'SPAN') { // text color\n                element.style.color = value;\n            } else if (nodeName !== 'IMG') { // #1336\n                element.filled = value !== NONE;\n                this.setAttr('fillcolor', this.renderer.color(value, element, key, this));\n            }\n        },\n        'fill-opacitySetter': function (value, key, element) {\n            createElement(\n                this.renderer.prepVML(['<', key.split('-')[0], ' opacity=\"', value, '\"/>']),\n                null,\n                null,\n                element\n            );\n        },\n        opacitySetter: noop, // Don't bother - animation is too slow and filters introduce artifacts\n        rotationSetter: function (value, key, element) {\n            var style = element.style;\n            this[key] = style[key] = value; // style is for #1873\n\n            // Correction for the 1x1 size of the shape container. Used in gauge needles.\n            style.left = -mathRound(mathSin(value * deg2rad) + 1) + PX;\n            style.top = mathRound(mathCos(value * deg2rad)) + PX;\n        },\n        strokeSetter: function (value, key, element) {\n            this.setAttr('strokecolor', this.renderer.color(value, element, key, this));\n        },\n        'stroke-widthSetter': function (value, key, element) {\n            element.stroked = !!value; // VML \"stroked\" attribute\n            this[key] = value; // used in getter, issue #113\n            if (isNumber(value)) {\n                value += PX;\n            }\n            this.setAttr('strokeweight', value);\n        },\n        titleSetter: function (value, key) {\n            this.setAttr(key, value);\n        },\n        visibilitySetter: function (value, key, element) {\n\n            // Handle inherited visibility\n            if (value === 'inherit') {\n                value = VISIBLE;\n            }\n\n            // Let the shadow follow the main element\n            if (this.shadows) {\n                each(this.shadows, function (shadow) {\n                    shadow.style[key] = value;\n                });\n            }\n\n            // Instead of toggling the visibility CSS property, move the div out of the viewport.\n            // This works around #61 and #586\n            if (element.nodeName === 'DIV') {\n                value = value === HIDDEN ? '-999em' : 0;\n\n                // In order to redraw, IE7 needs the div to be visible when tucked away\n                // outside the viewport. So the visibility is actually opposite of\n                // the expected value. This applies to the tooltip only.\n                if (!docMode8) {\n                    element.style[key] = value ? VISIBLE : HIDDEN;\n                }\n                key = 'top';\n            }\n            element.style[key] = value;\n        },\n        displaySetter: function (value, key, element) {\n            element.style[key] = value;\n        },\n        xSetter: function (value, key, element) {\n            this[key] = value; // used in getter\n\n            if (key === 'x') {\n                key = 'left';\n            } else if (key === 'y') {\n                key = 'top';\n            }/* else {\n                value = mathMax(0, value); // don't set width or height below zero (#311)\n            }*/\n\n            // clipping rectangle special\n            if (this.updateClipping) {\n                this[key] = value; // the key is now 'left' or 'top' for 'x' and 'y'\n                this.updateClipping();\n            } else {\n                // normal\n                element.style[key] = value;\n            }\n        },\n        zIndexSetter: function (value, key, element) {\n            element.style[key] = value;\n        }\n    };\n    VMLElement['stroke-opacitySetter'] = VMLElement['fill-opacitySetter'];\n\n    Highcharts.VMLElement = VMLElement = extendClass(SVGElement, VMLElement);\n\n    // Some shared setters\n    VMLElement.prototype.ySetter =\n        VMLElement.prototype.widthSetter =\n        VMLElement.prototype.heightSetter =\n        VMLElement.prototype.xSetter;\n\n\n    /**\n     * The VML renderer\n     */\n    var VMLRendererExtension = { // inherit SVGRenderer\n\n        Element: VMLElement,\n        isIE8: userAgent.indexOf('MSIE 8.0') > -1,\n\n\n        /**\n         * Initialize the VMLRenderer\n         * @param {Object} container\n         * @param {Number} width\n         * @param {Number} height\n         */\n        init: function (container, width, height, style) {\n            var renderer = this,\n                boxWrapper,\n                box,\n                css;\n\n            renderer.alignedObjects = [];\n\n            boxWrapper = renderer.createElement(DIV)\n                .css(extend(this.getStyle(style), { position: 'relative' }));\n            box = boxWrapper.element;\n            container.appendChild(boxWrapper.element);\n\n\n            // generate the containing box\n            renderer.isVML = true;\n            renderer.box = box;\n            renderer.boxWrapper = boxWrapper;\n            renderer.gradients = {};\n            renderer.cache = {}; // Cache for numerical bounding boxes\n            renderer.cacheKeys = [];\n            renderer.imgCount = 0;\n\n\n            renderer.setSize(width, height, false);\n\n            // The only way to make IE6 and IE7 print is to use a global namespace. However,\n            // with IE8 the only way to make the dynamic shapes visible in screen and print mode\n            // seems to be to add the xmlns attribute and the behaviour style inline.\n            if (!doc.namespaces.hcv) {\n\n                doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');\n\n                // Setup default CSS (#2153, #2368, #2384)\n                css = 'hcv\\\\:fill, hcv\\\\:path, hcv\\\\:shape, hcv\\\\:stroke' +\n                    '{ behavior:url(#default#VML); display: inline-block; } ';\n                try {\n                    doc.createStyleSheet().cssText = css;\n                } catch (e) {\n                    doc.styleSheets[0].cssText += css;\n                }\n\n            }\n        },\n\n\n        /**\n         * Detect whether the renderer is hidden. This happens when one of the parent elements\n         * has display: none\n         */\n        isHidden: function () {\n            return !this.box.offsetWidth;\n        },\n\n        /**\n         * Define a clipping rectangle. In VML it is accomplished by storing the values\n         * for setting the CSS style to all associated members.\n         *\n         * @param {Number} x\n         * @param {Number} y\n         * @param {Number} width\n         * @param {Number} height\n         */\n        clipRect: function (x, y, width, height) {\n\n            // create a dummy element\n            var clipRect = this.createElement(),\n                isObj = isObject(x);\n\n            // mimic a rectangle with its style object for automatic updating in attr\n            return extend(clipRect, {\n                members: [],\n                count: 0,\n                left: (isObj ? x.x : x) + 1,\n                top: (isObj ? x.y : y) + 1,\n                width: (isObj ? x.width : width) - 1,\n                height: (isObj ? x.height : height) - 1,\n                getCSS: function (wrapper) {\n                    var element = wrapper.element,\n                        nodeName = element.nodeName,\n                        isShape = nodeName === 'shape',\n                        inverted = wrapper.inverted,\n                        rect = this,\n                        top = rect.top - (isShape ? element.offsetTop : 0),\n                        left = rect.left,\n                        right = left + rect.width,\n                        bottom = top + rect.height,\n                        ret = {\n                            clip: 'rect(' +\n                                mathRound(inverted ? left : top) + 'px,' +\n                                mathRound(inverted ? bottom : right) + 'px,' +\n                                mathRound(inverted ? right : bottom) + 'px,' +\n                                mathRound(inverted ? top : left) + 'px)'\n                        };\n\n                    // issue 74 workaround\n                    if (!inverted && docMode8 && nodeName === 'DIV') {\n                        extend(ret, {\n                            width: right + PX,\n                            height: bottom + PX\n                        });\n                    }\n                    return ret;\n                },\n\n                // used in attr and animation to update the clipping of all members\n                updateClipping: function () {\n                    each(clipRect.members, function (member) {\n                        if (member.element) { // Deleted series, like in stock/members/series-remove demo. Should be removed from members, but this will do.\n                            member.css(clipRect.getCSS(member));\n                        }\n                    });\n                }\n            });\n\n        },\n\n\n        /**\n         * Take a color and return it if it's a string, make it a gradient if it's a\n         * gradient configuration object, and apply opacity.\n         *\n         * @param {Object} color The color or config object\n         */\n        color: function (color, elem, prop, wrapper) {\n            var renderer = this,\n                colorObject,\n                regexRgba = /^rgba/,\n                markup,\n                fillType,\n                ret = NONE;\n\n            // Check for linear or radial gradient\n            if (color && color.linearGradient) {\n                fillType = 'gradient';\n            } else if (color && color.radialGradient) {\n                fillType = 'pattern';\n            }\n\n\n            if (fillType) {\n\n                var stopColor,\n                    stopOpacity,\n                    gradient = color.linearGradient || color.radialGradient,\n                    x1,\n                    y1,\n                    x2,\n                    y2,\n                    opacity1,\n                    opacity2,\n                    color1,\n                    color2,\n                    fillAttr = '',\n                    stops = color.stops,\n                    firstStop,\n                    lastStop,\n                    colors = [],\n                    addFillNode = function () {\n                        // Add the fill subnode. When colors attribute is used, the meanings of opacity and o:opacity2\n                        // are reversed.\n                        markup = ['<fill colors=\"' + colors.join(',') + '\" opacity=\"', opacity2, '\" o:opacity2=\"', opacity1,\n                            '\" type=\"', fillType, '\" ', fillAttr, 'focus=\"100%\" method=\"any\" />'];\n                        createElement(renderer.prepVML(markup), null, null, elem);\n                    };\n\n                // Extend from 0 to 1\n                firstStop = stops[0];\n                lastStop = stops[stops.length - 1];\n                if (firstStop[0] > 0) {\n                    stops.unshift([\n                        0,\n                        firstStop[1]\n                    ]);\n                }\n                if (lastStop[0] < 1) {\n                    stops.push([\n                        1,\n                        lastStop[1]\n                    ]);\n                }\n\n                // Compute the stops\n                each(stops, function (stop, i) {\n                    if (regexRgba.test(stop[1])) {\n                        colorObject = Color(stop[1]);\n                        stopColor = colorObject.get('rgb');\n                        stopOpacity = colorObject.get('a');\n                    } else {\n                        stopColor = stop[1];\n                        stopOpacity = 1;\n                    }\n\n                    // Build the color attribute\n                    colors.push((stop[0] * 100) + '% ' + stopColor);\n\n                    // Only start and end opacities are allowed, so we use the first and the last\n                    if (!i) {\n                        opacity1 = stopOpacity;\n                        color2 = stopColor;\n                    } else {\n                        opacity2 = stopOpacity;\n                        color1 = stopColor;\n                    }\n                });\n\n                // Apply the gradient to fills only.\n                if (prop === 'fill') {\n\n                    // Handle linear gradient angle\n                    if (fillType === 'gradient') {\n                        x1 = gradient.x1 || gradient[0] || 0;\n                        y1 = gradient.y1 || gradient[1] || 0;\n                        x2 = gradient.x2 || gradient[2] || 0;\n                        y2 = gradient.y2 || gradient[3] || 0;\n                        fillAttr = 'angle=\"' + (90  - math.atan(\n                            (y2 - y1) / // y vector\n                            (x2 - x1) // x vector\n                            ) * 180 / mathPI) + '\"';\n\n                        addFillNode();\n\n                    // Radial (circular) gradient\n                    } else {\n\n                        var r = gradient.r,\n                            sizex = r * 2,\n                            sizey = r * 2,\n                            cx = gradient.cx,\n                            cy = gradient.cy,\n                            radialReference = elem.radialReference,\n                            bBox,\n                            applyRadialGradient = function () {\n                                if (radialReference) {\n                                    bBox = wrapper.getBBox();\n                                    cx += (radialReference[0] - bBox.x) / bBox.width - 0.5;\n                                    cy += (radialReference[1] - bBox.y) / bBox.height - 0.5;\n                                    sizex *= radialReference[2] / bBox.width;\n                                    sizey *= radialReference[2] / bBox.height;\n                                }\n                                fillAttr = 'src=\"' + defaultOptions.global.VMLRadialGradientURL + '\" ' +\n                                    'size=\"' + sizex + ',' + sizey + '\" ' +\n                                    'origin=\"0.5,0.5\" ' +\n                                    'position=\"' + cx + ',' + cy + '\" ' +\n                                    'color2=\"' + color2 + '\" ';\n\n                                addFillNode();\n                            };\n\n                        // Apply radial gradient\n                        if (wrapper.added) {\n                            applyRadialGradient();\n                        } else {\n                            // We need to know the bounding box to get the size and position right\n                            wrapper.onAdd = applyRadialGradient;\n                        }\n\n                        // The fill element's color attribute is broken in IE8 standards mode, so we\n                        // need to set the parent shape's fillcolor attribute instead.\n                        ret = color1;\n                    }\n\n                // Gradients are not supported for VML stroke, return the first color. #722.\n                } else {\n                    ret = stopColor;\n                }\n\n            // If the color is an rgba color, split it and add a fill node\n            // to hold the opacity component\n            } else if (regexRgba.test(color) && elem.tagName !== 'IMG') {\n\n                colorObject = Color(color);\n\n                wrapper[prop + '-opacitySetter'](colorObject.get('a'), prop, elem);\n\n                ret = colorObject.get('rgb');\n\n\n            } else {\n                var propNodes = elem.getElementsByTagName(prop); // 'stroke' or 'fill' node\n                if (propNodes.length) {\n                    propNodes[0].opacity = 1;\n                    propNodes[0].type = 'solid';\n                }\n                ret = color;\n            }\n\n            return ret;\n        },\n\n        /**\n         * Take a VML string and prepare it for either IE8 or IE6/IE7.\n         * @param {Array} markup A string array of the VML markup to prepare\n         */\n        prepVML: function (markup) {\n            var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',\n                isIE8 = this.isIE8;\n\n            markup = markup.join('');\n\n            if (isIE8) { // add xmlns and style inline\n                markup = markup.replace('/>', ' xmlns=\"urn:schemas-microsoft-com:vml\" />');\n                if (markup.indexOf('style=\"') === -1) {\n                    markup = markup.replace('/>', ' style=\"' + vmlStyle + '\" />');\n                } else {\n                    markup = markup.replace('style=\"', 'style=\"' + vmlStyle);\n                }\n\n            } else { // add namespace\n                markup = markup.replace('<', '<hcv:');\n            }\n\n            return markup;\n        },\n\n        /**\n         * Create rotated and aligned text\n         * @param {String} str\n         * @param {Number} x\n         * @param {Number} y\n         */\n        text: SVGRenderer.prototype.html,\n\n        /**\n         * Create and return a path element\n         * @param {Array} path\n         */\n        path: function (path) {\n            var attr = {\n                // subpixel precision down to 0.1 (width and height = 1px)\n                coordsize: '10 10'\n            };\n            if (isArray(path)) {\n                attr.d = path;\n            } else if (isObject(path)) { // attributes\n                extend(attr, path);\n            }\n            // create the shape\n            return this.createElement('shape').attr(attr);\n        },\n\n        /**\n         * Create and return a circle element. In VML circles are implemented as\n         * shapes, which is faster than v:oval\n         * @param {Number} x\n         * @param {Number} y\n         * @param {Number} r\n         */\n        circle: function (x, y, r) {\n            var circle = this.symbol('circle');\n            if (isObject(x)) {\n                r = x.r;\n                y = x.y;\n                x = x.x;\n            }\n            circle.isCircle = true; // Causes x and y to mean center (#1682)\n            circle.r = r;\n            return circle.attr({ x: x, y: y });\n        },\n\n        /**\n         * Create a group using an outer div and an inner v:group to allow rotating\n         * and flipping. A simple v:group would have problems with positioning\n         * child HTML elements and CSS clip.\n         *\n         * @param {String} name The name of the group\n         */\n        g: function (name) {\n            var wrapper,\n                attribs;\n\n            // set the class name\n            if (name) {\n                attribs = { 'className': PREFIX + name, 'class': PREFIX + name };\n            }\n\n            // the div to hold HTML and clipping\n            wrapper = this.createElement(DIV).attr(attribs);\n\n            return wrapper;\n        },\n\n        /**\n         * VML override to create a regular HTML image\n         * @param {String} src\n         * @param {Number} x\n         * @param {Number} y\n         * @param {Number} width\n         * @param {Number} height\n         */\n        image: function (src, x, y, width, height) {\n            var obj = this.createElement('img')\n                .attr({ src: src });\n\n            if (arguments.length > 1) {\n                obj.attr({\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n            }\n            return obj;\n        },\n\n        /**\n         * For rectangles, VML uses a shape for rect to overcome bugs and rotation problems\n         */\n        createElement: function (nodeName) {\n            return nodeName === 'rect' ? this.symbol(nodeName) : SVGRenderer.prototype.createElement.call(this, nodeName);\n        },\n\n        /**\n         * In the VML renderer, each child of an inverted div (group) is inverted\n         * @param {Object} element\n         * @param {Object} parentNode\n         */\n        invertChild: function (element, parentNode) {\n            var ren = this,\n                parentStyle = parentNode.style,\n                imgStyle = element.tagName === 'IMG' && element.style; // #1111\n\n            css(element, {\n                flip: 'x',\n                left: pInt(parentStyle.width) - (imgStyle ? pInt(imgStyle.top) : 1),\n                top: pInt(parentStyle.height) - (imgStyle ? pInt(imgStyle.left) : 1),\n                rotation: -90\n            });\n\n            // Recursively invert child elements, needed for nested composite shapes like box plots and error bars. #1680, #1806.\n            each(element.childNodes, function (child) {\n                ren.invertChild(child, element);\n            });\n        },\n\n        /**\n         * Symbol definitions that override the parent SVG renderer's symbols\n         *\n         */\n        symbols: {\n            // VML specific arc function\n            arc: function (x, y, w, h, options) {\n                var start = options.start,\n                    end = options.end,\n                    radius = options.r || w || h,\n                    innerRadius = options.innerR,\n                    cosStart = mathCos(start),\n                    sinStart = mathSin(start),\n                    cosEnd = mathCos(end),\n                    sinEnd = mathSin(end),\n                    ret;\n\n                if (end - start === 0) { // no angle, don't show it.\n                    return ['x'];\n                }\n\n                ret = [\n                    'wa', // clockwise arc to\n                    x - radius, // left\n                    y - radius, // top\n                    x + radius, // right\n                    y + radius, // bottom\n                    x + radius * cosStart, // start x\n                    y + radius * sinStart, // start y\n                    x + radius * cosEnd, // end x\n                    y + radius * sinEnd  // end y\n                ];\n\n                if (options.open && !innerRadius) {\n                    ret.push(\n                        'e',\n                        M,\n                        x, // - innerRadius,\n                        y// - innerRadius\n                    );\n                }\n\n                ret.push(\n                    'at', // anti clockwise arc to\n                    x - innerRadius, // left\n                    y - innerRadius, // top\n                    x + innerRadius, // right\n                    y + innerRadius, // bottom\n                    x + innerRadius * cosEnd, // start x\n                    y + innerRadius * sinEnd, // start y\n                    x + innerRadius * cosStart, // end x\n                    y + innerRadius * sinStart, // end y\n                    'x', // finish path\n                    'e' // close\n                );\n\n                ret.isArc = true;\n                return ret;\n\n            },\n            // Add circle symbol path. This performs significantly faster than v:oval.\n            circle: function (x, y, w, h, wrapper) {\n\n                if (wrapper) {\n                    w = h = 2 * wrapper.r;\n                }\n\n                // Center correction, #1682\n                if (wrapper && wrapper.isCircle) {\n                    x -= w / 2;\n                    y -= h / 2;\n                }\n\n                // Return the path\n                return [\n                    'wa', // clockwisearcto\n                    x, // left\n                    y, // top\n                    x + w, // right\n                    y + h, // bottom\n                    x + w, // start x\n                    y + h / 2,     // start y\n                    x + w, // end x\n                    y + h / 2,     // end y\n                    //'x', // finish path\n                    'e' // close\n                ];\n            },\n            /**\n             * Add rectangle symbol path which eases rotation and omits arcsize problems\n             * compared to the built-in VML roundrect shape. When borders are not rounded,\n             * use the simpler square path, else use the callout path without the arrow.\n             */\n            rect: function (x, y, w, h, options) {\n                return SVGRenderer.prototype.symbols[\n                    !defined(options) || !options.r ? 'square' : 'callout'\n                ].call(0, x, y, w, h, options);\n            }\n        }\n    };\n    Highcharts.VMLRenderer = VMLRenderer = function () {\n        this.init.apply(this, arguments);\n    };\n    VMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);\n\n        // general renderer\n        Renderer = VMLRenderer;\n    }\n\n    // This method is used with exporting in old IE, when emulating SVG (see #2314)\n    SVGRenderer.prototype.measureSpanWidth = function (text, styles) {\n        var measuringSpan = doc.createElement('span'),\n            offsetWidth,\n            textNode = doc.createTextNode(text);\n\n        measuringSpan.appendChild(textNode);\n        css(measuringSpan, styles);\n        this.box.appendChild(measuringSpan);\n        offsetWidth = measuringSpan.offsetWidth;\n        discardElement(measuringSpan); // #2463\n        return offsetWidth;\n    };\n\n\n    /* ****************************************************************************\n     *                                                                            *\n     * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *\n     *                                                                            *\n     *****************************************************************************/\n    /* ****************************************************************************\n     *                                                                            *\n     * START OF ANDROID < 3 SPECIFIC CODE. THIS CAN BE REMOVED IF YOU'RE NOT      *\n     * TARGETING THAT SYSTEM.                                                     *\n     *                                                                            *\n     *****************************************************************************/\n    var CanVGRenderer,\n        CanVGController;\n\n    /**\n     * Downloads a script and executes a callback when done.\n     * @param {String} scriptLocation\n     * @param {Function} callback\n     */\n    function getScript(scriptLocation, callback) {\n        var head = doc.getElementsByTagName('head')[0],\n            script = doc.createElement('script');\n\n        script.type = 'text/javascript';\n        script.src = scriptLocation;\n        script.onload = callback;\n\n        head.appendChild(script);\n    }\n\n    if (useCanVG) {\n        /**\n         * The CanVGRenderer is empty from start to keep the source footprint small.\n         * When requested, the CanVGController downloads the rest of the source packaged\n         * together with the canvg library.\n         */\n        Highcharts.CanVGRenderer = CanVGRenderer = function () {\n            // Override the global SVG namespace to fake SVG/HTML that accepts CSS\n            SVG_NS = 'http://www.w3.org/1999/xhtml';\n        };\n\n        /**\n         * Start with an empty symbols object. This is needed when exporting is used (exporting.src.js will add a few symbols), but\n         * the implementation from SvgRenderer will not be merged in until first render.\n         */\n        CanVGRenderer.prototype.symbols = {};\n\n        /**\n         * Handles on demand download of canvg rendering support.\n         */\n        CanVGController = (function () {\n            // List of renderering calls\n            var deferredRenderCalls = [];\n\n            /**\n             * When downloaded, we are ready to draw deferred charts.\n             */\n            function drawDeferred() {\n                var callLength = deferredRenderCalls.length,\n                    callIndex;\n\n                // Draw all pending render calls\n                for (callIndex = 0; callIndex < callLength; callIndex++) {\n                    deferredRenderCalls[callIndex]();\n                }\n                // Clear the list\n                deferredRenderCalls = [];\n            }\n\n            return {\n                push: function (func, scriptLocation) {\n                    // Only get the script once\n                    if (deferredRenderCalls.length === 0) {\n                        getScript(scriptLocation, drawDeferred);\n                    }\n                    // Register render call\n                    deferredRenderCalls.push(func);\n                }\n            };\n        }());\n\n        Renderer = CanVGRenderer;\n    } // end CanVGRenderer\n\n    /* ****************************************************************************\n     *                                                                            *\n     * END OF ANDROID < 3 SPECIFIC CODE                                           *\n     *                                                                            *\n     *****************************************************************************/\n\n    /**\n     * The Tick class\n     */\n    function Tick(axis, pos, type, noLabel) {\n        this.axis = axis;\n        this.pos = pos;\n        this.type = type || '';\n        this.isNew = true;\n\n        if (!type && !noLabel) {\n            this.addLabel();\n        }\n    }\n\n    Tick.prototype = {\n        /**\n         * Write the tick label\n         */\n        addLabel: function () {\n            var tick = this,\n                axis = tick.axis,\n                options = axis.options,\n                chart = axis.chart,\n                categories = axis.categories,\n                names = axis.names,\n                pos = tick.pos,\n                labelOptions = options.labels,\n                str,\n                tickPositions = axis.tickPositions,\n                isFirst = pos === tickPositions[0],\n                isLast = pos === tickPositions[tickPositions.length - 1],\n                value = categories ?\n                    pick(categories[pos], names[pos], pos) :\n                    pos,\n                label = tick.label,\n                tickPositionInfo = tickPositions.info,\n                dateTimeLabelFormat;\n\n            // Set the datetime label format. If a higher rank is set for this position, use that. If not,\n            // use the general format.\n            if (axis.isDatetimeAxis && tickPositionInfo) {\n                dateTimeLabelFormat = options.dateTimeLabelFormats[tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName];\n            }\n            // set properties for access in render method\n            tick.isFirst = isFirst;\n            tick.isLast = isLast;\n\n            // get the string\n            str = axis.labelFormatter.call({\n                axis: axis,\n                chart: chart,\n                isFirst: isFirst,\n                isLast: isLast,\n                dateTimeLabelFormat: dateTimeLabelFormat,\n                value: axis.isLog ? correctFloat(axis.lin2log(value)) : value\n            });\n\n            // prepare CSS\n            //css = width && { width: mathMax(1, mathRound(width - 2 * (labelOptions.padding || 10))) + PX };\n\n            // first call\n            if (!defined(label)) {\n\n                tick.label = label =\n                    defined(str) && labelOptions.enabled ?\n                        chart.renderer.text(\n                                str,\n                                0,\n                                0,\n                                labelOptions.useHTML\n                            )\n                            //.attr(attr)\n                            // without position absolute, IE export sometimes is wrong\n                            .css(merge(labelOptions.style))\n                            .add(axis.labelGroup) :\n                        null;\n                tick.labelLength = label && label.getBBox().width; // Un-rotated length\n                tick.rotation = 0; // Base value to detect change for new calls to getBBox\n\n            // update\n            } else if (label) {\n                label.attr({ text: str });\n            }\n        },\n\n        /**\n         * Get the offset height or width of the label\n         */\n        getLabelSize: function () {\n            return this.label ?\n                this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] :\n                0;\n        },\n\n        /**\n         * Handle the label overflow by adjusting the labels to the left and right edge, or\n         * hide them if they collide into the neighbour label.\n         */\n        handleOverflow: function (xy) {\n            var axis = this.axis,\n                pxPos = xy.x,\n                chartWidth = axis.chart.chartWidth,\n                spacing = axis.chart.spacing,\n                leftBound = pick(axis.labelLeft, mathMin(axis.pos, spacing[3])),\n                rightBound = pick(axis.labelRight, mathMax(axis.pos + axis.len, chartWidth - spacing[1])),\n                label = this.label,\n                rotation = this.rotation,\n                factor = { left: 0, center: 0.5, right: 1 }[axis.labelAlign],\n                labelWidth = label.getBBox().width,\n                slotWidth = axis.getSlotWidth(),\n                modifiedSlotWidth = slotWidth,\n                xCorrection = factor,\n                goRight = 1,\n                leftPos,\n                rightPos,\n                textWidth,\n                css = {};\n\n            // Check if the label overshoots the chart spacing box. If it does, move it.\n            // If it now overshoots the slotWidth, add ellipsis.\n            if (!rotation) {\n                leftPos = pxPos - factor * labelWidth;\n                rightPos = pxPos + (1 - factor) * labelWidth;\n\n                if (leftPos < leftBound) {\n                    modifiedSlotWidth = xy.x + modifiedSlotWidth * (1 - factor) - leftBound;\n                } else if (rightPos > rightBound) {\n                    modifiedSlotWidth = rightBound - xy.x + modifiedSlotWidth * factor;\n                    goRight = -1;\n                }\n\n                modifiedSlotWidth = mathMin(slotWidth, modifiedSlotWidth); // #4177\n                if (modifiedSlotWidth < slotWidth && axis.labelAlign === 'center') {\n                    xy.x += goRight * (slotWidth - modifiedSlotWidth - xCorrection * (slotWidth - mathMin(labelWidth, modifiedSlotWidth)));\n                }\n                // If the label width exceeds the available space, set a text width to be\n                // picked up below. Also, if a width has been set before, we need to set a new\n                // one because the reported labelWidth will be limited by the box (#3938).\n                if (labelWidth > modifiedSlotWidth || (axis.autoRotation && label.styles.width)) {\n                    textWidth = modifiedSlotWidth;\n                }\n\n            // Add ellipsis to prevent rotated labels to be clipped against the edge of the chart\n            } else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {\n                textWidth = mathRound(pxPos / mathCos(rotation * deg2rad) - leftBound);\n            } else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {\n                textWidth = mathRound((chartWidth - pxPos) / mathCos(rotation * deg2rad));\n            }\n\n            if (textWidth) {\n                css.width = textWidth;\n                if (!axis.options.labels.style.textOverflow) {\n                    css.textOverflow = 'ellipsis';\n                }\n                label.css(css);\n            }\n        },\n\n        /**\n         * Get the x and y position for ticks and labels\n         */\n        getPosition: function (horiz, pos, tickmarkOffset, old) {\n            var axis = this.axis,\n                chart = axis.chart,\n                cHeight = (old && chart.oldChartHeight) || chart.chartHeight;\n\n            return {\n                x: horiz ?\n                    axis.translate(pos + tickmarkOffset, null, null, old) + axis.transB :\n                    axis.left + axis.offset + (axis.opposite ? ((old && chart.oldChartWidth) || chart.chartWidth) - axis.right - axis.left : 0),\n\n                y: horiz ?\n                    cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) :\n                    cHeight - axis.translate(pos + tickmarkOffset, null, null, old) - axis.transB\n            };\n\n        },\n\n        /**\n         * Get the x, y position of the tick label\n         */\n        getLabelPosition: function (x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {\n            var axis = this.axis,\n                transA = axis.transA,\n                reversed = axis.reversed,\n                staggerLines = axis.staggerLines,\n                rotCorr = axis.tickRotCorr || { x: 0, y: 0 },\n                yOffset = labelOptions.y,\n                line;\n\n            if (!defined(yOffset)) {\n                if (axis.side === 0) {\n                    yOffset = label.rotation ? -8 : -label.getBBox().height;\n                } else if (axis.side === 2) {\n                    yOffset = rotCorr.y + 8;\n                } else {\n                    // #3140, #3140\n                    yOffset = mathCos(label.rotation * deg2rad) * (rotCorr.y - label.getBBox(false, 0).height / 2);\n                }\n            }\n\n            x = x + labelOptions.x + rotCorr.x - (tickmarkOffset && horiz ?\n                tickmarkOffset * transA * (reversed ? -1 : 1) : 0);\n            y = y + yOffset - (tickmarkOffset && !horiz ?\n                tickmarkOffset * transA * (reversed ? 1 : -1) : 0);\n\n            // Correct for staggered labels\n            if (staggerLines) {\n                line = (index / (step || 1) % staggerLines);\n                if (axis.opposite) {\n                    line = staggerLines - line - 1;\n                }\n                y += line * (axis.labelOffset / staggerLines);\n            }\n\n            return {\n                x: x,\n                y: mathRound(y)\n            };\n        },\n\n        /**\n         * Extendible method to return the path of the marker\n         */\n        getMarkPath: function (x, y, tickLength, tickWidth, horiz, renderer) {\n            return renderer.crispLine([\n                M,\n                x,\n                y,\n                L,\n                x + (horiz ? 0 : -tickLength),\n                y + (horiz ? tickLength : 0)\n            ], tickWidth);\n        },\n\n        /**\n         * Put everything in place\n         *\n         * @param index {Number}\n         * @param old {Boolean} Use old coordinates to prepare an animation into new position\n         */\n        render: function (index, old, opacity) {\n            var tick = this,\n                axis = tick.axis,\n                options = axis.options,\n                chart = axis.chart,\n                renderer = chart.renderer,\n                horiz = axis.horiz,\n                type = tick.type,\n                label = tick.label,\n                pos = tick.pos,\n                labelOptions = options.labels,\n                gridLine = tick.gridLine,\n                gridPrefix = type ? type + 'Grid' : 'grid',\n                tickPrefix = type ? type + 'Tick' : 'tick',\n                gridLineWidth = options[gridPrefix + 'LineWidth'],\n                gridLineColor = options[gridPrefix + 'LineColor'],\n                dashStyle = options[gridPrefix + 'LineDashStyle'],\n                tickSize = axis.tickSize(tickPrefix),\n                tickColor = options[tickPrefix + 'Color'],\n                gridLinePath,\n                mark = tick.mark,\n                markPath,\n                step = /*axis.labelStep || */labelOptions.step,\n                attribs,\n                show = true,\n                tickmarkOffset = axis.tickmarkOffset,\n                xy = tick.getPosition(horiz, pos, tickmarkOffset, old),\n                x = xy.x,\n                y = xy.y,\n                reverseCrisp = ((horiz && x === axis.pos + axis.len) || (!horiz && y === axis.pos)) ? -1 : 1; // #1480, #1687\n\n            opacity = pick(opacity, 1);\n            this.isActive = true;\n\n            // create the grid line\n            if (gridLineWidth) {\n                gridLinePath = axis.getPlotLinePath(pos + tickmarkOffset, gridLineWidth * reverseCrisp, old, true);\n\n                if (gridLine === UNDEFINED) {\n                    attribs = {\n                        stroke: gridLineColor,\n                        'stroke-width': gridLineWidth\n                    };\n                    if (dashStyle) {\n                        attribs.dashstyle = dashStyle;\n                    }\n                    if (!type) {\n                        attribs.zIndex = 1;\n                    }\n                    if (old) {\n                        attribs.opacity = 0;\n                    }\n                    tick.gridLine = gridLine =\n                        gridLineWidth ?\n                            renderer.path(gridLinePath)\n                                .attr(attribs).add(axis.gridGroup) :\n                            null;\n                }\n\n                // If the parameter 'old' is set, the current call will be followed\n                // by another call, therefore do not do any animations this time\n                if (!old && gridLine && gridLinePath) {\n                    gridLine[tick.isNew ? 'attr' : 'animate']({\n                        d: gridLinePath,\n                        opacity: opacity\n                    });\n                }\n            }\n\n            // create the tick mark\n            if (tickSize) {\n                if (axis.opposite) {\n                    tickSize[0] = -tickSize[0];\n                }\n                markPath = tick.getMarkPath(x, y, tickSize[0], tickSize[1] * reverseCrisp, horiz, renderer);\n                if (mark) { // updating\n                    mark.animate({\n                        d: markPath,\n                        opacity: opacity\n                    });\n                } else { // first time\n                    tick.mark = renderer.path(\n                        markPath\n                    ).attr({\n                        stroke: tickColor,\n                        'stroke-width': tickSize[1],\n                        opacity: opacity\n                    }).add(axis.axisGroup);\n                }\n            }\n\n            // the label is created on init - now move it into place\n            if (label && isNumber(x)) {\n                label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);\n\n                // Apply show first and show last. If the tick is both first and last, it is\n                // a single centered tick, in which case we show the label anyway (#2100).\n                if ((tick.isFirst && !tick.isLast && !pick(options.showFirstLabel, 1)) ||\n                        (tick.isLast && !tick.isFirst && !pick(options.showLastLabel, 1))) {\n                    show = false;\n\n                // Handle label overflow and show or hide accordingly\n                } else if (horiz && !axis.isRadial && !labelOptions.step && !labelOptions.rotation && !old && opacity !== 0) {\n                    tick.handleOverflow(xy);\n                }\n\n                // apply step\n                if (step && index % step) {\n                    // show those indices dividable by step\n                    show = false;\n                }\n\n                // Set the new position, and show or hide\n                if (show && isNumber(xy.y)) {\n                    xy.opacity = opacity;\n                    label[tick.isNew ? 'attr' : 'animate'](xy);\n                } else {\n                    stop(label); // #5332\n                    label.attr('y', -9999); // #1338\n                }\n                tick.isNew = false;\n            }\n        },\n\n        /**\n         * Destructor for the tick prototype\n         */\n        destroy: function () {\n            destroyObjectProperties(this, this.axis);\n        }\n    };\n\n    /**\n     * The object wrapper for plot lines and plot bands\n     * @param {Object} options\n     */\n    Highcharts.PlotLineOrBand = function (axis, options) {\n        this.axis = axis;\n\n        if (options) {\n            this.options = options;\n            this.id = options.id;\n        }\n    };\n\n    Highcharts.PlotLineOrBand.prototype = {\n\n        /**\n         * Render the plot line or plot band. If it is already existing,\n         * move it.\n         */\n        render: function () {\n            var plotLine = this,\n                axis = plotLine.axis,\n                horiz = axis.horiz,\n                options = plotLine.options,\n                optionsLabel = options.label,\n                label = plotLine.label,\n                width = options.width,\n                to = options.to,\n                from = options.from,\n                isBand = defined(from) && defined(to),\n                value = options.value,\n                dashStyle = options.dashStyle,\n                svgElem = plotLine.svgElem,\n                path = [],\n                addEvent,\n                eventType,\n                color = options.color,\n                zIndex = pick(options.zIndex, 0),\n                events = options.events,\n                attribs = {},\n                renderer = axis.chart.renderer,\n                log2lin = axis.log2lin;\n\n            // logarithmic conversion\n            if (axis.isLog) {\n                from = log2lin(from);\n                to = log2lin(to);\n                value = log2lin(value);\n            }\n\n            // plot line\n            if (width) {\n                path = axis.getPlotLinePath(value, width);\n                attribs = {\n                    stroke: color,\n                    'stroke-width': width\n                };\n                if (dashStyle) {\n                    attribs.dashstyle = dashStyle;\n                }\n            } else if (isBand) { // plot band\n\n                path = axis.getPlotBandPath(from, to, options);\n                if (color) {\n                    attribs.fill = color;\n                }\n                if (options.borderWidth) {\n                    attribs.stroke = options.borderColor;\n                    attribs['stroke-width'] = options.borderWidth;\n                }\n            } else {\n                return;\n            }\n            // zIndex\n            attribs.zIndex = zIndex;\n\n            // common for lines and bands\n            if (svgElem) {\n                if (path) {\n                    svgElem.show();\n                    svgElem.animate({ d: path });\n                } else {\n                    svgElem.hide();\n                    if (label) {\n                        plotLine.label = label = label.destroy();\n                    }\n                }\n            } else if (path && path.length) {\n                plotLine.svgElem = svgElem = renderer.path(path)\n                    .attr(attribs).add();\n\n                // events\n                if (events) {\n                    addEvent = function (eventType) {\n                        svgElem.on(eventType, function (e) {\n                            events[eventType].apply(plotLine, [e]);\n                        });\n                    };\n                    for (eventType in events) {\n                        addEvent(eventType);\n                    }\n                }\n            }\n\n            // the plot band/line label\n            if (optionsLabel && defined(optionsLabel.text) && path && path.length && \n                    axis.width > 0 && axis.height > 0 && !path.flat) {\n                // apply defaults\n                optionsLabel = merge({\n                    align: horiz && isBand && 'center',\n                    x: horiz ? !isBand && 4 : 10,\n                    verticalAlign: !horiz && isBand && 'middle',\n                    y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,\n                    rotation: horiz && !isBand && 90\n                }, optionsLabel);\n\n                this.renderLabel(optionsLabel, path, isBand, zIndex);\n\n            } else if (label) { // move out of sight\n                label.hide();\n            }\n\n            // chainable\n            return plotLine;\n        },\n\n        /**\n         * Render and align label for plot line or band.\n         */\n        renderLabel: function (optionsLabel, path, isBand, zIndex) {\n            var plotLine = this,\n                label = plotLine.label,\n                renderer = plotLine.axis.chart.renderer,\n                attribs,\n                xs,\n                ys,\n                x,\n                y;\n\n            // add the SVG element\n            if (!label) {\n                attribs = {\n                    align: optionsLabel.textAlign || optionsLabel.align,\n                    rotation: optionsLabel.rotation\n                };\n            \n                attribs.zIndex = zIndex;\n            \n                plotLine.label = label = renderer.text(\n                        optionsLabel.text,\n                        0,\n                        0,\n                        optionsLabel.useHTML\n                    )\n                    .attr(attribs)\n                    .css(optionsLabel.style)\n                    .add();\n            }\n\n            // get the bounding box and align the label\n            // #3000 changed to better handle choice between plotband or plotline\n            xs = [path[1], path[4], (isBand ? path[6] : path[1])];\n            ys = [path[2], path[5], (isBand ? path[7] : path[2])];\n            x = arrayMin(xs);\n            y = arrayMin(ys);\n\n            label.align(optionsLabel, false, {\n                x: x,\n                y: y,\n                width: arrayMax(xs) - x,\n                height: arrayMax(ys) - y\n            });\n            label.show();\n        },\n\n        /**\n         * Remove the plot line or band\n         */\n        destroy: function () {\n            // remove it from the lookup\n            erase(this.axis.plotLinesAndBands, this);\n\n            delete this.axis;\n            destroyObjectProperties(this);\n        }\n    };\n\n    /**\n     * Object with members for extending the Axis prototype\n     */\n\n    AxisPlotLineOrBandExtension = {\n\n        /**\n         * Create the path for a plot band\n         */\n        getPlotBandPath: function (from, to) {\n            var toPath = this.getPlotLinePath(to, null, null, true),\n                path = this.getPlotLinePath(from, null, null, true);\n\n            if (path && toPath) {\n\n                // Flat paths don't need labels (#3836)\n                path.flat = path.toString() === toPath.toString();\n\n                path.push(\n                    toPath[4],\n                    toPath[5],\n                    toPath[1],\n                    toPath[2]\n                );\n            } else { // outside the axis area\n                path = null;\n            }\n\n            return path;\n        },\n\n        addPlotBand: function (options) {\n            return this.addPlotBandOrLine(options, 'plotBands');\n        },\n\n        addPlotLine: function (options) {\n            return this.addPlotBandOrLine(options, 'plotLines');\n        },\n\n        /**\n         * Add a plot band or plot line after render time\n         *\n         * @param options {Object} The plotBand or plotLine configuration object\n         */\n        addPlotBandOrLine: function (options, coll) {\n            var obj = new Highcharts.PlotLineOrBand(this, options).render(),\n                userOptions = this.userOptions;\n\n            if (obj) { // #2189\n                // Add it to the user options for exporting and Axis.update\n                if (coll) {\n                    userOptions[coll] = userOptions[coll] || [];\n                    userOptions[coll].push(options);\n                }\n                this.plotLinesAndBands.push(obj);\n            }\n\n            return obj;\n        },\n\n        /**\n         * Remove a plot band or plot line from the chart by id\n         * @param {Object} id\n         */\n        removePlotBandOrLine: function (id) {\n            var plotLinesAndBands = this.plotLinesAndBands,\n                options = this.options,\n                userOptions = this.userOptions,\n                i = plotLinesAndBands.length;\n            while (i--) {\n                if (plotLinesAndBands[i].id === id) {\n                    plotLinesAndBands[i].destroy();\n                }\n            }\n            each([options.plotLines || [], userOptions.plotLines || [], options.plotBands || [], userOptions.plotBands || []], function (arr) {\n                i = arr.length;\n                while (i--) {\n                    if (arr[i].id === id) {\n                        erase(arr, arr[i]);\n                    }\n                }\n            });\n        }\n    };\n\n    /**\n     * Create a new axis object\n     * @param {Object} chart\n     * @param {Object} options\n     */\n    var Axis = Highcharts.Axis = function () {\n        this.init.apply(this, arguments);\n    };\n\n    Axis.prototype = {\n\n        /**\n         * Default options for the X axis - the Y axis has extended defaults\n         */\n        defaultOptions: {\n            // allowDecimals: null,\n            // alternateGridColor: null,\n            // categories: [],\n            dateTimeLabelFormats: {\n                millisecond: '%H:%M:%S.%L',\n                second: '%H:%M:%S',\n                minute: '%H:%M',\n                hour: '%H:%M',\n                day: '%e. %b',\n                week: '%e. %b',\n                month: '%b \\'%y',\n                year: '%Y'\n            },\n            endOnTick: false,\n            gridLineColor: '#D8D8D8',\n            // gridLineDashStyle: 'solid',\n            // gridLineWidth: 0,\n            // reversed: false,\n\n            labels: {\n                enabled: true,\n                // rotation: 0,\n                // align: 'center',\n                // step: null,\n                style: {\n                    color: '#606060',\n                    cursor: 'default',\n                    fontSize: '11px'\n                },\n                x: 0\n                //y: undefined\n                /*formatter: function () {\n                    return this.value;\n                },*/\n            },\n            lineColor: '#C0D0E0',\n            lineWidth: 1,\n            //linkedTo: null,\n            //max: undefined,\n            //min: undefined,\n            minPadding: 0.01,\n            maxPadding: 0.01,\n            //minRange: null,\n            minorGridLineColor: '#E0E0E0',\n            // minorGridLineDashStyle: null,\n            minorGridLineWidth: 1,\n            minorTickColor: '#A0A0A0',\n            //minorTickInterval: null,\n            minorTickLength: 2,\n            minorTickPosition: 'outside', // inside or outside\n            //minorTickWidth: 0,\n            //opposite: false,\n            //offset: 0,\n            //plotBands: [{\n            //    events: {},\n            //    zIndex: 1,\n            //    labels: { align, x, verticalAlign, y, style, rotation, textAlign }\n            //}],\n            //plotLines: [{\n            //    events: {}\n            //  dashStyle: {}\n            //    zIndex:\n            //    labels: { align, x, verticalAlign, y, style, rotation, textAlign }\n            //}],\n            //reversed: false,\n            // showFirstLabel: true,\n            // showLastLabel: true,\n            startOfWeek: 1,\n            startOnTick: false,\n            tickColor: '#C0D0E0',\n            //tickInterval: null,\n            tickLength: 10,\n            tickmarkPlacement: 'between', // on or between\n            tickPixelInterval: 100,\n            tickPosition: 'outside',\n            //tickWidth: 1,\n            title: {\n                //text: null,\n                align: 'middle', // low, middle or high\n                //margin: 0 for horizontal, 10 for vertical axes,\n                //rotation: 0,\n                //side: 'outside',\n                style: {\n                    color: '#707070'\n                }\n                //x: 0,\n                //y: 0\n            },\n            type: 'linear' // linear, logarithmic or datetime\n            //visible: true\n        },\n\n        /**\n         * This options set extends the defaultOptions for Y axes\n         */\n        defaultYAxisOptions: {\n            endOnTick: true,\n            gridLineWidth: 1,\n            tickPixelInterval: 72,\n            showLastLabel: true,\n            labels: {\n                x: -8\n            },\n            lineWidth: 0,\n            maxPadding: 0.05,\n            minPadding: 0.05,\n            startOnTick: true,\n            //tickWidth: 0,\n            title: {\n                rotation: 270,\n                text: 'Values'\n            },\n            stackLabels: {\n                enabled: false,\n                //align: dynamic,\n                //y: dynamic,\n                //x: dynamic,\n                //verticalAlign: dynamic,\n                //textAlign: dynamic,\n                //rotation: 0,\n                formatter: function () {\n                    return Highcharts.numberFormat(this.total, -1);\n                },\n                style: merge(defaultPlotOptions.line.dataLabels.style, { color: '#000000' })\n            }\n        },\n\n        /**\n         * These options extend the defaultOptions for left axes\n         */\n        defaultLeftAxisOptions: {\n            labels: {\n                x: -15\n            },\n            title: {\n                rotation: 270\n            }\n        },\n\n        /**\n         * These options extend the defaultOptions for right axes\n         */\n        defaultRightAxisOptions: {\n            labels: {\n                x: 15\n            },\n            title: {\n                rotation: 90\n            }\n        },\n\n        /**\n         * These options extend the defaultOptions for bottom axes\n         */\n        defaultBottomAxisOptions: {\n            labels: {\n                autoRotation: [-45],\n                x: 0\n                // overflow: undefined,\n                // staggerLines: null\n            },\n            title: {\n                rotation: 0\n            }\n        },\n        /**\n         * These options extend the defaultOptions for top axes\n         */\n        defaultTopAxisOptions: {\n            labels: {\n                autoRotation: [-45],\n                x: 0\n                // overflow: undefined\n                // staggerLines: null\n            },\n            title: {\n                rotation: 0\n            }\n        },\n\n        /**\n         * Initialize the axis\n         */\n        init: function (chart, userOptions) {\n\n\n            var isXAxis = userOptions.isX,\n                axis = this;\n\n            axis.chart = chart;\n\n            // Flag, is the axis horizontal\n            axis.horiz = chart.inverted ? !isXAxis : isXAxis;\n\n            // Flag, isXAxis\n            axis.isXAxis = isXAxis;\n            axis.coll = axis.coll || (isXAxis ? 'xAxis' : 'yAxis');\n\n            axis.opposite = userOptions.opposite; // needed in setOptions\n            axis.side = userOptions.side || (axis.horiz ?\n                    (axis.opposite ? 0 : 2) : // top : bottom\n                    (axis.opposite ? 1 : 3));  // right : left\n\n            axis.setOptions(userOptions);\n\n\n            var options = this.options,\n                type = options.type,\n                isDatetimeAxis = type === 'datetime';\n\n            axis.labelFormatter = options.labels.formatter || axis.defaultLabelFormatter; // can be overwritten by dynamic format\n\n\n            // Flag, stagger lines or not\n            axis.userOptions = userOptions;\n\n            //axis.axisTitleMargin = UNDEFINED,// = options.title.margin,\n            axis.minPixelPadding = 0;\n\n            axis.reversed = options.reversed;\n            axis.visible = options.visible !== false;\n            axis.zoomEnabled = options.zoomEnabled !== false;\n\n            // Initial categories\n            axis.hasNames = type === 'category' || options.categories === true;\n            axis.categories = options.categories || axis.hasNames;\n            axis.names = axis.names || []; // Preserve on update (#3830)\n\n            // Elements\n            //axis.axisGroup = UNDEFINED;\n            //axis.gridGroup = UNDEFINED;\n            //axis.axisTitle = UNDEFINED;\n            //axis.axisLine = UNDEFINED;\n\n            // Shorthand types\n            axis.isLog = type === 'logarithmic';\n            axis.isDatetimeAxis = isDatetimeAxis;\n\n            // Flag, if axis is linked to another axis\n            axis.isLinked = defined(options.linkedTo);\n            // Linked axis.\n            //axis.linkedParent = UNDEFINED;\n\n            // Tick positions\n            //axis.tickPositions = UNDEFINED; // array containing predefined positions\n            // Tick intervals\n            //axis.tickInterval = UNDEFINED;\n            //axis.minorTickInterval = UNDEFINED;\n\n\n            // Major ticks\n            axis.ticks = {};\n            axis.labelEdge = [];\n            // Minor ticks\n            axis.minorTicks = {};\n\n            // List of plotLines/Bands\n            axis.plotLinesAndBands = [];\n\n            // Alternate bands\n            axis.alternateBands = {};\n\n            // Axis metrics\n            //axis.left = UNDEFINED;\n            //axis.top = UNDEFINED;\n            //axis.width = UNDEFINED;\n            //axis.height = UNDEFINED;\n            //axis.bottom = UNDEFINED;\n            //axis.right = UNDEFINED;\n            //axis.transA = UNDEFINED;\n            //axis.transB = UNDEFINED;\n            //axis.oldTransA = UNDEFINED;\n            axis.len = 0;\n            //axis.oldMin = UNDEFINED;\n            //axis.oldMax = UNDEFINED;\n            //axis.oldUserMin = UNDEFINED;\n            //axis.oldUserMax = UNDEFINED;\n            //axis.oldAxisLength = UNDEFINED;\n            axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;\n            axis.range = options.range;\n            axis.offset = options.offset || 0;\n\n\n            // Dictionary for stacks\n            axis.stacks = {};\n            axis.oldStacks = {};\n            axis.stacksTouched = 0;\n\n            // Min and max in the data\n            //axis.dataMin = UNDEFINED,\n            //axis.dataMax = UNDEFINED,\n\n            // The axis range\n            axis.max = null;\n            axis.min = null;\n\n            // User set min and max\n            //axis.userMin = UNDEFINED,\n            //axis.userMax = UNDEFINED,\n\n            // Crosshair options\n            axis.crosshair = pick(options.crosshair, splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1], false);\n            // Run Axis\n\n            var eventType,\n                events = axis.options.events;\n\n            // Register\n            if (inArray(axis, chart.axes) === -1) { // don't add it again on Axis.update()\n                if (isXAxis) { // #2713\n                    chart.axes.splice(chart.xAxis.length, 0, axis);\n                } else {\n                    chart.axes.push(axis);\n                }\n\n                chart[axis.coll].push(axis);\n            }\n\n            axis.series = axis.series || []; // populated by Series\n\n            // inverted charts have reversed xAxes as default\n            if (chart.inverted && isXAxis && axis.reversed === UNDEFINED) {\n                axis.reversed = true;\n            }\n\n            axis.removePlotBand = axis.removePlotBandOrLine;\n            axis.removePlotLine = axis.removePlotBandOrLine;\n\n\n            // register event listeners\n            for (eventType in events) {\n                addEvent(axis, eventType, events[eventType]);\n            }\n\n            // extend logarithmic axis\n            if (axis.isLog) {\n                axis.val2lin = axis.log2lin;\n                axis.lin2val = axis.lin2log;\n            }\n        },\n\n        /**\n         * Merge and set options\n         */\n        setOptions: function (userOptions) {\n            this.options = merge(\n                this.defaultOptions,\n                this.coll === 'yAxis' && this.defaultYAxisOptions,\n                [this.defaultTopAxisOptions, this.defaultRightAxisOptions,\n                    this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side],\n                merge(\n                    defaultOptions[this.coll], // if set in setOptions (#1053)\n                    userOptions\n                )\n            );\n        },\n\n        /**\n         * The default label formatter. The context is a special config object for the label.\n         */\n        defaultLabelFormatter: function () {\n            var axis = this.axis,\n                value = this.value,\n                categories = axis.categories,\n                dateTimeLabelFormat = this.dateTimeLabelFormat,\n                numericSymbols = defaultOptions.lang.numericSymbols,\n                i = numericSymbols && numericSymbols.length,\n                multi,\n                ret,\n                formatOption = axis.options.labels.format,\n\n                // make sure the same symbol is added for all labels on a linear axis\n                numericSymbolDetector = axis.isLog ? value : axis.tickInterval;\n\n            if (formatOption) {\n                ret = format(formatOption, this);\n\n            } else if (categories) {\n                ret = value;\n\n            } else if (dateTimeLabelFormat) { // datetime axis\n                ret = dateFormat(dateTimeLabelFormat, value);\n\n            } else if (i && numericSymbolDetector >= 1000) {\n                // Decide whether we should add a numeric symbol like k (thousands) or M (millions).\n                // If we are to enable this in tooltip or other places as well, we can move this\n                // logic to the numberFormatter and enable it by a parameter.\n                while (i-- && ret === UNDEFINED) {\n                    multi = Math.pow(1000, i + 1);\n                    if (numericSymbolDetector >= multi && (value * 10) % multi === 0 && numericSymbols[i] !== null && value !== 0) { // #5480\n                        ret = Highcharts.numberFormat(value / multi, -1) + numericSymbols[i];\n                    }\n                }\n            }\n\n            if (ret === UNDEFINED) {\n                if (mathAbs(value) >= 10000) { // add thousands separators\n                    ret = Highcharts.numberFormat(value, -1);\n\n                } else { // small numbers\n                    ret = Highcharts.numberFormat(value, -1, UNDEFINED, ''); // #2466\n                }\n            }\n\n            return ret;\n        },\n\n        /**\n         * Get the minimum and maximum for the series of each axis\n         */\n        getSeriesExtremes: function () {\n            var axis = this,\n                chart = axis.chart;\n\n            axis.hasVisibleSeries = false;\n\n            // Reset properties in case we're redrawing (#3353)\n            axis.dataMin = axis.dataMax = axis.threshold = null;\n            axis.softThreshold = !axis.isXAxis;\n\n            if (axis.buildStacks) {\n                axis.buildStacks();\n            }\n\n            // loop through this axis' series\n            each(axis.series, function (series) {\n\n                if (series.visible || !chart.options.chart.ignoreHiddenSeries) {\n\n                    var seriesOptions = series.options,\n                        xData,\n                        threshold = seriesOptions.threshold,\n                        seriesDataMin,\n                        seriesDataMax;\n\n                    axis.hasVisibleSeries = true;\n\n                    // Validate threshold in logarithmic axes\n                    if (axis.isLog && threshold <= 0) {\n                        threshold = null;\n                    }\n\n                    // Get dataMin and dataMax for X axes\n                    if (axis.isXAxis) {\n                        xData = series.xData;\n                        if (xData.length) {\n                            // If xData contains values which is not numbers, then filter them out.\n                            // To prevent performance hit, we only do this after we have already\n                            // found seriesDataMin because in most cases all data is valid. #5234.\n                            seriesDataMin = arrayMin(xData);\n                            if (!isNumber(seriesDataMin) && !(seriesDataMin instanceof Date)) { // Date for #5010\n                                xData = grep(xData, function (x) {\n                                    return isNumber(x);\n                                });\n                                seriesDataMin = arrayMin(xData); // Do it again with valid data\n                            }\n\n                            axis.dataMin = mathMin(pick(axis.dataMin, xData[0]), seriesDataMin);\n                            axis.dataMax = mathMax(pick(axis.dataMax, xData[0]), arrayMax(xData));\n                        \n                        }\n\n                    // Get dataMin and dataMax for Y axes, as well as handle stacking and processed data\n                    } else {\n\n                        // Get this particular series extremes\n                        series.getExtremes();\n                        seriesDataMax = series.dataMax;\n                        seriesDataMin = series.dataMin;\n\n                        // Get the dataMin and dataMax so far. If percentage is used, the min and max are\n                        // always 0 and 100. If seriesDataMin and seriesDataMax is null, then series\n                        // doesn't have active y data, we continue with nulls\n                        if (defined(seriesDataMin) && defined(seriesDataMax)) {\n                            axis.dataMin = mathMin(pick(axis.dataMin, seriesDataMin), seriesDataMin);\n                            axis.dataMax = mathMax(pick(axis.dataMax, seriesDataMax), seriesDataMax);\n                        }\n\n                        // Adjust to threshold\n                        if (defined(threshold)) {\n                            axis.threshold = threshold;\n                        }\n                        // If any series has a hard threshold, it takes precedence\n                        if (!seriesOptions.softThreshold || axis.isLog) {\n                            axis.softThreshold = false;\n                        }\n                    }\n                }\n            });\n        },\n\n        /**\n         * Translate from axis value to pixel position on the chart, or back\n         *\n         */\n        translate: function (val, backwards, cvsCoord, old, handleLog, pointPlacement) {\n            var axis = this.linkedParent || this, // #1417\n                sign = 1,\n                cvsOffset = 0,\n                localA = old ? axis.oldTransA : axis.transA,\n                localMin = old ? axis.oldMin : axis.min,\n                returnValue,\n                minPixelPadding = axis.minPixelPadding,\n                doPostTranslate = (axis.isOrdinal || axis.isBroken || (axis.isLog && handleLog)) && axis.lin2val;\n\n            if (!localA) {\n                localA = axis.transA;\n            }\n\n            // In vertical axes, the canvas coordinates start from 0 at the top like in\n            // SVG.\n            if (cvsCoord) {\n                sign *= -1; // canvas coordinates inverts the value\n                cvsOffset = axis.len;\n            }\n\n            // Handle reversed axis\n            if (axis.reversed) {\n                sign *= -1;\n                cvsOffset -= sign * (axis.sector || axis.len);\n            }\n\n            // From pixels to value\n            if (backwards) { // reverse translation\n\n                val = val * sign + cvsOffset;\n                val -= minPixelPadding;\n                returnValue = val / localA + localMin; // from chart pixel to value\n                if (doPostTranslate) { // log and ordinal axes\n                    returnValue = axis.lin2val(returnValue);\n                }\n\n            // From value to pixels\n            } else {\n                if (doPostTranslate) { // log and ordinal axes\n                    val = axis.val2lin(val);\n                }\n                if (pointPlacement === 'between') {\n                    pointPlacement = 0.5;\n                }\n                returnValue = sign * (val - localMin) * localA + cvsOffset + (sign * minPixelPadding) +\n                    (isNumber(pointPlacement) ? localA * pointPlacement * axis.pointRange : 0);\n            }\n\n            return returnValue;\n        },\n\n        /**\n         * Utility method to translate an axis value to pixel position.\n         * @param {Number} value A value in terms of axis units\n         * @param {Boolean} paneCoordinates Whether to return the pixel coordinate relative to the chart\n         *        or just the axis/pane itself.\n         */\n        toPixels: function (value, paneCoordinates) {\n            return this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);\n        },\n\n        /*\n         * Utility method to translate a pixel position in to an axis value\n         * @param {Number} pixel The pixel value coordinate\n         * @param {Boolean} paneCoordiantes Whether the input pixel is relative to the chart or just the\n         *        axis/pane itself.\n         */\n        toValue: function (pixel, paneCoordinates) {\n            return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);\n        },\n\n        /**\n         * Create the path for a plot line that goes from the given value on\n         * this axis, across the plot to the opposite side\n         * @param {Number} value\n         * @param {Number} lineWidth Used for calculation crisp line\n         * @param {Number] old Use old coordinates (for resizing and rescaling)\n         */\n        getPlotLinePath: function (value, lineWidth, old, force, translatedValue) {\n            var axis = this,\n                chart = axis.chart,\n                axisLeft = axis.left,\n                axisTop = axis.top,\n                x1,\n                y1,\n                x2,\n                y2,\n                cHeight = (old && chart.oldChartHeight) || chart.chartHeight,\n                cWidth = (old && chart.oldChartWidth) || chart.chartWidth,\n                skip,\n                transB = axis.transB,\n                /**\n                 * Check if x is between a and b. If not, either move to a/b or skip,\n                 * depending on the force parameter.\n                 */\n                between = function (x, a, b) {\n                    if (x < a || x > b) {\n                        if (force) {\n                            x = mathMin(mathMax(a, x), b);\n                        } else {\n                            skip = true;\n                        }\n                    }\n                    return x;\n                };\n\n            translatedValue = pick(translatedValue, axis.translate(value, null, null, old));\n            x1 = x2 = mathRound(translatedValue + transB);\n            y1 = y2 = mathRound(cHeight - translatedValue - transB);\n            if (!isNumber(translatedValue)) { // no min or max\n                skip = true;\n\n            } else if (axis.horiz) {\n                y1 = axisTop;\n                y2 = cHeight - axis.bottom;\n                x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);\n            } else {\n                x1 = axisLeft;\n                x2 = cWidth - axis.right;\n                y1 = y2 = between(y1, axisTop, axisTop + axis.height);\n            }\n            return skip && !force ?\n                null :\n                chart.renderer.crispLine([M, x1, y1, L, x2, y2], lineWidth || 1);\n        },\n\n        /**\n         * Set the tick positions of a linear axis to round values like whole tens or every five.\n         */\n        getLinearTickPositions: function (tickInterval, min, max) {\n            var pos,\n                lastPos,\n                roundedMin = correctFloat(mathFloor(min / tickInterval) * tickInterval),\n                roundedMax = correctFloat(mathCeil(max / tickInterval) * tickInterval),\n                tickPositions = [];\n\n            // For single points, add a tick regardless of the relative position (#2662)\n            if (min === max && isNumber(min)) {\n                return [min];\n            }\n\n            // Populate the intermediate values\n            pos = roundedMin;\n            while (pos <= roundedMax) {\n\n                // Place the tick on the rounded value\n                tickPositions.push(pos);\n\n                // Always add the raw tickInterval, not the corrected one.\n                pos = correctFloat(pos + tickInterval);\n\n                // If the interval is not big enough in the current min - max range to actually increase\n                // the loop variable, we need to break out to prevent endless loop. Issue #619\n                if (pos === lastPos) {\n                    break;\n                }\n\n                // Record the last value\n                lastPos = pos;\n            }\n            return tickPositions;\n        },\n\n        /**\n         * Return the minor tick positions. For logarithmic axes, reuse the same logic\n         * as for major ticks.\n         */\n        getMinorTickPositions: function () {\n            var axis = this,\n                options = axis.options,\n                tickPositions = axis.tickPositions,\n                minorTickInterval = axis.minorTickInterval,\n                minorTickPositions = [],\n                pos,\n                i,\n                pointRangePadding = axis.pointRangePadding || 0,\n                min = axis.min - pointRangePadding, // #1498\n                max = axis.max + pointRangePadding, // #1498\n                range = max - min,\n                len;\n\n            // If minor ticks get too dense, they are hard to read, and may cause long running script. So we don't draw them.\n            if (range && range / minorTickInterval < axis.len / 3) { // #3875\n\n                if (axis.isLog) {\n                    len = tickPositions.length;\n                    for (i = 1; i < len; i++) {\n                        minorTickPositions = minorTickPositions.concat(\n                            axis.getLogTickPositions(minorTickInterval, tickPositions[i - 1], tickPositions[i], true)\n                        );\n                    }\n                } else if (axis.isDatetimeAxis && options.minorTickInterval === 'auto') { // #1314\n                    minorTickPositions = minorTickPositions.concat(\n                        axis.getTimeTicks(\n                            axis.normalizeTimeTickInterval(minorTickInterval),\n                            min,\n                            max,\n                            options.startOfWeek\n                        )\n                    );\n                } else {\n                    for (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {\n                        minorTickPositions.push(pos);\n                    }\n                }\n            }\n\n            if (minorTickPositions.length !== 0) { // don't change the extremes, when there is no minor ticks\n                axis.trimTicks(minorTickPositions, options.startOnTick, options.endOnTick); // #3652 #3743 #1498\n            }\n            return minorTickPositions;\n        },\n\n        /**\n         * Adjust the min and max for the minimum range. Keep in mind that the series data is\n         * not yet processed, so we don't have information on data cropping and grouping, or\n         * updated axis.pointRange or series.pointRange. The data can't be processed until\n         * we have finally established min and max.\n         */\n        adjustForMinRange: function () {\n            var axis = this,\n                options = axis.options,\n                min = axis.min,\n                max = axis.max,\n                zoomOffset,\n                spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange,\n                closestDataRange,\n                i,\n                distance,\n                xData,\n                loopLength,\n                minArgs,\n                maxArgs,\n                minRange;\n\n            // Set the automatic minimum range based on the closest point distance\n            if (axis.isXAxis && axis.minRange === UNDEFINED && !axis.isLog) {\n\n                if (defined(options.min) || defined(options.max)) {\n                    axis.minRange = null; // don't do this again\n\n                } else {\n\n                    // Find the closest distance between raw data points, as opposed to\n                    // closestPointRange that applies to processed points (cropped and grouped)\n                    each(axis.series, function (series) {\n                        xData = series.xData;\n                        loopLength = series.xIncrement ? 1 : xData.length - 1;\n                        for (i = loopLength; i > 0; i--) {\n                            distance = xData[i] - xData[i - 1];\n                            if (closestDataRange === UNDEFINED || distance < closestDataRange) {\n                                closestDataRange = distance;\n                            }\n                        }\n                    });\n                    axis.minRange = mathMin(closestDataRange * 5, axis.dataMax - axis.dataMin);\n                }\n            }\n\n            // if minRange is exceeded, adjust\n            if (max - min < axis.minRange) {\n                minRange = axis.minRange;\n                zoomOffset = (minRange - max + min) / 2;\n\n                // if min and max options have been set, don't go beyond it\n                minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];\n                if (spaceAvailable) { // if space is available, stay within the data range\n                    minArgs[2] = axis.isLog ? axis.log2lin(axis.dataMin) : axis.dataMin;\n                }\n                min = arrayMax(minArgs);\n\n                maxArgs = [min + minRange, pick(options.max, min + minRange)];\n                if (spaceAvailable) { // if space is availabe, stay within the data range\n                    maxArgs[2] = axis.isLog ? axis.log2lin(axis.dataMax) : axis.dataMax;\n                }\n\n                max = arrayMin(maxArgs);\n\n                // now if the max is adjusted, adjust the min back\n                if (max - min < minRange) {\n                    minArgs[0] = max - minRange;\n                    minArgs[1] = pick(options.min, max - minRange);\n                    min = arrayMax(minArgs);\n                }\n            }\n\n            // Record modified extremes\n            axis.min = min;\n            axis.max = max;\n        },\n\n        /**\n         * Find the closestPointRange across all series\n         */\n        getClosest: function () {\n            var ret;\n\n            if (this.categories) {\n                ret = 1;\n            } else {\n                each(this.series, function (series) {\n                    var seriesClosest = series.closestPointRange;\n                    if (!series.noSharedTooltip && defined(seriesClosest)) {\n                        ret = defined(ret) ?\n                            mathMin(ret, seriesClosest) :\n                            seriesClosest;\n                    }\n                });\n            }\n            return ret;\n        },\n\n        /**\n         * When a point name is given and no x, search for the name in the existing categories,\n         * or if categories aren't provided, search names or create a new category (#2522).\n         */\n        nameToX: function (point) {\n            var explicitCategories = isArray(this.categories),\n                names = explicitCategories ? this.categories : this.names,\n                nameX = point.options.x,\n                x;\n\n            point.series.requireSorting = false;\n\n            if (!defined(nameX)) {\n                nameX = this.options.nameToX === false ?\n                    point.series.autoIncrement() : \n                    inArray(point.name, names);\n            }\n            if (nameX === -1) { // The name is not found in currenct categories\n                if (!explicitCategories) {\n                    x = names.length;\n                }\n            } else {\n                x = nameX;\n            }\n\n            // Write the last point's name to the names array\n            this.names[x] = point.name;\n\n            return x;\n        },\n\n        /**\n         * When changes have been done to series data, update the axis.names.\n         */\n        updateNames: function () {\n            var axis = this;\n\n            if (this.names.length > 0) {\n                this.names.length = 0;\n                this.minRange = undefined;\n                each(this.series || [], function (series) {\n            \n                    // When adding a series, points are not yet generated\n                    if (!series.processedXData) {\n                        series.processData();\n                        series.generatePoints();\n                    }\n\n                    each(series.points, function (point, i) {\n                        var x;\n                        if (point.options && point.options.x === undefined) {\n                            x = axis.nameToX(point);\n                            if (x !== point.x) {\n                                point.x = x;\n                                series.xData[i] = x;\n                            }\n                        }\n                    });\n                });\n            }\n        },\n\n        /**\n         * Update translation information\n         */\n        setAxisTranslation: function (saveOld) {\n            var axis = this,\n                range = axis.max - axis.min,\n                pointRange = axis.axisPointRange || 0,\n                closestPointRange,\n                minPointOffset = 0,\n                pointRangePadding = 0,\n                linkedParent = axis.linkedParent,\n                ordinalCorrection,\n                hasCategories = !!axis.categories,\n                transA = axis.transA,\n                isXAxis = axis.isXAxis;\n\n            // Adjust translation for padding. Y axis with categories need to go through the same (#1784).\n            if (isXAxis || hasCategories || pointRange) {\n                if (linkedParent) {\n                    minPointOffset = linkedParent.minPointOffset;\n                    pointRangePadding = linkedParent.pointRangePadding;\n\n                } else {\n                \n                    // Get the closest points\n                    closestPointRange = axis.getClosest();\n\n                    each(axis.series, function (series) {\n                        var seriesPointRange = hasCategories ? \n                            1 : \n                            (isXAxis ? \n                                pick(series.options.pointRange, closestPointRange, 0) : \n                                (axis.axisPointRange || 0)), // #2806\n                            pointPlacement = series.options.pointPlacement;\n\n                        pointRange = mathMax(pointRange, seriesPointRange);\n\n                        if (!axis.single) {\n                            // minPointOffset is the value padding to the left of the axis in order to make\n                            // room for points with a pointRange, typically columns. When the pointPlacement option\n                            // is 'between' or 'on', this padding does not apply.\n                            minPointOffset = mathMax(\n                                minPointOffset,\n                                isString(pointPlacement) ? 0 : seriesPointRange / 2\n                            );\n\n                            // Determine the total padding needed to the length of the axis to make room for the\n                            // pointRange. If the series' pointPlacement is 'on', no padding is added.\n                            pointRangePadding = mathMax(\n                                pointRangePadding,\n                                pointPlacement === 'on' ? 0 : seriesPointRange\n                            );\n                        }\n                    });\n                }\n\n                // Record minPointOffset and pointRangePadding\n                ordinalCorrection = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1; // #988, #1853\n                axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;\n                axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;\n\n                // pointRange means the width reserved for each point, like in a column chart\n                axis.pointRange = mathMin(pointRange, range);\n\n                // closestPointRange means the closest distance between points. In columns\n                // it is mostly equal to pointRange, but in lines pointRange is 0 while closestPointRange\n                // is some other value\n                if (isXAxis) {\n                    axis.closestPointRange = closestPointRange;\n                }\n            }\n\n            // Secondary values\n            if (saveOld) {\n                axis.oldTransA = transA;\n            }\n            axis.translationSlope = axis.transA = transA = axis.len / ((range + pointRangePadding) || 1);\n            axis.transB = axis.horiz ? axis.left : axis.bottom; // translation addend\n            axis.minPixelPadding = transA * minPointOffset;\n        },\n\n        minFromRange: function () {\n            return this.max - this.range;\n        },\n\n        /**\n         * Set the tick positions to round values and optionally extend the extremes\n         * to the nearest tick\n         */\n        setTickInterval: function (secondPass) {\n            var axis = this,\n                chart = axis.chart,\n                options = axis.options,\n                isLog = axis.isLog,\n                log2lin = axis.log2lin,\n                isDatetimeAxis = axis.isDatetimeAxis,\n                isXAxis = axis.isXAxis,\n                isLinked = axis.isLinked,\n                maxPadding = options.maxPadding,\n                minPadding = options.minPadding,\n                length,\n                linkedParentExtremes,\n                tickIntervalOption = options.tickInterval,\n                minTickInterval,\n                tickPixelIntervalOption = options.tickPixelInterval,\n                categories = axis.categories,\n                threshold = axis.threshold,\n                softThreshold = axis.softThreshold,\n                thresholdMin,\n                thresholdMax,\n                hardMin,\n                hardMax;\n\n            if (!isDatetimeAxis && !categories && !isLinked) {\n                this.getTickAmount();\n            }\n\n            // Min or max set either by zooming/setExtremes or initial options\n            hardMin = pick(axis.userMin, options.min);\n            hardMax = pick(axis.userMax, options.max);\n\n            // Linked axis gets the extremes from the parent axis\n            if (isLinked) {\n                axis.linkedParent = chart[axis.coll][options.linkedTo];\n                linkedParentExtremes = axis.linkedParent.getExtremes();\n                axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);\n                axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);\n                if (options.type !== axis.linkedParent.options.type) {\n                    error(11, 1); // Can't link axes of different type\n                }\n\n            // Initial min and max from the extreme data values\n            } else {\n\n                // Adjust to hard threshold\n                if (!softThreshold && defined(threshold)) {\n                    if (axis.dataMin >= threshold) {\n                        thresholdMin = threshold;\n                        minPadding = 0;\n                    } else if (axis.dataMax <= threshold) {\n                        thresholdMax = threshold;\n                        maxPadding = 0;\n                    }\n                }\n\n                axis.min = pick(hardMin, thresholdMin, axis.dataMin);\n                axis.max = pick(hardMax, thresholdMax, axis.dataMax);\n\n            }\n\n            if (isLog) {\n                if (!secondPass && mathMin(axis.min, pick(axis.dataMin, axis.min)) <= 0) { // #978\n                    error(10, 1); // Can't plot negative values on log axis\n                }\n                // The correctFloat cures #934, float errors on full tens. But it\n                // was too aggressive for #4360 because of conversion back to lin,\n                // therefore use precision 15.\n                axis.min = correctFloat(log2lin(axis.min), 15);\n                axis.max = correctFloat(log2lin(axis.max), 15);\n            }\n\n            // handle zoomed range\n            if (axis.range && defined(axis.max)) {\n                axis.userMin = axis.min = hardMin = mathMax(axis.min, axis.minFromRange()); // #618\n                axis.userMax = hardMax = axis.max;\n\n                axis.range = null;  // don't use it when running setExtremes\n            }\n\n            // Hook for Highstock Scroller. Consider combining with beforePadding.\n            fireEvent(axis, 'foundExtremes');\n\n            // Hook for adjusting this.min and this.max. Used by bubble series.\n            if (axis.beforePadding) {\n                axis.beforePadding();\n            }\n\n            // adjust min and max for the minimum range\n            axis.adjustForMinRange();\n\n            // Pad the values to get clear of the chart's edges. To avoid tickInterval taking the padding\n            // into account, we do this after computing tick interval (#1337).\n            if (!categories && !axis.axisPointRange && !axis.usePercentage && !isLinked && defined(axis.min) && defined(axis.max)) {\n                length = axis.max - axis.min;\n                if (length) {\n                    if (!defined(hardMin) && minPadding) {\n                        axis.min -= length * minPadding;\n                    }\n                    if (!defined(hardMax)  && maxPadding) {\n                        axis.max += length * maxPadding;\n                    }\n                }\n            }\n\n            // Stay within floor and ceiling\n            if (isNumber(options.floor)) {\n                axis.min = mathMax(axis.min, options.floor);\n            }\n            if (isNumber(options.ceiling)) {\n                axis.max = mathMin(axis.max, options.ceiling);\n            }\n\n            // When the threshold is soft, adjust the extreme value only if\n            // the data extreme and the padded extreme land on either side of the threshold. For example,\n            // a series of [0, 1, 2, 3] would make the yAxis add a tick for -1 because of the\n            // default minPadding and startOnTick options. This is prevented by the softThreshold\n            // option.\n            if (softThreshold && defined(axis.dataMin)) {\n                threshold = threshold || 0;\n                if (!defined(hardMin) && axis.min < threshold && axis.dataMin >= threshold) {\n                    axis.min = threshold;\n                } else if (!defined(hardMax) && axis.max > threshold && axis.dataMax <= threshold) {\n                    axis.max = threshold;\n                }\n            }\n\n\n            // get tickInterval\n            if (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {\n                axis.tickInterval = 1;\n            } else if (isLinked && !tickIntervalOption &&\n                    tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {\n                axis.tickInterval = tickIntervalOption = axis.linkedParent.tickInterval;\n            } else {\n                axis.tickInterval = pick(\n                    tickIntervalOption,\n                    this.tickAmount ? ((axis.max - axis.min) / mathMax(this.tickAmount - 1, 1)) : undefined,\n                    categories ? // for categoried axis, 1 is default, for linear axis use tickPix\n                        1 :\n                        // don't let it be more than the data range\n                        (axis.max - axis.min) * tickPixelIntervalOption / mathMax(axis.len, tickPixelIntervalOption)\n                );\n            }\n\n            // Now we're finished detecting min and max, crop and group series data. This\n            // is in turn needed in order to find tick positions in ordinal axes.\n            if (isXAxis && !secondPass) {\n                each(axis.series, function (series) {\n                    series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);\n                });\n            }\n\n            // set the translation factor used in translate function\n            axis.setAxisTranslation(true);\n\n            // hook for ordinal axes and radial axes\n            if (axis.beforeSetTickPositions) {\n                axis.beforeSetTickPositions();\n            }\n\n            // hook for extensions, used in Highstock ordinal axes\n            if (axis.postProcessTickInterval) {\n                axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);\n            }\n\n            // In column-like charts, don't cramp in more ticks than there are points (#1943, #4184)\n            if (axis.pointRange && !tickIntervalOption) {\n                axis.tickInterval = mathMax(axis.pointRange, axis.tickInterval);\n            }\n\n            // Before normalizing the tick interval, handle minimum tick interval. This applies only if tickInterval is not defined.\n            minTickInterval = pick(options.minTickInterval, axis.isDatetimeAxis && axis.closestPointRange);\n            if (!tickIntervalOption && axis.tickInterval < minTickInterval) {\n                axis.tickInterval = minTickInterval;\n            }\n\n            // for linear axes, get magnitude and normalize the interval\n            if (!isDatetimeAxis && !isLog && !tickIntervalOption) {\n                axis.tickInterval = normalizeTickInterval(\n                    axis.tickInterval,\n                    null,\n                    getMagnitude(axis.tickInterval),\n                    // If the tick interval is between 0.5 and 5 and the axis max is in the order of\n                    // thousands, chances are we are dealing with years. Don't allow decimals. #3363.\n                    pick(options.allowDecimals, !(axis.tickInterval > 0.5 && axis.tickInterval < 5 && axis.max > 1000 && axis.max < 9999)),\n                    !!this.tickAmount\n                );\n            }\n\n            // Prevent ticks from getting so close that we can't draw the labels\n            if (!this.tickAmount) {\n                axis.tickInterval = axis.unsquish();\n            }\n\n            this.setTickPositions();\n        },\n\n        /**\n         * Now we have computed the normalized tickInterval, get the tick positions\n         */\n        setTickPositions: function () {\n\n            var options = this.options,\n                tickPositions,\n                tickPositionsOption = options.tickPositions,\n                tickPositioner = options.tickPositioner,\n                startOnTick = options.startOnTick,\n                endOnTick = options.endOnTick,\n                single;\n\n            // Set the tickmarkOffset\n            this.tickmarkOffset = (this.categories && options.tickmarkPlacement === 'between' &&\n                this.tickInterval === 1) ? 0.5 : 0; // #3202\n\n\n            // get minorTickInterval\n            this.minorTickInterval = options.minorTickInterval === 'auto' && this.tickInterval ?\n                this.tickInterval / 5 : options.minorTickInterval;\n\n            // Find the tick positions\n            this.tickPositions = tickPositions = tickPositionsOption && tickPositionsOption.slice(); // Work on a copy (#1565)\n            if (!tickPositions) {\n\n                if (this.isDatetimeAxis) {\n                    tickPositions = this.getTimeTicks(\n                        this.normalizeTimeTickInterval(this.tickInterval, options.units),\n                        this.min,\n                        this.max,\n                        options.startOfWeek,\n                        this.ordinalPositions,\n                        this.closestPointRange,\n                        true\n                    );\n                } else if (this.isLog) {\n                    tickPositions = this.getLogTickPositions(this.tickInterval, this.min, this.max);\n                } else {\n                    tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);\n                }\n\n                // Too dense ticks, keep only the first and last (#4477)\n                if (tickPositions.length > this.len) {\n                    tickPositions = [tickPositions[0], tickPositions.pop()];\n                }\n\n                this.tickPositions = tickPositions;\n\n                // Run the tick positioner callback, that allows modifying auto tick positions.\n                if (tickPositioner) {\n                    tickPositioner = tickPositioner.apply(this, [this.min, this.max]);\n                    if (tickPositioner) {\n                        this.tickPositions = tickPositions = tickPositioner;\n                    }\n                }\n\n            }\n\n            if (!this.isLinked) {\n\n                // reset min/max or remove extremes based on start/end on tick\n                this.trimTicks(tickPositions, startOnTick, endOnTick);\n\n                // When there is only one point, or all points have the same value on this axis, then min\n                // and max are equal and tickPositions.length is 0 or 1. In this case, add some padding\n                // in order to center the point, but leave it with one tick. #1337.\n                if (this.min === this.max && defined(this.min) && !this.tickAmount) {\n                    // Substract half a unit (#2619, #2846, #2515, #3390)\n                    single = true;\n                    this.min -= 0.5;\n                    this.max += 0.5;\n                }\n                this.single = single;\n\n                if (!tickPositionsOption && !tickPositioner) {\n                    this.adjustTickAmount();\n                }\n            }\n        },\n\n        /**\n         * Handle startOnTick and endOnTick by either adapting to padding min/max or rounded min/max\n         */\n        trimTicks: function (tickPositions, startOnTick, endOnTick) {\n            var roundedMin = tickPositions[0],\n                roundedMax = tickPositions[tickPositions.length - 1],\n                minPointOffset = this.minPointOffset || 0;\n\n            if (startOnTick) {\n                this.min = roundedMin;\n            } else {\n                while (this.min - minPointOffset > tickPositions[0]) {\n                    tickPositions.shift();\n                }\n            }\n\n            if (endOnTick) {\n                this.max = roundedMax;\n            } else {\n                while (this.max + minPointOffset < tickPositions[tickPositions.length - 1]) {\n                    tickPositions.pop();\n                }\n            }\n\n            // If no tick are left, set one tick in the middle (#3195)\n            if (tickPositions.length === 0 && defined(roundedMin)) {\n                tickPositions.push((roundedMax + roundedMin) / 2);\n            }\n        },\n\n        /**\n         * Check if there are multiple axes in the same pane\n         * @returns {Boolean} There are other axes\n         */\n        alignToOthers: function () {\n            var others = {}, // Whether there is another axis to pair with this one\n                hasOther,\n                options = this.options;\n\n            if (this.chart.options.chart.alignTicks !== false && options.alignTicks !== false) {\n                each(this.chart[this.coll], function (axis) {\n                    var otherOptions = axis.options,\n                        horiz = axis.horiz,\n                        key = [\n                            horiz ? otherOptions.left : otherOptions.top, \n                            otherOptions.width,\n                            otherOptions.height, \n                            otherOptions.pane\n                        ].join(',');\n\n\n                    if (axis.series.length) { // #4442\n                        if (others[key]) {\n                            hasOther = true; // #4201\n                        } else {\n                            others[key] = 1;\n                        }\n                    }\n                });\n            }\n            return hasOther;\n        },\n\n        /**\n         * Set the max ticks of either the x and y axis collection\n         */\n        getTickAmount: function () {\n            var options = this.options,\n                tickAmount = options.tickAmount,\n                tickPixelInterval = options.tickPixelInterval;\n\n            if (!defined(options.tickInterval) && this.len < tickPixelInterval && !this.isRadial &&\n                    !this.isLog && options.startOnTick && options.endOnTick) {\n                tickAmount = 2;\n            }\n\n            if (!tickAmount && this.alignToOthers()) {\n                // Add 1 because 4 tick intervals require 5 ticks (including first and last)\n                tickAmount = mathCeil(this.len / tickPixelInterval) + 1;\n            }\n\n            // For tick amounts of 2 and 3, compute five ticks and remove the intermediate ones. This\n            // prevents the axis from adding ticks that are too far away from the data extremes.\n            if (tickAmount < 4) {\n                this.finalTickAmt = tickAmount;\n                tickAmount = 5;\n            }\n\n            this.tickAmount = tickAmount;\n        },\n\n        /**\n         * When using multiple axes, adjust the number of ticks to match the highest\n         * number of ticks in that group\n         */\n        adjustTickAmount: function () {\n            var tickInterval = this.tickInterval,\n                tickPositions = this.tickPositions,\n                tickAmount = this.tickAmount,\n                finalTickAmt = this.finalTickAmt,\n                currentTickAmount = tickPositions && tickPositions.length,\n                i,\n                len;\n\n            if (currentTickAmount < tickAmount) {\n                while (tickPositions.length < tickAmount) {\n                    tickPositions.push(correctFloat(\n                        tickPositions[tickPositions.length - 1] + tickInterval\n                    ));\n                }\n                this.transA *= (currentTickAmount - 1) / (tickAmount - 1);\n                this.max = tickPositions[tickPositions.length - 1];\n\n            // We have too many ticks, run second pass to try to reduce ticks\n            } else if (currentTickAmount > tickAmount) {\n                this.tickInterval *= 2;\n                this.setTickPositions();\n            }\n\n            // The finalTickAmt property is set in getTickAmount\n            if (defined(finalTickAmt)) {\n                i = len = tickPositions.length;\n                while (i--) {\n                    if (\n                        (finalTickAmt === 3 && i % 2 === 1) || // Remove every other tick\n                        (finalTickAmt <= 2 && i > 0 && i < len - 1) // Remove all but first and last\n                    ) {\n                        tickPositions.splice(i, 1);\n                    }\n                }\n                this.finalTickAmt = UNDEFINED;\n            }\n        },\n\n        /**\n         * Set the scale based on data min and max, user set min and max or options\n         *\n         */\n        setScale: function () {\n            var axis = this,\n                isDirtyData,\n                isDirtyAxisLength;\n\n            axis.oldMin = axis.min;\n            axis.oldMax = axis.max;\n            axis.oldAxisLength = axis.len;\n\n            // set the new axisLength\n            axis.setAxisSize();\n            //axisLength = horiz ? axisWidth : axisHeight;\n            isDirtyAxisLength = axis.len !== axis.oldAxisLength;\n\n            // is there new data?\n            each(axis.series, function (series) {\n                if (series.isDirtyData || series.isDirty ||\n                        series.xAxis.isDirty) { // when x axis is dirty, we need new data extremes for y as well\n                    isDirtyData = true;\n                }\n            });\n\n            // do we really need to go through all this?\n            if (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw ||\n                axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax || axis.alignToOthers()) {\n\n                if (axis.resetStacks) {\n                    axis.resetStacks();\n                }\n\n                axis.forceRedraw = false;\n\n                // get data extremes if needed\n                axis.getSeriesExtremes();\n\n                // get fixed positions based on tickInterval\n                axis.setTickInterval();\n\n                // record old values to decide whether a rescale is necessary later on (#540)\n                axis.oldUserMin = axis.userMin;\n                axis.oldUserMax = axis.userMax;\n\n                // Mark as dirty if it is not already set to dirty and extremes have changed. #595.\n                if (!axis.isDirty) {\n                    axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;\n                }\n            } else if (axis.cleanStacks) {\n                axis.cleanStacks();\n            }\n        },\n\n        /**\n         * Set the extremes and optionally redraw\n         * @param {Number} newMin\n         * @param {Number} newMax\n         * @param {Boolean} redraw\n         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n         *    configuration\n         * @param {Object} eventArguments\n         *\n         */\n        setExtremes: function (newMin, newMax, redraw, animation, eventArguments) {\n            var axis = this,\n                chart = axis.chart;\n\n            redraw = pick(redraw, true); // defaults to true\n\n            each(axis.series, function (serie) {\n                delete serie.kdTree;\n            });\n\n            // Extend the arguments with min and max\n            eventArguments = extend(eventArguments, {\n                min: newMin,\n                max: newMax\n            });\n\n            // Fire the event\n            fireEvent(axis, 'setExtremes', eventArguments, function () { // the default event handler\n\n                axis.userMin = newMin;\n                axis.userMax = newMax;\n                axis.eventArgs = eventArguments;\n\n                if (redraw) {\n                    chart.redraw(animation);\n                }\n            });\n        },\n\n        /**\n         * Overridable method for zooming chart. Pulled out in a separate method to allow overriding\n         * in stock charts.\n         */\n        zoom: function (newMin, newMax) {\n            var dataMin = this.dataMin,\n                dataMax = this.dataMax,\n                options = this.options,\n                min = mathMin(dataMin, pick(options.min, dataMin)),\n                max = mathMax(dataMax, pick(options.max, dataMax));\n\n            // Prevent pinch zooming out of range. Check for defined is for #1946. #1734.\n            if (!this.allowZoomOutside) {\n                if (defined(dataMin) && newMin <= min) {\n                    newMin = min;\n                }\n                if (defined(dataMax) && newMax >= max) {\n                    newMax = max;\n                }\n            }\n\n            // In full view, displaying the reset zoom button is not required\n            this.displayBtn = newMin !== UNDEFINED || newMax !== UNDEFINED;\n\n            // Do it\n            this.setExtremes(\n                newMin,\n                newMax,\n                false,\n                UNDEFINED,\n                { trigger: 'zoom' }\n            );\n            return true;\n        },\n\n        /**\n         * Update the axis metrics\n         */\n        setAxisSize: function () {\n            var chart = this.chart,\n                options = this.options,\n                offsetLeft = options.offsetLeft || 0,\n                offsetRight = options.offsetRight || 0,\n                horiz = this.horiz,\n                width = pick(options.width, chart.plotWidth - offsetLeft + offsetRight),\n                height = pick(options.height, chart.plotHeight),\n                top = pick(options.top, chart.plotTop),\n                left = pick(options.left, chart.plotLeft + offsetLeft),\n                percentRegex = /%$/;\n\n            // Check for percentage based input values. Rounding fixes problems with\n            // column overflow and plot line filtering (#4898, #4899)\n            if (percentRegex.test(height)) {\n                height = Math.round(parseFloat(height) / 100 * chart.plotHeight);\n            }\n            if (percentRegex.test(top)) {\n                top = Math.round(parseFloat(top) / 100 * chart.plotHeight + chart.plotTop);\n            }\n\n            // Expose basic values to use in Series object and navigator\n            this.left = left;\n            this.top = top;\n            this.width = width;\n            this.height = height;\n            this.bottom = chart.chartHeight - height - top;\n            this.right = chart.chartWidth - width - left;\n\n            // Direction agnostic properties\n            this.len = mathMax(horiz ? width : height, 0); // mathMax fixes #905\n            this.pos = horiz ? left : top; // distance from SVG origin\n        },\n\n        /**\n         * Get the actual axis extremes\n         */\n        getExtremes: function () {\n            var axis = this,\n                isLog = axis.isLog,\n                lin2log = axis.lin2log;\n\n            return {\n                min: isLog ? correctFloat(lin2log(axis.min)) : axis.min,\n                max: isLog ? correctFloat(lin2log(axis.max)) : axis.max,\n                dataMin: axis.dataMin,\n                dataMax: axis.dataMax,\n                userMin: axis.userMin,\n                userMax: axis.userMax\n            };\n        },\n\n        /**\n         * Get the zero plane either based on zero or on the min or max value.\n         * Used in bar and area plots\n         */\n        getThreshold: function (threshold) {\n            var axis = this,\n                isLog = axis.isLog,\n                lin2log = axis.lin2log,\n                realMin = isLog ? lin2log(axis.min) : axis.min,\n                realMax = isLog ? lin2log(axis.max) : axis.max;\n\n            if (threshold === null) {\n                threshold = realMin;\n            } else if (realMin > threshold) {\n                threshold = realMin;\n            } else if (realMax < threshold) {\n                threshold = realMax;\n            }\n\n            return axis.translate(threshold, 0, 1, 0, 1);\n        },\n\n        /**\n         * Compute auto alignment for the axis label based on which side the axis is on\n         * and the given rotation for the label\n         */\n        autoLabelAlign: function (rotation) {\n            var ret,\n                angle = (pick(rotation, 0) - (this.side * 90) + 720) % 360;\n\n            if (angle > 15 && angle < 165) {\n                ret = 'right';\n            } else if (angle > 195 && angle < 345) {\n                ret = 'left';\n            } else {\n                ret = 'center';\n            }\n            return ret;\n        },\n\n        /**\n         * Get the tick length and width for the axis.\n         * @param   {String} prefix 'tick' or 'minorTick'\n         * @returns {Array}        An array of tickLength and tickWidth\n         */\n        tickSize: function (prefix) {\n            var options = this.options,\n                tickLength = options[prefix + 'Length'],\n                tickWidth = pick(options[prefix + 'Width'], prefix === 'tick' && this.isXAxis ? 1 : 0); // X axis defaults to 1\n\n            if (tickWidth && tickLength) {\n                // Negate the length\n                if (options[prefix + 'Position'] === 'inside') {\n                    tickLength = -tickLength;\n                }\n                return [tickLength, tickWidth];\n            }\n            \n        },\n\n        /**\n         * Return the size of the labels\n         */\n        labelMetrics: function () {\n            return this.chart.renderer.fontMetrics(\n                this.options.labels.style.fontSize, \n                this.ticks[0] && this.ticks[0].label\n            );\n        },\n\n        /**\n         * Prevent the ticks from getting so close we can't draw the labels. On a horizontal\n         * axis, this is handled by rotating the labels, removing ticks and adding ellipsis.\n         * On a vertical axis remove ticks and add ellipsis.\n         */\n        unsquish: function () {\n            var labelOptions = this.options.labels,\n                horiz = this.horiz,\n                tickInterval = this.tickInterval,\n                newTickInterval = tickInterval,\n                slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval),\n                rotation,\n                rotationOption = labelOptions.rotation,\n                labelMetrics = this.labelMetrics(),\n                step,\n                bestScore = Number.MAX_VALUE,\n                autoRotation,\n                // Return the multiple of tickInterval that is needed to avoid collision\n                getStep = function (spaceNeeded) {\n                    var step = spaceNeeded / (slotSize || 1);\n                    step = step > 1 ? mathCeil(step) : 1;\n                    return step * tickInterval;\n                };\n\n            if (horiz) {\n                autoRotation = !labelOptions.staggerLines && !labelOptions.step && ( // #3971\n                    defined(rotationOption) ?\n                        [rotationOption] :\n                        slotSize < pick(labelOptions.autoRotationLimit, 80) && labelOptions.autoRotation\n                );\n\n                if (autoRotation) {\n\n                    // Loop over the given autoRotation options, and determine which gives the best score. The\n                    // best score is that with the lowest number of steps and a rotation closest to horizontal.\n                    each(autoRotation, function (rot) {\n                        var score;\n\n                        if (rot === rotationOption || (rot && rot >= -90 && rot <= 90)) { // #3891\n\n                            step = getStep(mathAbs(labelMetrics.h / mathSin(deg2rad * rot)));\n\n                            score = step + mathAbs(rot / 360);\n\n                            if (score < bestScore) {\n                                bestScore = score;\n                                rotation = rot;\n                                newTickInterval = step;\n                            }\n                        }\n                    });\n                }\n\n            } else if (!labelOptions.step) { // #4411\n                newTickInterval = getStep(labelMetrics.h);\n            }\n\n            this.autoRotation = autoRotation;\n            this.labelRotation = pick(rotation, rotationOption);\n\n            return newTickInterval;\n        },\n\n        /**\n         * Get the general slot width for this axis. This may change between the pre-render (from Axis.getOffset) \n         * and the final tick rendering and placement (#5086).\n         */\n        getSlotWidth: function () {\n            var chart = this.chart,\n                horiz = this.horiz,\n                labelOptions = this.options.labels,\n                slotCount = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n                marginLeft = chart.margin[3];\n\n            return (horiz && (labelOptions.step || 0) < 2 && !labelOptions.rotation && // #4415\n                ((this.staggerLines || 1) * chart.plotWidth) / slotCount) ||\n                (!horiz && ((marginLeft && (marginLeft - chart.spacing[3])) || chart.chartWidth * 0.33)); // #1580, #1931\n\n        },\n\n        /**\n         * Render the axis labels and determine whether ellipsis or rotation need to be applied\n         */\n        renderUnsquish: function () {\n            var chart = this.chart,\n                renderer = chart.renderer,\n                tickPositions = this.tickPositions,\n                ticks = this.ticks,\n                labelOptions = this.options.labels,\n                horiz = this.horiz,\n                slotWidth = this.getSlotWidth(),\n                innerWidth = mathMax(1, mathRound(slotWidth - 2 * (labelOptions.padding || 5))),\n                attr = {},\n                labelMetrics = this.labelMetrics(),\n                textOverflowOption = labelOptions.style.textOverflow,\n                css,\n                maxLabelLength = 0,\n                label,\n                i,\n                pos;\n\n            // Set rotation option unless it is \"auto\", like in gauges\n            if (!isString(labelOptions.rotation)) {\n                attr.rotation = labelOptions.rotation || 0; // #4443\n            }\n\n            // Get the longest label length\n            each(tickPositions, function (tick) {\n                tick = ticks[tick];\n                if (tick && tick.labelLength > maxLabelLength) {\n                    maxLabelLength = tick.labelLength;\n                }\n            });\n            this.maxLabelLength = maxLabelLength;\n        \n\n            // Handle auto rotation on horizontal axis\n            if (this.autoRotation) {\n\n                // Apply rotation only if the label is too wide for the slot, and\n                // the label is wider than its height.\n                if (maxLabelLength > innerWidth && maxLabelLength > labelMetrics.h) {\n                    attr.rotation = this.labelRotation;\n                } else {\n                    this.labelRotation = 0;\n                }\n\n            // Handle word-wrap or ellipsis on vertical axis\n            } else if (slotWidth) {\n                // For word-wrap or ellipsis\n                css = { width: innerWidth + PX };\n\n                if (!textOverflowOption) {\n                    css.textOverflow = 'clip';\n\n                    // On vertical axis, only allow word wrap if there is room for more lines.\n                    i = tickPositions.length;\n                    while (!horiz && i--) {\n                        pos = tickPositions[i];\n                        label = ticks[pos].label;\n                        if (label) {\n                            // Reset ellipsis in order to get the correct bounding box (#4070)\n                            if (label.styles.textOverflow === 'ellipsis') {\n                                label.css({ textOverflow: 'clip' });\n\n                            // Set the correct width in order to read the bounding box height (#4678, #5034)\n                            } else if (ticks[pos].labelLength > slotWidth) {\n                                label.css({ width: slotWidth + 'px' });\n                            }\n\n                            if (label.getBBox().height > this.len / tickPositions.length - (labelMetrics.h - labelMetrics.f)) {\n                                label.specCss = { textOverflow: 'ellipsis' };\n                            }\n                        }\n                    }\n                }\n            }\n\n\n            // Add ellipsis if the label length is significantly longer than ideal\n            if (attr.rotation) {\n                css = {\n                    width: (maxLabelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : chart.chartHeight) + PX\n                };\n                if (!textOverflowOption) {\n                    css.textOverflow = 'ellipsis';\n                }\n            }\n\n            // Set the explicit or automatic label alignment\n            this.labelAlign = labelOptions.align || this.autoLabelAlign(this.labelRotation);\n            if (this.labelAlign) {\n                attr.align = this.labelAlign;\n            }\n\n            // Apply general and specific CSS\n            each(tickPositions, function (pos) {\n                var tick = ticks[pos],\n                    label = tick && tick.label;\n                if (label) {\n                    label.attr(attr); // This needs to go before the CSS in old IE (#4502)\n                    if (css) {\n                        label.css(merge(css, label.specCss));\n                    }\n                    delete label.specCss;\n                    tick.rotation = attr.rotation;\n                }\n            });\n\n            // Note: Why is this not part of getLabelPosition?\n            this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side !== 0);\n        },\n\n        /**\n         * Return true if the axis has associated data\n         */\n        hasData: function () {\n            return this.hasVisibleSeries || (defined(this.min) && defined(this.max) && !!this.tickPositions);\n        },\n\n        /**\n         * Render the tick labels to a preliminary position to get their sizes\n         */\n        getOffset: function () {\n            var axis = this,\n                chart = axis.chart,\n                renderer = chart.renderer,\n                options = axis.options,\n                tickPositions = axis.tickPositions,\n                ticks = axis.ticks,\n                horiz = axis.horiz,\n                side = axis.side,\n                invertedSide = chart.inverted ? [1, 0, 3, 2][side] : side,\n                hasData,\n                showAxis,\n                titleOffset = 0,\n                titleOffsetOption,\n                titleMargin = 0,\n                axisTitleOptions = options.title,\n                labelOptions = options.labels,\n                labelOffset = 0, // reset\n                labelOffsetPadded,\n                opposite = axis.opposite,\n                axisOffset = chart.axisOffset,\n                clipOffset = chart.clipOffset,\n                clip,\n                directionFactor = [-1, 1, 1, -1][side],\n                n,\n                textAlign,\n                axisParent = axis.axisParent, // Used in color axis\n                lineHeightCorrection,\n                tickSize = this.tickSize('tick');\n\n            // For reuse in Axis.render\n            hasData = axis.hasData();\n            axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);\n\n            // Set/reset staggerLines\n            axis.staggerLines = axis.horiz && labelOptions.staggerLines;\n\n            // Create the axisGroup and gridGroup elements on first iteration\n            if (!axis.axisGroup) {\n                axis.gridGroup = renderer.g('grid')\n                    .attr({ zIndex: options.gridZIndex || 1 })\n                    .add(axisParent);\n                axis.axisGroup = renderer.g('axis')\n                    .attr({ zIndex: options.zIndex || 2 })\n                    .add(axisParent);\n                axis.labelGroup = renderer.g('axis-labels')\n                    .attr({ zIndex: labelOptions.zIndex || 7 })\n                    .addClass(PREFIX + axis.coll.toLowerCase() + '-labels')\n                    .add(axisParent);\n            }\n\n            if (hasData || axis.isLinked) {\n\n                // Generate ticks\n                each(tickPositions, function (pos) {\n                    if (!ticks[pos]) {\n                        ticks[pos] = new Tick(axis, pos);\n                    } else {\n                        ticks[pos].addLabel(); // update labels depending on tick interval\n                    }\n                });\n\n                axis.renderUnsquish();\n\n\n                // Left side must be align: right and right side must have align: left for labels\n                if (labelOptions.reserveSpace !== false && (side === 0 || side === 2 ||\n                        { 1: 'left', 3: 'right' }[side] === axis.labelAlign || axis.labelAlign === 'center')) {\n                    each(tickPositions, function (pos) {\n\n                        // get the highest offset\n                        labelOffset = mathMax(\n                            ticks[pos].getLabelSize(),\n                            labelOffset\n                        );\n                    });\n                }\n\n                if (axis.staggerLines) {\n                    labelOffset *= axis.staggerLines;\n                    axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1);\n                }\n\n\n            } else { // doesn't have data\n                for (n in ticks) {\n                    ticks[n].destroy();\n                    delete ticks[n];\n                }\n            }\n\n            if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {\n                if (!axis.axisTitle) {\n                    textAlign = axisTitleOptions.textAlign;\n                    if (!textAlign) {\n                        textAlign = (horiz ? { \n                            low: 'left',\n                            middle: 'center',\n                            high: 'right'\n                        } : { \n                            low: opposite ? 'right' : 'left',\n                            middle: 'center',\n                            high: opposite ? 'left' : 'right'\n                        })[axisTitleOptions.align];\n                    }\n                    axis.axisTitle = renderer.text(\n                        axisTitleOptions.text,\n                        0,\n                        0,\n                        axisTitleOptions.useHTML\n                    )\n                    .attr({\n                        zIndex: 7,\n                        rotation: axisTitleOptions.rotation || 0,\n                        align: textAlign\n                    })\n                    .addClass(PREFIX + this.coll.toLowerCase() + '-title')\n                    .css(axisTitleOptions.style)\n                    .add(axis.axisGroup);\n                    axis.axisTitle.isNew = true;\n                }\n\n                if (showAxis) {\n                    titleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];\n                    titleOffsetOption = axisTitleOptions.offset;\n                    titleMargin = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10);\n                }\n\n                // hide or show the title depending on whether showEmpty is set\n                axis.axisTitle[showAxis ? 'show' : 'hide'](true);\n            }\n\n            // handle automatic or user set offset\n            axis.offset = directionFactor * pick(options.offset, axisOffset[side]);\n\n            axis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 }; // polar\n            if (side === 0) {\n                lineHeightCorrection = -axis.labelMetrics().h;\n            } else if (side === 2) {\n                lineHeightCorrection = axis.tickRotCorr.y;\n            } else {\n                lineHeightCorrection = 0;\n            }\n\n            // Find the padded label offset\n            labelOffsetPadded = Math.abs(labelOffset) + titleMargin;\n            if (labelOffset) {\n                labelOffsetPadded -= lineHeightCorrection;\n                labelOffsetPadded += directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + directionFactor * 8) : labelOptions.x);\n            }\n            axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);\n\n            axisOffset[side] = mathMax(\n                axisOffset[side],\n                axis.axisTitleMargin + titleOffset + directionFactor * axis.offset,\n                labelOffsetPadded, // #3027\n                hasData && tickPositions.length && tickSize ? tickSize[0] : 0 // #4866\n            );\n\n            // Decide the clipping needed to keep the graph inside the plot area and axis lines\n            clip = options.offset ? 0 : mathFloor(options.lineWidth / 2) * 2; // #4308, #4371\n            clipOffset[invertedSide] = mathMax(clipOffset[invertedSide], clip);\n        },\n\n        /**\n         * Get the path for the axis line\n         */\n        getLinePath: function (lineWidth) {\n            var chart = this.chart,\n                opposite = this.opposite,\n                offset = this.offset,\n                horiz = this.horiz,\n                lineLeft = this.left + (opposite ? this.width : 0) + offset,\n                lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;\n\n            if (opposite) {\n                lineWidth *= -1; // crispify the other way - #1480, #1687\n            }\n\n            return chart.renderer\n                .crispLine([\n                    M,\n                    horiz ?\n                        this.left :\n                        lineLeft,\n                    horiz ?\n                        lineTop :\n                        this.top,\n                    L,\n                    horiz ?\n                        chart.chartWidth - this.right :\n                        lineLeft,\n                    horiz ?\n                        lineTop :\n                        chart.chartHeight - this.bottom\n                ], lineWidth);\n        },\n\n        /**\n         * Position the title\n         */\n        getTitlePosition: function () {\n            // compute anchor points for each of the title align options\n            var horiz = this.horiz,\n                axisLeft = this.left,\n                axisTop = this.top,\n                axisLength = this.len,\n                axisTitleOptions = this.options.title,\n                margin = horiz ? axisLeft : axisTop,\n                opposite = this.opposite,\n                offset = this.offset,\n                xOption = axisTitleOptions.x || 0,\n                yOption = axisTitleOptions.y || 0,\n                fontSize = this.chart.renderer.fontMetrics(axisTitleOptions.style.fontSize).f,\n\n                // the position in the length direction of the axis\n                alongAxis = {\n                    low: margin + (horiz ? 0 : axisLength),\n                    middle: margin + axisLength / 2,\n                    high: margin + (horiz ? axisLength : 0)\n                }[axisTitleOptions.align],\n\n                // the position in the perpendicular direction of the axis\n                offAxis = (horiz ? axisTop + this.height : axisLeft) +\n                    (horiz ? 1 : -1) * // horizontal axis reverses the margin\n                    (opposite ? -1 : 1) * // so does opposite axes\n                    this.axisTitleMargin +\n                    (this.side === 2 ? fontSize : 0);\n\n            return {\n                x: horiz ?\n                    alongAxis + xOption :\n                    offAxis + (opposite ? this.width : 0) + offset + xOption,\n                y: horiz ?\n                    offAxis + yOption - (opposite ? this.height : 0) + offset :\n                    alongAxis + yOption\n            };\n        },\n\n        /**\n         * Render the axis\n         */\n        render: function () {\n            var axis = this,\n                chart = axis.chart,\n                renderer = chart.renderer,\n                options = axis.options,\n                isLog = axis.isLog,\n                lin2log = axis.lin2log,\n                isLinked = axis.isLinked,\n                tickPositions = axis.tickPositions,\n                axisTitle = axis.axisTitle,\n                ticks = axis.ticks,\n                minorTicks = axis.minorTicks,\n                alternateBands = axis.alternateBands,\n                stackLabelOptions = options.stackLabels,\n                alternateGridColor = options.alternateGridColor,\n                tickmarkOffset = axis.tickmarkOffset,\n                lineWidth = options.lineWidth,\n                linePath,\n                hasRendered = chart.hasRendered,\n                slideInTicks = hasRendered && isNumber(axis.oldMin),\n                showAxis = axis.showAxis,\n                animation = animObject(renderer.globalAnimation),\n                from,\n                to;\n\n            // Reset\n            axis.labelEdge.length = 0;\n            //axis.justifyToPlot = overflow === 'justify';\n            axis.overlap = false;\n\n            // Mark all elements inActive before we go over and mark the active ones\n            each([ticks, minorTicks, alternateBands], function (coll) {\n                var pos;\n                for (pos in coll) {\n                    coll[pos].isActive = false;\n                }\n            });\n\n            // If the series has data draw the ticks. Else only the line and title\n            if (axis.hasData() || isLinked) {\n\n                // minor ticks\n                if (axis.minorTickInterval && !axis.categories) {\n                    each(axis.getMinorTickPositions(), function (pos) {\n                        if (!minorTicks[pos]) {\n                            minorTicks[pos] = new Tick(axis, pos, 'minor');\n                        }\n\n                        // render new ticks in old position\n                        if (slideInTicks && minorTicks[pos].isNew) {\n                            minorTicks[pos].render(null, true);\n                        }\n\n                        minorTicks[pos].render(null, false, 1);\n                    });\n                }\n\n                // Major ticks. Pull out the first item and render it last so that\n                // we can get the position of the neighbour label. #808.\n                if (tickPositions.length) { // #1300\n                    each(tickPositions, function (pos, i) {\n\n                        // linked axes need an extra check to find out if\n                        if (!isLinked || (pos >= axis.min && pos <= axis.max)) {\n\n                            if (!ticks[pos]) {\n                                ticks[pos] = new Tick(axis, pos);\n                            }\n\n                            // render new ticks in old position\n                            if (slideInTicks && ticks[pos].isNew) {\n                                ticks[pos].render(i, true, 0.1);\n                            }\n\n                            ticks[pos].render(i);\n                        }\n\n                    });\n                    // In a categorized axis, the tick marks are displayed between labels. So\n                    // we need to add a tick mark and grid line at the left edge of the X axis.\n                    if (tickmarkOffset && (axis.min === 0 || axis.single)) {\n                        if (!ticks[-1]) {\n                            ticks[-1] = new Tick(axis, -1, null, true);\n                        }\n                        ticks[-1].render(-1);\n                    }\n\n                }\n\n                // alternate grid color\n                if (alternateGridColor) {\n                    each(tickPositions, function (pos, i) {\n                        to = tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] + tickmarkOffset : axis.max - tickmarkOffset; \n                        if (i % 2 === 0 && pos < axis.max && to <= axis.max + (chart.polar ? -tickmarkOffset : tickmarkOffset)) { // #2248, #4660\n                            if (!alternateBands[pos]) {\n                                alternateBands[pos] = new Highcharts.PlotLineOrBand(axis);\n                            }\n                            from = pos + tickmarkOffset; // #949\n                            alternateBands[pos].options = {\n                                from: isLog ? lin2log(from) : from,\n                                to: isLog ? lin2log(to) : to,\n                                color: alternateGridColor\n                            };\n                            alternateBands[pos].render();\n                            alternateBands[pos].isActive = true;\n                        }\n                    });\n                }\n\n                // custom plot lines and bands\n                if (!axis._addedPlotLB) { // only first time\n                    each((options.plotLines || []).concat(options.plotBands || []), function (plotLineOptions) {\n                        axis.addPlotBandOrLine(plotLineOptions);\n                    });\n                    axis._addedPlotLB = true;\n                }\n\n            } // end if hasData\n\n            // Remove inactive ticks\n            each([ticks, minorTicks, alternateBands], function (coll) {\n                var pos,\n                    i,\n                    forDestruction = [],\n                    delay = animation.duration,\n                    destroyInactiveItems = function () {\n                        i = forDestruction.length;\n                        while (i--) {\n                            // When resizing rapidly, the same items may be destroyed in different timeouts,\n                            // or the may be reactivated\n                            if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {\n                                coll[forDestruction[i]].destroy();\n                                delete coll[forDestruction[i]];\n                            }\n                        }\n\n                    };\n\n                for (pos in coll) {\n\n                    if (!coll[pos].isActive) {\n                        // Render to zero opacity\n                        coll[pos].render(pos, false, 0);\n                        coll[pos].isActive = false;\n                        forDestruction.push(pos);\n                    }\n                }\n\n                // When the objects are finished fading out, destroy them\n                syncTimeout(\n                    destroyInactiveItems, \n                    coll === alternateBands || !chart.hasRendered || !delay ? 0 : delay\n                );\n            });\n\n            // Static items. As the axis group is cleared on subsequent calls\n            // to render, these items are added outside the group.\n            // axis line\n            if (lineWidth) {\n                linePath = axis.getLinePath(lineWidth);\n                if (!axis.axisLine) {\n                    axis.axisLine = renderer.path(linePath)\n                        .attr({\n                            stroke: options.lineColor,\n                            'stroke-width': lineWidth,\n                            zIndex: 7\n                        })\n                        .add(axis.axisGroup);\n                } else {\n                    axis.axisLine.animate({ d: linePath });\n                }\n\n                // show or hide the line depending on options.showEmpty\n                axis.axisLine[showAxis ? 'show' : 'hide'](true);\n            }\n\n            if (axisTitle && showAxis) {\n\n                axisTitle[axisTitle.isNew ? 'attr' : 'animate'](\n                    axis.getTitlePosition()\n                );\n                axisTitle.isNew = false;\n            }\n\n            // Stacked totals:\n            if (stackLabelOptions && stackLabelOptions.enabled) {\n                axis.renderStackTotals();\n            }\n            // End stacked totals\n\n            axis.isDirty = false;\n        },\n\n        /**\n         * Redraw the axis to reflect changes in the data or axis extremes\n         */\n        redraw: function () {\n\n            if (this.visible) {\n                // render the axis\n                this.render();\n\n                // move plot lines and bands\n                each(this.plotLinesAndBands, function (plotLine) {\n                    plotLine.render();\n                });\n            }\n\n            // mark associated series as dirty and ready for redraw\n            each(this.series, function (series) {\n                series.isDirty = true;\n            });\n\n        },\n\n        /**\n         * Destroys an Axis instance.\n         */\n        destroy: function (keepEvents) {\n            var axis = this,\n                stacks = axis.stacks,\n                stackKey,\n                plotLinesAndBands = axis.plotLinesAndBands,\n                i;\n\n            // Remove the events\n            if (!keepEvents) {\n                removeEvent(axis);\n            }\n\n            // Destroy each stack total\n            for (stackKey in stacks) {\n                destroyObjectProperties(stacks[stackKey]);\n\n                stacks[stackKey] = null;\n            }\n\n            // Destroy collections\n            each([axis.ticks, axis.minorTicks, axis.alternateBands], function (coll) {\n                destroyObjectProperties(coll);\n            });\n            i = plotLinesAndBands.length;\n            while (i--) { // #1975\n                plotLinesAndBands[i].destroy();\n            }\n\n            // Destroy properties\n            each(['stackTotalGroup', 'axisLine', 'axisTitle', 'axisGroup', 'gridGroup', 'labelGroup', 'cross'], function (prop) {\n                if (axis[prop]) {\n                    axis[prop] = axis[prop].destroy();\n                }\n            });\n\n\n            this._addedPlotLB = this.chart._labelPanes = this.ordinalSlope = undefined; // #1611, #2887, #4314, #5316\n        },\n\n        /**\n         * Draw the crosshair\n         * \n         * @param  {Object} e The event arguments from the modified pointer event\n         * @param  {Object} point The Point object\n         */\n        drawCrosshair: function (e, point) {\n\n            var path,\n                options = this.crosshair,\n                pos,\n                attribs,\n                categorized,\n                strokeWidth;\n\n            // Use last available event when updating non-snapped crosshairs without\n            // mouse interaction (#5287)\n            if (!e) {\n                e = this.cross && this.cross.e;\n            }\n\n            if (\n                // Disabled in options\n                !this.crosshair ||\n                // Snap\n                ((defined(point) || !pick(options.snap, true)) === false)\n            ) {\n                this.hideCrosshair();\n            } else {\n\n                // Get the path\n                if (!pick(options.snap, true)) {\n                    pos = (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);\n                } else if (defined(point)) {\n                    pos = this.isXAxis ? point.plotX : this.len - point.plotY; // #3834\n                }\n\n                if (this.isRadial) {\n                    path = this.getPlotLinePath(this.isXAxis ? point.x : pick(point.stackY, point.y)) || null; // #3189\n                } else {\n                    path = this.getPlotLinePath(null, null, null, null, pos) || null; // #3189\n                }\n\n                if (path === null) {\n                    this.hideCrosshair();\n                    return;\n                }\n\n                categorized = this.categories && !this.isRadial;\n                strokeWidth = pick(options.width, (categorized ? this.transA : 1));\n\n                // Draw the cross\n                if (this.cross) {\n                    this.cross\n                        .attr({\n                            d: path,\n                            visibility: 'visible',\n                            'stroke-width': strokeWidth // #4737\n                        });\n                } else {\n                    attribs = {\n                        'pointer-events': 'none', // #5259\n                        'stroke-width': strokeWidth,\n                        stroke: options.color || (categorized ? 'rgba(155,200,255,0.2)' : '#C0C0C0'),\n                        zIndex: pick(options.zIndex, 2)\n                    };\n                    if (options.dashStyle) {\n                        attribs.dashstyle = options.dashStyle;\n                    }\n                    this.cross = this.chart.renderer.path(path).attr(attribs).add();\n                }\n                this.cross.e = e;\n            }\n\n        },\n\n        /**\n         *    Hide the crosshair.\n         */\n        hideCrosshair: function () {\n            if (this.cross) {\n                this.cross.hide();\n            }\n        }\n    }; // end Axis\n\n    extend(Axis.prototype, AxisPlotLineOrBandExtension);\n\n    /**\n     * Set the tick positions to a time unit that makes sense, for example\n     * on the first of each month or on every Monday. Return an array\n     * with the time positions. Used in datetime axes as well as for grouping\n     * data on a datetime axis.\n     *\n     * @param {Object} normalizedInterval The interval in axis values (ms) and the count\n     * @param {Number} min The minimum in axis values\n     * @param {Number} max The maximum in axis values\n     * @param {Number} startOfWeek\n     */\n    Axis.prototype.getTimeTicks = function (normalizedInterval, min, max, startOfWeek) {\n        var tickPositions = [],\n            i,\n            higherRanks = {},\n            useUTC = defaultOptions.global.useUTC,\n            minYear, // used in months and years as a basis for Date.UTC()\n            minDate = new Date(min - getTZOffset(min)),\n            interval = normalizedInterval.unitRange,\n            count = normalizedInterval.count;\n\n        if (defined(min)) { // #1300\n            minDate[setMilliseconds](interval >= timeUnits.second ? 0 : // #3935\n                count * mathFloor(minDate.getMilliseconds() / count)); // #3652, #3654\n\n            if (interval >= timeUnits.second) { // second\n                minDate[setSeconds](interval >= timeUnits.minute ? 0 : // #3935\n                    count * mathFloor(minDate.getSeconds() / count));\n            }\n\n            if (interval >= timeUnits.minute) { // minute\n                minDate[setMinutes](interval >= timeUnits.hour ? 0 :\n                    count * mathFloor(minDate[getMinutes]() / count));\n            }\n\n            if (interval >= timeUnits.hour) { // hour\n                minDate[setHours](interval >= timeUnits.day ? 0 :\n                    count * mathFloor(minDate[getHours]() / count));\n            }\n\n            if (interval >= timeUnits.day) { // day\n                minDate[setDate](interval >= timeUnits.month ? 1 :\n                    count * mathFloor(minDate[getDate]() / count));\n            }\n\n            if (interval >= timeUnits.month) { // month\n                minDate[setMonth](interval >= timeUnits.year ? 0 :\n                    count * mathFloor(minDate[getMonth]() / count));\n                minYear = minDate[getFullYear]();\n            }\n\n            if (interval >= timeUnits.year) { // year\n                minYear -= minYear % count;\n                minDate[setFullYear](minYear);\n            }\n\n            // week is a special case that runs outside the hierarchy\n            if (interval === timeUnits.week) {\n                // get start of current week, independent of count\n                minDate[setDate](minDate[getDate]() - minDate[getDay]() +\n                    pick(startOfWeek, 1));\n            }\n\n\n            // get tick positions\n            i = 1;\n            if (timezoneOffset || getTimezoneOffset) {\n                minDate = minDate.getTime();\n                minDate = new Date(minDate + getTZOffset(minDate));\n            }\n            minYear = minDate[getFullYear]();\n            var time = minDate.getTime(),\n                minMonth = minDate[getMonth](),\n                minDateDate = minDate[getDate](),\n                variableDayLength = !useUTC || !!getTimezoneOffset, // #4951\n                localTimezoneOffset = (timeUnits.day +\n                        (useUTC ? getTZOffset(minDate) : minDate.getTimezoneOffset() * 60 * 1000)\n                    ) % timeUnits.day; // #950, #3359\n\n            // iterate and add tick positions at appropriate values\n            while (time < max) {\n                tickPositions.push(time);\n\n                // if the interval is years, use Date.UTC to increase years\n                if (interval === timeUnits.year) {\n                    time = makeTime(minYear + i * count, 0);\n\n                // if the interval is months, use Date.UTC to increase months\n                } else if (interval === timeUnits.month) {\n                    time = makeTime(minYear, minMonth + i * count);\n\n                // if we're using global time, the interval is not fixed as it jumps\n                // one hour at the DST crossover\n                } else if (variableDayLength && (interval === timeUnits.day || interval === timeUnits.week)) {\n                    time = makeTime(minYear, minMonth, minDateDate +\n                        i * count * (interval === timeUnits.day ? 1 : 7));\n\n                // else, the interval is fixed and we use simple addition\n                } else {\n                    time += interval * count;\n                }\n\n                i++;\n            }\n\n            // push the last time\n            tickPositions.push(time);\n\n\n            // mark new days if the time is dividible by day (#1649, #1760)\n            each(grep(tickPositions, function (time) {\n                return interval <= timeUnits.hour && time % timeUnits.day === localTimezoneOffset;\n            }), function (time) {\n                higherRanks[time] = 'day';\n            });\n        }\n\n\n        // record information on the chosen unit - for dynamic label formatter\n        tickPositions.info = extend(normalizedInterval, {\n            higherRanks: higherRanks,\n            totalRange: interval * count\n        });\n\n        return tickPositions;\n    };\n\n    /**\n     * Get a normalized tick interval for dates. Returns a configuration object with\n     * unit range (interval), count and name. Used to prepare data for getTimeTicks.\n     * Previously this logic was part of getTimeTicks, but as getTimeTicks now runs\n     * of segments in stock charts, the normalizing logic was extracted in order to\n     * prevent it for running over again for each segment having the same interval.\n     * #662, #697.\n     */\n    Axis.prototype.normalizeTimeTickInterval = function (tickInterval, unitsOption) {\n        var units = unitsOption || [[\n                'millisecond', // unit name\n                [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples\n            ], [\n                'second',\n                [1, 2, 5, 10, 15, 30]\n            ], [\n                'minute',\n                [1, 2, 5, 10, 15, 30]\n            ], [\n                'hour',\n                [1, 2, 3, 4, 6, 8, 12]\n            ], [\n                'day',\n                [1, 2]\n            ], [\n                'week',\n                [1, 2]\n            ], [\n                'month',\n                [1, 2, 3, 4, 6]\n            ], [\n                'year',\n                null\n            ]],\n            unit = units[units.length - 1], // default unit is years\n            interval = timeUnits[unit[0]],\n            multiples = unit[1],\n            count,\n            i;\n\n        // loop through the units to find the one that best fits the tickInterval\n        for (i = 0; i < units.length; i++) {\n            unit = units[i];\n            interval = timeUnits[unit[0]];\n            multiples = unit[1];\n\n\n            if (units[i + 1]) {\n                // lessThan is in the middle between the highest multiple and the next unit.\n                var lessThan = (interval * multiples[multiples.length - 1] +\n                            timeUnits[units[i + 1][0]]) / 2;\n\n                // break and keep the current unit\n                if (tickInterval <= lessThan) {\n                    break;\n                }\n            }\n        }\n\n        // prevent 2.5 years intervals, though 25, 250 etc. are allowed\n        if (interval === timeUnits.year && tickInterval < 5 * interval) {\n            multiples = [1, 2, 5];\n        }\n\n        // get the count\n        count = normalizeTickInterval(\n            tickInterval / interval,\n            multiples,\n            unit[0] === 'year' ? mathMax(getMagnitude(tickInterval / interval), 1) : 1 // #1913, #2360\n        );\n\n        return {\n            unitRange: interval,\n            count: count,\n            unitName: unit[0]\n        };\n    };\n    /**\n     * Methods defined on the Axis prototype\n     */\n\n    /**\n     * Set the tick positions of a logarithmic axis\n     */\n    Axis.prototype.getLogTickPositions = function (interval, min, max, minor) {\n        var axis = this,\n            options = axis.options,\n            axisLength = axis.len,\n            lin2log = axis.lin2log,\n            log2lin = axis.log2lin,\n            // Since we use this method for both major and minor ticks,\n            // use a local variable and return the result\n            positions = [];\n\n        // Reset\n        if (!minor) {\n            axis._minorAutoInterval = null;\n        }\n\n        // First case: All ticks fall on whole logarithms: 1, 10, 100 etc.\n        if (interval >= 0.5) {\n            interval = mathRound(interval);\n            positions = axis.getLinearTickPositions(interval, min, max);\n\n        // Second case: We need intermediary ticks. For example\n        // 1, 2, 4, 6, 8, 10, 20, 40 etc.\n        } else if (interval >= 0.08) {\n            var roundedMin = mathFloor(min),\n                intermediate,\n                i,\n                j,\n                len,\n                pos,\n                lastPos,\n                break2;\n\n            if (interval > 0.3) {\n                intermediate = [1, 2, 4];\n            } else if (interval > 0.15) { // 0.2 equals five minor ticks per 1, 10, 100 etc\n                intermediate = [1, 2, 4, 6, 8];\n            } else { // 0.1 equals ten minor ticks per 1, 10, 100 etc\n                intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n            }\n\n            for (i = roundedMin; i < max + 1 && !break2; i++) {\n                len = intermediate.length;\n                for (j = 0; j < len && !break2; j++) {\n                    pos = log2lin(lin2log(i) * intermediate[j]);\n                    if (pos > min && (!minor || lastPos <= max) && lastPos !== UNDEFINED) { // #1670, lastPos is #3113\n                        positions.push(lastPos);\n                    }\n\n                    if (lastPos > max) {\n                        break2 = true;\n                    }\n                    lastPos = pos;\n                }\n            }\n\n        // Third case: We are so deep in between whole logarithmic values that\n        // we might as well handle the tick positions like a linear axis. For\n        // example 1.01, 1.02, 1.03, 1.04.\n        } else {\n            var realMin = lin2log(min),\n                realMax = lin2log(max),\n                tickIntervalOption = options[minor ? 'minorTickInterval' : 'tickInterval'],\n                filteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption,\n                tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),\n                totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;\n\n            interval = pick(\n                filteredTickIntervalOption,\n                axis._minorAutoInterval,\n                (realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1)\n            );\n\n            interval = normalizeTickInterval(\n                interval,\n                null,\n                getMagnitude(interval)\n            );\n\n            positions = map(axis.getLinearTickPositions(\n                interval,\n                realMin,\n                realMax\n            ), log2lin);\n\n            if (!minor) {\n                axis._minorAutoInterval = interval / 5;\n            }\n        }\n\n        // Set the axis-level tickInterval variable\n        if (!minor) {\n            axis.tickInterval = interval;\n        }\n        return positions;\n    };\n\n    Axis.prototype.log2lin = function (num) {\n        return math.log(num) / math.LN10;\n    };\n\n    Axis.prototype.lin2log = function (num) {\n        return math.pow(10, num);\n    };\n    /**\n     * The tooltip object\n     * @param {Object} chart The chart instance\n     * @param {Object} options Tooltip options\n     */\n    var Tooltip = Highcharts.Tooltip = function () {\n        this.init.apply(this, arguments);\n    };\n\n    Tooltip.prototype = {\n\n        init: function (chart, options) {\n\n            var borderWidth = options.borderWidth,\n                style = options.style,\n                padding = pInt(style.padding);\n\n            // Save the chart and options\n            this.chart = chart;\n            this.options = options;\n\n            // Keep track of the current series\n            //this.currentSeries = UNDEFINED;\n\n            // List of crosshairs\n            this.crosshairs = [];\n\n            // Current values of x and y when animating\n            this.now = { x: 0, y: 0 };\n\n            // The tooltip is initially hidden\n            this.isHidden = true;\n\n\n            // create the label\n            this.label = chart.renderer.label('', 0, 0, options.shape || 'callout', null, null, options.useHTML, null, 'tooltip')\n                .attr({\n                    padding: padding,\n                    fill: options.backgroundColor,\n                    'stroke-width': borderWidth,\n                    r: options.borderRadius,\n                    zIndex: 8,\n                    display: 'none' // #2301, #2657, #3532, #5570\n                })\n                .css(style)\n                .css({ padding: 0 }) // Remove it from VML, the padding is applied as an attribute instead (#1117)\n                .add();\n\n            // When using canVG the shadow shows up as a gray circle\n            // even if the tooltip is hidden.\n            if (!useCanVG) {\n                this.label.shadow(options.shadow);\n            }\n\n            // Public property for getting the shared state.\n            this.shared = options.shared;\n        },\n\n        /**\n         * Destroy the tooltip and its elements.\n         */\n        destroy: function () {\n            // Destroy and clear local variables\n            if (this.label) {\n                this.label = this.label.destroy();\n            }\n            clearTimeout(this.hideTimer);\n            clearTimeout(this.tooltipTimeout);\n        },\n\n        /**\n         * Provide a soft movement for the tooltip\n         *\n         * @param {Number} x\n         * @param {Number} y\n         * @private\n         */\n        move: function (x, y, anchorX, anchorY) {\n            var tooltip = this,\n                now = tooltip.now,\n                animate = tooltip.options.animation !== false && !tooltip.isHidden &&\n                    // When we get close to the target position, abort animation and land on the right place (#3056)\n                    (mathAbs(x - now.x) > 1 || mathAbs(y - now.y) > 1),\n                skipAnchor = tooltip.followPointer || tooltip.len > 1;\n\n            // Get intermediate values for animation\n            extend(now, {\n                x: animate ? (2 * now.x + x) / 3 : x,\n                y: animate ? (now.y + y) / 2 : y,\n                anchorX: skipAnchor ? UNDEFINED : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,\n                anchorY: skipAnchor ? UNDEFINED : animate ? (now.anchorY + anchorY) / 2 : anchorY\n            });\n\n            // Move to the intermediate value\n            tooltip.label.attr(now);\n\n\n            // Run on next tick of the mouse tracker\n            if (animate) {\n\n                // Never allow two timeouts\n                clearTimeout(this.tooltipTimeout);\n\n                // Set the fixed interval ticking for the smooth tooltip\n                this.tooltipTimeout = setTimeout(function () {\n                    // The interval function may still be running during destroy, so check that the chart is really there before calling.\n                    if (tooltip) {\n                        tooltip.move(x, y, anchorX, anchorY);\n                    }\n                }, 32);\n\n            }\n        },\n\n        /**\n         * Hide the tooltip\n         */\n        hide: function (delay) {\n            var tooltip = this;\n            clearTimeout(this.hideTimer); // disallow duplicate timers (#1728, #1766)\n            delay = pick(delay, this.options.hideDelay, 500);\n            if (!this.isHidden) {\n                this.hideTimer = syncTimeout(function () {\n                    tooltip.label[delay ? 'fadeOut' : 'hide']();\n                    tooltip.isHidden = true;\n                }, delay);\n            }\n        },\n\n        /**\n         * Extendable method to get the anchor position of the tooltip\n         * from a point or set of points\n         */\n        getAnchor: function (points, mouseEvent) {\n            var ret,\n                chart = this.chart,\n                inverted = chart.inverted,\n                plotTop = chart.plotTop,\n                plotLeft = chart.plotLeft,\n                plotX = 0,\n                plotY = 0,\n                yAxis,\n                xAxis;\n\n            points = splat(points);\n\n            // Pie uses a special tooltipPos\n            ret = points[0].tooltipPos;\n\n            // When tooltip follows mouse, relate the position to the mouse\n            if (this.followPointer && mouseEvent) {\n                if (mouseEvent.chartX === UNDEFINED) {\n                    mouseEvent = chart.pointer.normalize(mouseEvent);\n                }\n                ret = [\n                    mouseEvent.chartX - chart.plotLeft,\n                    mouseEvent.chartY - plotTop\n                ];\n            }\n            // When shared, use the average position\n            if (!ret) {\n                each(points, function (point) {\n                    yAxis = point.series.yAxis;\n                    xAxis = point.series.xAxis;\n                    plotX += point.plotX  + (!inverted && xAxis ? xAxis.left - plotLeft : 0);\n                    plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) +\n                        (!inverted && yAxis ? yAxis.top - plotTop : 0); // #1151\n                });\n\n                plotX /= points.length;\n                plotY /= points.length;\n\n                ret = [\n                    inverted ? chart.plotWidth - plotY : plotX,\n                    this.shared && !inverted && points.length > 1 && mouseEvent ?\n                        mouseEvent.chartY - plotTop : // place shared tooltip next to the mouse (#424)\n                        inverted ? chart.plotHeight - plotX : plotY\n                ];\n            }\n\n            return map(ret, mathRound);\n        },\n\n        /**\n         * Place the tooltip in a chart without spilling over\n         * and not covering the point it self.\n         */\n        getPosition: function (boxWidth, boxHeight, point) {\n\n            var chart = this.chart,\n                distance = this.distance,\n                ret = {},\n                h = point.h || 0, // #4117\n                swapped,\n                first = ['y', chart.chartHeight, boxHeight, point.plotY + chart.plotTop, chart.plotTop, chart.plotTop + chart.plotHeight],\n                second = ['x', chart.chartWidth, boxWidth, point.plotX + chart.plotLeft, chart.plotLeft, chart.plotLeft + chart.plotWidth],\n                // The far side is right or bottom\n                preferFarSide = !this.followPointer && pick(point.ttBelow, !chart.inverted === !!point.negative), // #4984\n                /**\n                 * Handle the preferred dimension. When the preferred dimension is tooltip\n                 * on top or bottom of the point, it will look for space there.\n                 */\n                firstDimension = function (dim, outerSize, innerSize, point, min, max) {\n                    var roomLeft = innerSize < point - distance,\n                        roomRight = point + distance + innerSize < outerSize,\n                        alignedLeft = point - distance - innerSize,\n                        alignedRight = point + distance;\n\n                    if (preferFarSide && roomRight) {\n                        ret[dim] = alignedRight;\n                    } else if (!preferFarSide && roomLeft) {\n                        ret[dim] = alignedLeft;\n                    } else if (roomLeft) {\n                        ret[dim] = mathMin(max - innerSize, alignedLeft - h < 0 ? alignedLeft : alignedLeft - h);\n                    } else if (roomRight) {\n                        ret[dim] = mathMax(min, alignedRight + h + innerSize > outerSize ? alignedRight : alignedRight + h);\n                    } else {\n                        return false;\n                    }\n                },\n                /**\n                 * Handle the secondary dimension. If the preferred dimension is tooltip\n                 * on top or bottom of the point, the second dimension is to align the tooltip\n                 * above the point, trying to align center but allowing left or right\n                 * align within the chart box.\n                 */\n                secondDimension = function (dim, outerSize, innerSize, point) {\n                    var retVal;\n\n                    // Too close to the edge, return false and swap dimensions\n                    if (point < distance || point > outerSize - distance) {\n                        retVal = false;\n                    // Align left/top\n                    } else if (point < innerSize / 2) {\n                        ret[dim] = 1;\n                    // Align right/bottom\n                    } else if (point > outerSize - innerSize / 2) {\n                        ret[dim] = outerSize - innerSize - 2;\n                    // Align center\n                    } else {\n                        ret[dim] = point - innerSize / 2;\n                    }\n                    return retVal;\n                },\n                /**\n                 * Swap the dimensions\n                 */\n                swap = function (count) {\n                    var temp = first;\n                    first = second;\n                    second = temp;\n                    swapped = count;\n                },\n                run = function () {\n                    if (firstDimension.apply(0, first) !== false) {\n                        if (secondDimension.apply(0, second) === false && !swapped) {\n                            swap(true);\n                            run();\n                        }\n                    } else if (!swapped) {\n                        swap(true);\n                        run();\n                    } else {\n                        ret.x = ret.y = 0;\n                    }\n                };\n\n            // Under these conditions, prefer the tooltip on the side of the point\n            if (chart.inverted || this.len > 1) {\n                swap();\n            }\n            run();\n\n            return ret;\n\n        },\n\n        /**\n         * In case no user defined formatter is given, this will be used. Note that the context\n         * here is an object holding point, series, x, y etc.\n         */\n        defaultFormatter: function (tooltip) {\n            var items = this.points || splat(this),\n                s;\n\n            // build the header\n            s = [tooltip.tooltipFooterHeaderFormatter(items[0])]; //#3397: abstraction to enable formatting of footer and header\n\n            // build the values\n            s = s.concat(tooltip.bodyFormatter(items));\n\n            // footer\n            s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true)); //#3397: abstraction to enable formatting of footer and header\n\n            return s.join('');\n        },\n\n        /**\n         * Refresh the tooltip's text and position.\n         * @param {Object} point\n         */\n        refresh: function (point, mouseEvent) {\n            var tooltip = this,\n                chart = tooltip.chart,\n                label = tooltip.label,\n                options = tooltip.options,\n                x,\n                y,\n                anchor,\n                textConfig = {},\n                text,\n                pointConfig = [],\n                formatter = options.formatter || tooltip.defaultFormatter,\n                hoverPoints = chart.hoverPoints,\n                borderColor,\n                shared = tooltip.shared,\n                currentSeries;\n\n            clearTimeout(this.hideTimer);\n\n            // get the reference point coordinates (pie charts use tooltipPos)\n            tooltip.followPointer = splat(point)[0].series.tooltipOptions.followPointer;\n            anchor = tooltip.getAnchor(point, mouseEvent);\n            x = anchor[0];\n            y = anchor[1];\n\n            // shared tooltip, array is sent over\n            if (shared && !(point.series && point.series.noSharedTooltip)) {\n\n                // hide previous hoverPoints and set new\n\n                chart.hoverPoints = point;\n                if (hoverPoints) {\n                    each(hoverPoints, function (point) {\n                        point.setState();\n                    });\n                }\n\n                each(point, function (item) {\n                    item.setState(HOVER_STATE);\n\n                    pointConfig.push(item.getLabelConfig());\n                });\n\n                textConfig = {\n                    x: point[0].category,\n                    y: point[0].y\n                };\n                textConfig.points = pointConfig;\n                this.len = pointConfig.length;\n                point = point[0];\n\n            // single point tooltip\n            } else {\n                textConfig = point.getLabelConfig();\n            }\n            text = formatter.call(textConfig, tooltip);\n\n            // register the current series\n            currentSeries = point.series;\n            this.distance = pick(currentSeries.tooltipOptions.distance, 16);\n\n            // update the inner HTML\n            if (text === false) {\n                this.hide();\n            } else {\n\n                // show it\n                if (tooltip.isHidden) {\n                    stop(label);\n                    label.attr({\n                        opacity: 1,\n                        display: 'block'\n                    }).show();\n                }\n\n                // update text\n                label.attr({\n                    text: text\n                });\n\n                // set the stroke color of the box\n                borderColor = options.borderColor || point.color || currentSeries.color || '#606060';\n                label.attr({\n                    stroke: borderColor\n                });\n                tooltip.updatePosition({\n                    plotX: x,\n                    plotY: y,\n                    negative: point.negative,\n                    ttBelow: point.ttBelow,\n                    h: anchor[2] || 0\n                });\n\n                this.isHidden = false;\n            }\n            fireEvent(chart, 'tooltipRefresh', {\n                text: text,\n                x: x + chart.plotLeft,\n                y: y + chart.plotTop,\n                borderColor: borderColor\n            });\n        },\n\n        /**\n         * Find the new position and perform the move\n         */\n        updatePosition: function (point) {\n            var chart = this.chart,\n                label = this.label,\n                pos = (this.options.positioner || this.getPosition).call(\n                    this,\n                    label.width,\n                    label.height,\n                    point\n                );\n\n            // do the move\n            this.move(\n                mathRound(pos.x),\n                mathRound(pos.y || 0), // can be undefined (#3977)\n                point.plotX + chart.plotLeft,\n                point.plotY + chart.plotTop\n            );\n        },\n\n        /**\n         * Get the best X date format based on the closest point range on the axis.\n         */\n        getXDateFormat: function (point, options, xAxis) {\n            var xDateFormat,\n                dateTimeLabelFormats = options.dateTimeLabelFormats,\n                closestPointRange = xAxis && xAxis.closestPointRange,\n                n,\n                blank = '01-01 00:00:00.000',\n                strpos = {\n                    millisecond: 15,\n                    second: 12,\n                    minute: 9,\n                    hour: 6,\n                    day: 3\n                },\n                date,\n                lastN = 'millisecond'; // for sub-millisecond data, #4223\n\n            if (closestPointRange) {\n                date = dateFormat('%m-%d %H:%M:%S.%L', point.x);\n                for (n in timeUnits) {\n\n                    // If the range is exactly one week and we're looking at a Sunday/Monday, go for the week format\n                    if (closestPointRange === timeUnits.week && +dateFormat('%w', point.x) === xAxis.options.startOfWeek &&\n                            date.substr(6) === blank.substr(6)) {\n                        n = 'week';\n                        break;\n                    }\n\n                    // The first format that is too great for the range\n                    if (timeUnits[n] > closestPointRange) {\n                        n = lastN;\n                        break;\n                    }\n\n                    // If the point is placed every day at 23:59, we need to show\n                    // the minutes as well. #2637.\n                    if (strpos[n] && date.substr(strpos[n]) !== blank.substr(strpos[n])) {\n                        break;\n                    }\n\n                    // Weeks are outside the hierarchy, only apply them on Mondays/Sundays like in the first condition\n                    if (n !== 'week') {\n                        lastN = n;\n                    }\n                }\n\n                if (n) {\n                    xDateFormat = dateTimeLabelFormats[n];\n                }\n            } else {\n                xDateFormat = dateTimeLabelFormats.day;\n            }\n\n            return xDateFormat || dateTimeLabelFormats.year; // #2546, 2581\n        },\n\n        /**\n         * Format the footer/header of the tooltip\n         * #3397: abstraction to enable formatting of footer and header\n         */\n        tooltipFooterHeaderFormatter: function (labelConfig, isFooter) {\n            var footOrHead = isFooter ? 'footer' : 'header',\n                series = labelConfig.series,\n                tooltipOptions = series.tooltipOptions,\n                xDateFormat = tooltipOptions.xDateFormat,\n                xAxis = series.xAxis,\n                isDateTime = xAxis && xAxis.options.type === 'datetime' && isNumber(labelConfig.key),\n                formatString = tooltipOptions[footOrHead + 'Format'];\n\n            // Guess the best date format based on the closest point distance (#568, #3418)\n            if (isDateTime && !xDateFormat) {\n                xDateFormat = this.getXDateFormat(labelConfig, tooltipOptions, xAxis);\n            }\n\n            // Insert the footer date format if any\n            if (isDateTime && xDateFormat) {\n                formatString = formatString.replace('{point.key}', '{point.key:' + xDateFormat + '}');\n            }\n\n            return format(formatString, {\n                point: labelConfig,\n                series: series\n            });\n        },\n\n        /**\n         * Build the body (lines) of the tooltip by iterating over the items and returning one entry for each item,\n         * abstracting this functionality allows to easily overwrite and extend it.\n         */\n        bodyFormatter: function (items) {\n            return map(items, function (item) {\n                var tooltipOptions = item.series.tooltipOptions;\n                return (tooltipOptions.pointFormatter || item.point.tooltipFormatter).call(item.point, tooltipOptions.pointFormat);\n            });\n        }\n\n    };\n\n    var hoverChartIndex;\n\n    // Global flag for touch support\n    hasTouch = doc && doc.documentElement.ontouchstart !== UNDEFINED;\n\n    /**\n     * The mouse tracker object. All methods starting with \"on\" are primary DOM event handlers.\n     * Subsequent methods should be named differently from what they are doing.\n     * @param {Object} chart The Chart instance\n     * @param {Object} options The root options object\n     */\n    var Pointer = Highcharts.Pointer = function (chart, options) {\n        this.init(chart, options);\n    };\n\n    Pointer.prototype = {\n        /**\n         * Initialize Pointer\n         */\n        init: function (chart, options) {\n\n            var chartOptions = options.chart,\n                chartEvents = chartOptions.events,\n                zoomType = useCanVG ? '' : chartOptions.zoomType,\n                inverted = chart.inverted,\n                zoomX,\n                zoomY;\n\n            // Store references\n            this.options = options;\n            this.chart = chart;\n\n            // Zoom status\n            this.zoomX = zoomX = /x/.test(zoomType);\n            this.zoomY = zoomY = /y/.test(zoomType);\n            this.zoomHor = (zoomX && !inverted) || (zoomY && inverted);\n            this.zoomVert = (zoomY && !inverted) || (zoomX && inverted);\n            this.hasZoom = zoomX || zoomY;\n\n            // Do we need to handle click on a touch device?\n            this.runChartClick = chartEvents && !!chartEvents.click;\n\n            this.pinchDown = [];\n            this.lastValidTouch = {};\n\n            if (Highcharts.Tooltip && options.tooltip.enabled) {\n                chart.tooltip = new Tooltip(chart, options.tooltip);\n                this.followTouchMove = pick(options.tooltip.followTouchMove, true);\n            }\n\n            this.setDOMEvents();\n        },\n\n        /**\n         * Add crossbrowser support for chartX and chartY\n         * @param {Object} e The event object in standard browsers\n         */\n        normalize: function (e, chartPosition) {\n            var chartX,\n                chartY,\n                ePos;\n\n            // IE normalizing\n            e = e || win.event;\n            if (!e.target) {\n                e.target = e.srcElement;\n            }\n\n            // iOS (#2757)\n            ePos = e.touches ?  (e.touches.length ? e.touches.item(0) : e.changedTouches[0]) : e;\n\n            // Get mouse position\n            if (!chartPosition) {\n                this.chartPosition = chartPosition = offset(this.chart.container);\n            }\n\n            // chartX and chartY\n            if (ePos.pageX === UNDEFINED) { // IE < 9. #886.\n                chartX = mathMax(e.x, e.clientX - chartPosition.left); // #2005, #2129: the second case is\n                    // for IE10 quirks mode within framesets\n                chartY = e.y;\n            } else {\n                chartX = ePos.pageX - chartPosition.left;\n                chartY = ePos.pageY - chartPosition.top;\n            }\n\n            return extend(e, {\n                chartX: mathRound(chartX),\n                chartY: mathRound(chartY)\n            });\n        },\n\n        /**\n         * Get the click position in terms of axis values.\n         *\n         * @param {Object} e A pointer event\n         */\n        getCoordinates: function (e) {\n            var coordinates = {\n                xAxis: [],\n                yAxis: []\n            };\n\n            each(this.chart.axes, function (axis) {\n                coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({\n                    axis: axis,\n                    value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])\n                });\n            });\n            return coordinates;\n        },\n\n        /**\n         * With line type charts with a single tracker, get the point closest to the mouse.\n         * Run Point.onMouseOver and display tooltip for the point or points.\n         */\n        runPointActions: function (e) {\n\n            var pointer = this,\n                chart = pointer.chart,\n                series = chart.series,\n                tooltip = chart.tooltip,\n                shared = tooltip ? tooltip.shared : false,\n                followPointer,\n                updatePosition = true,\n                hoverPoint = chart.hoverPoint,\n                hoverSeries = chart.hoverSeries,\n                i,\n                anchor,\n                noSharedTooltip,\n                stickToHoverSeries,\n                directTouch,\n                kdpoints = [],\n                kdpointT;\n\n            // For hovering over the empty parts of the plot area (hoverSeries is undefined).\n            // If there is one series with point tracking (combo chart), don't go to nearest neighbour.\n            if (!shared && !hoverSeries) {\n                for (i = 0; i < series.length; i++) {\n                    if (series[i].directTouch || !series[i].options.stickyTracking) {\n                        series = [];\n                    }\n                }\n            }\n\n            // If it has a hoverPoint and that series requires direct touch (like columns, #3899), or we're on\n            // a noSharedTooltip series among shared tooltip series (#4546), use the hoverPoint . Otherwise,\n            // search the k-d tree.\n            stickToHoverSeries = hoverSeries && (shared ? hoverSeries.noSharedTooltip : hoverSeries.directTouch);\n            if (stickToHoverSeries && hoverPoint) {\n                kdpoints = [hoverPoint];\n\n            // Handle shared tooltip or cases where a series is not yet hovered\n            } else {\n                // When we have non-shared tooltip and sticky tracking is disabled,\n                // search for the closest point only on hovered series: #5533, #5476\n                if (!shared && hoverSeries && !hoverSeries.options.stickyTracking) {\n                    series = [hoverSeries];\n                }\n                // Find nearest points on all series\n                each(series, function (s) {\n                    // Skip hidden series\n                    noSharedTooltip = s.noSharedTooltip && shared;\n                    directTouch = !shared && s.directTouch;\n                    if (s.visible && !noSharedTooltip && !directTouch && pick(s.options.enableMouseTracking, true)) { // #3821\n                        kdpointT = s.searchPoint(e, !noSharedTooltip && s.kdDimensions === 1); // #3828\n                        if (kdpointT && kdpointT.series) { // Point.series becomes null when reset and before redraw (#5197)\n                            kdpoints.push(kdpointT);\n                        }\n                    }\n                });\n\n                // Sort kdpoints by distance to mouse pointer\n                kdpoints.sort(function (p1, p2) {\n                    var isCloserX = p1.distX - p2.distX,\n                        isCloser = p1.dist - p2.dist,\n                        isAbove = p1.series.group.zIndex > p2.series.group.zIndex ? -1 : 1;\n                    // We have two points which are not in the same place on xAxis and shared tooltip:\n                    if (isCloserX !== 0) {\n                        return isCloserX;\n                    }\n                    // Points are not exactly in the same place on x/yAxis:\n                    if (isCloser !== 0) {\n                        return isCloser;\n                    }\n                    // The same xAxis and yAxis position, sort by z-index:\n                    return isAbove;\n                });\n            }\n\n            // Remove points with different x-positions, required for shared tooltip and crosshairs (#4645):\n            if (shared) {\n                i = kdpoints.length;\n                while (i--) {\n                    if (kdpoints[i].clientX !== kdpoints[0].clientX || kdpoints[i].series.noSharedTooltip) {\n                        kdpoints.splice(i, 1);\n                    }\n                }\n            }\n\n            // Refresh tooltip for kdpoint if new hover point or tooltip was hidden // #3926, #4200\n            if (kdpoints[0] && (kdpoints[0] !== pointer.hoverPoint || (tooltip && tooltip.isHidden))) {\n                // Draw tooltip if necessary\n                if (shared && !kdpoints[0].series.noSharedTooltip) {\n                    // Do mouseover on all points (#3919, #3985, #4410)\n                    for (i = 0; i >= 0; i--) {\n                        kdpoints[i].onMouseOver(e, kdpoints[i] !== ((hoverSeries && hoverSeries.directTouch && hoverPoint) || kdpoints[0]));\n                    }\n                    // Make sure that the hoverPoint and hoverSeries are stored for events (e.g. click), #5622\n                    if (hoverSeries && hoverSeries.directTouch && hoverPoint && hoverPoint !== kdpoints[0]) {\n                        hoverPoint.onMouseOver(e, false);\n                    }\n                    if (kdpoints.length && tooltip) {\n                        // Keep the order of series in tooltip:\n                        tooltip.refresh(kdpoints.sort(function (p1, p2) {\n                            return p1.series.index - p2.series.index;\n                        }), e);\n                    }\n                } else {\n                    if (tooltip) {\n                        tooltip.refresh(kdpoints[0], e);\n                    }\n                    if (!hoverSeries || !hoverSeries.directTouch) { // #4448\n                        kdpoints[0].onMouseOver(e);\n                    }\n                }\n                pointer.prevKDPoint = kdpoints[0];\n                updatePosition = false;\n            }\n            // Update positions (regardless of kdpoint or hoverPoint)\n            if (updatePosition) {\n                followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer;\n                if (tooltip && followPointer && !tooltip.isHidden) {\n                    anchor = tooltip.getAnchor([{}], e);\n                    tooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });\n                }\n            }\n\n            // Start the event listener to pick up the tooltip and crosshairs\n            if (!pointer._onDocumentMouseMove) {\n                pointer._onDocumentMouseMove = function (e) {\n                    if (charts[hoverChartIndex]) {\n                        charts[hoverChartIndex].pointer.onDocumentMouseMove(e);\n                    }\n                };\n                addEvent(doc, 'mousemove', pointer._onDocumentMouseMove);\n            }\n\n            // Crosshair. For each hover point, loop over axes and draw cross if that point\n            // belongs to the axis (#4927).\n            each(shared ? kdpoints : [pick(hoverPoint, kdpoints[0])], function drawPointCrosshair(point) { // #5269\n                each(chart.axes, function drawAxisCrosshair(axis) {\n                    // In case of snap = false, point is undefined, and we draw the crosshair anyway (#5066)\n                    if (!point || point.series && point.series[axis.coll] === axis) { // #5658\n                        axis.drawCrosshair(e, point);\n                    }\n                });\n            });\n        },\n\n        /**\n         * Reset the tracking by hiding the tooltip, the hover series state and the hover point\n         *\n         * @param allowMove {Boolean} Instead of destroying the tooltip altogether, allow moving it if possible\n         */\n        reset: function (allowMove, delay) {\n            var pointer = this,\n                chart = pointer.chart,\n                hoverSeries = chart.hoverSeries,\n                hoverPoint = chart.hoverPoint,\n                hoverPoints = chart.hoverPoints,\n                tooltip = chart.tooltip,\n                tooltipPoints = tooltip && tooltip.shared ? hoverPoints : hoverPoint;\n\n            // Check if the points have moved outside the plot area (#1003, #4736, #5101)\n            if (allowMove && tooltipPoints) {\n                each(splat(tooltipPoints), function (point) {\n                    if (point.series.isCartesian && point.plotX === undefined) {\n                        allowMove = false;\n                    }\n                });\n            }\n        \n            // Just move the tooltip, #349\n            if (allowMove) {\n                if (tooltip && tooltipPoints) {\n                    tooltip.refresh(tooltipPoints);\n                    if (hoverPoint) { // #2500\n                        hoverPoint.setState(hoverPoint.state, true);\n                        each(chart.axes, function (axis) {\n                            if (axis.crosshair) {\n                                axis.drawCrosshair(null, hoverPoint);\n                            }\n                        });\n                    }\n                }\n\n            // Full reset\n            } else {\n\n                if (hoverPoint) {\n                    hoverPoint.onMouseOut();\n                }\n\n                if (hoverPoints) {\n                    each(hoverPoints, function (point) {\n                        point.setState();\n                    });\n                }\n\n                if (hoverSeries) {\n                    hoverSeries.onMouseOut();\n                }\n\n                if (tooltip) {\n                    tooltip.hide(delay);\n                }\n\n                if (pointer._onDocumentMouseMove) {\n                    removeEvent(doc, 'mousemove', pointer._onDocumentMouseMove);\n                    pointer._onDocumentMouseMove = null;\n                }\n\n                // Remove crosshairs\n                each(chart.axes, function (axis) {\n                    axis.hideCrosshair();\n                });\n\n                pointer.hoverX = pointer.prevKDPoint = chart.hoverPoints = chart.hoverPoint = null;\n            }\n        },\n\n        /**\n         * Scale series groups to a certain scale and translation\n         */\n        scaleGroups: function (attribs, clip) {\n\n            var chart = this.chart,\n                seriesAttribs;\n\n            // Scale each series\n            each(chart.series, function (series) {\n                seriesAttribs = attribs || series.getPlotBox(); // #1701\n                if (series.xAxis && series.xAxis.zoomEnabled) {\n                    series.group.attr(seriesAttribs);\n                    if (series.markerGroup) {\n                        series.markerGroup.attr(seriesAttribs);\n                        series.markerGroup.clip(clip ? chart.clipRect : null);\n                    }\n                    if (series.dataLabelsGroup) {\n                        series.dataLabelsGroup.attr(seriesAttribs);\n                    }\n                }\n            });\n\n            // Clip\n            chart.clipRect.attr(clip || chart.clipBox);\n        },\n\n        /**\n         * Start a drag operation\n         */\n        dragStart: function (e) {\n            var chart = this.chart;\n\n            // Record the start position\n            chart.mouseIsDown = e.type;\n            chart.cancelClick = false;\n            chart.mouseDownX = this.mouseDownX = e.chartX;\n            chart.mouseDownY = this.mouseDownY = e.chartY;\n        },\n\n        /**\n         * Perform a drag operation in response to a mousemove event while the mouse is down\n         */\n        drag: function (e) {\n\n            var chart = this.chart,\n                chartOptions = chart.options.chart,\n                chartX = e.chartX,\n                chartY = e.chartY,\n                zoomHor = this.zoomHor,\n                zoomVert = this.zoomVert,\n                plotLeft = chart.plotLeft,\n                plotTop = chart.plotTop,\n                plotWidth = chart.plotWidth,\n                plotHeight = chart.plotHeight,\n                clickedInside,\n                size,\n                selectionMarker = this.selectionMarker,\n                mouseDownX = this.mouseDownX,\n                mouseDownY = this.mouseDownY,\n                panKey = chartOptions.panKey && e[chartOptions.panKey + 'Key'];\n\n            // If the device supports both touch and mouse (like IE11), and we are touch-dragging\n            // inside the plot area, don't handle the mouse event. #4339.\n            if (selectionMarker && selectionMarker.touch) {\n                return;\n            }\n\n            // If the mouse is outside the plot area, adjust to cooordinates\n            // inside to prevent the selection marker from going outside\n            if (chartX < plotLeft) {\n                chartX = plotLeft;\n            } else if (chartX > plotLeft + plotWidth) {\n                chartX = plotLeft + plotWidth;\n            }\n\n            if (chartY < plotTop) {\n                chartY = plotTop;\n            } else if (chartY > plotTop + plotHeight) {\n                chartY = plotTop + plotHeight;\n            }\n\n            // determine if the mouse has moved more than 10px\n            this.hasDragged = Math.sqrt(\n                Math.pow(mouseDownX - chartX, 2) +\n                Math.pow(mouseDownY - chartY, 2)\n            );\n\n            if (this.hasDragged > 10) {\n                clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);\n\n                // make a selection\n                if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {\n                    if (!selectionMarker) {\n                        this.selectionMarker = selectionMarker = chart.renderer.rect(\n                            plotLeft,\n                            plotTop,\n                            zoomHor ? 1 : plotWidth,\n                            zoomVert ? 1 : plotHeight,\n                            0\n                        )\n                        .attr({\n                            fill: chartOptions.selectionMarkerFill || 'rgba(69,114,167,0.25)',\n                            zIndex: 7\n                        })\n                        .add();\n                    }\n                }\n\n                // adjust the width of the selection marker\n                if (selectionMarker && zoomHor) {\n                    size = chartX - mouseDownX;\n                    selectionMarker.attr({\n                        width: mathAbs(size),\n                        x: (size > 0 ? 0 : size) + mouseDownX\n                    });\n                }\n                // adjust the height of the selection marker\n                if (selectionMarker && zoomVert) {\n                    size = chartY - mouseDownY;\n                    selectionMarker.attr({\n                        height: mathAbs(size),\n                        y: (size > 0 ? 0 : size) + mouseDownY\n                    });\n                }\n\n                // panning\n                if (clickedInside && !selectionMarker && chartOptions.panning) {\n                    chart.pan(e, chartOptions.panning);\n                }\n            }\n        },\n\n        /**\n         * On mouse up or touch end across the entire document, drop the selection.\n         */\n        drop: function (e) {\n            var pointer = this,\n                chart = this.chart,\n                hasPinched = this.hasPinched;\n\n            if (this.selectionMarker) {\n                var selectionData = {\n                        originalEvent: e, // #4890\n                        xAxis: [],\n                        yAxis: []\n                    },\n                    selectionBox = this.selectionMarker,\n                    selectionLeft = selectionBox.attr ? selectionBox.attr('x') : selectionBox.x,\n                    selectionTop = selectionBox.attr ? selectionBox.attr('y') : selectionBox.y,\n                    selectionWidth = selectionBox.attr ? selectionBox.attr('width') : selectionBox.width,\n                    selectionHeight = selectionBox.attr ? selectionBox.attr('height') : selectionBox.height,\n                    runZoom;\n\n                // a selection has been made\n                if (this.hasDragged || hasPinched) {\n\n                    // record each axis' min and max\n                    each(chart.axes, function (axis) {\n                        if (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{ xAxis: 'zoomX', yAxis: 'zoomY' }[axis.coll]])) { // #859, #3569\n                            var horiz = axis.horiz,\n                                minPixelPadding = e.type === 'touchend' ? axis.minPixelPadding : 0, // #1207, #3075\n                                selectionMin = axis.toValue((horiz ? selectionLeft : selectionTop) + minPixelPadding),\n                                selectionMax = axis.toValue((horiz ? selectionLeft + selectionWidth : selectionTop + selectionHeight) - minPixelPadding);\n\n                            selectionData[axis.coll].push({\n                                axis: axis,\n                                min: mathMin(selectionMin, selectionMax), // for reversed axes\n                                max: mathMax(selectionMin, selectionMax)\n                            });\n                            runZoom = true;\n                        }\n                    });\n                    if (runZoom) {\n                        fireEvent(chart, 'selection', selectionData, function (args) {\n                            chart.zoom(extend(args, hasPinched ? { animation: false } : null));\n                        });\n                    }\n\n                }\n                this.selectionMarker = this.selectionMarker.destroy();\n\n                // Reset scaling preview\n                if (hasPinched) {\n                    this.scaleGroups();\n                }\n            }\n\n            // Reset all\n            if (chart) { // it may be destroyed on mouse up - #877\n                css(chart.container, { cursor: chart._cursor });\n                chart.cancelClick = this.hasDragged > 10; // #370\n                chart.mouseIsDown = this.hasDragged = this.hasPinched = false;\n                this.pinchDown = [];\n            }\n        },\n\n        onContainerMouseDown: function (e) {\n\n            e = this.normalize(e);\n\n            // issue #295, dragging not always working in Firefox\n            if (e.preventDefault) {\n                e.preventDefault();\n            }\n\n            this.dragStart(e);\n        },\n\n\n\n        onDocumentMouseUp: function (e) {\n            if (charts[hoverChartIndex]) {\n                charts[hoverChartIndex].pointer.drop(e);\n            }\n        },\n\n        /**\n         * Special handler for mouse move that will hide the tooltip when the mouse leaves the plotarea.\n         * Issue #149 workaround. The mouseleave event does not always fire.\n         */\n        onDocumentMouseMove: function (e) {\n            var chart = this.chart,\n                chartPosition = this.chartPosition;\n\n            e = this.normalize(e, chartPosition);\n\n            // If we're outside, hide the tooltip\n            if (chartPosition && !this.inClass(e.target, 'highcharts-tracker') &&\n                    !chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {\n                this.reset();\n            }\n        },\n\n        /**\n         * When mouse leaves the container, hide the tooltip.\n         */\n        onContainerMouseLeave: function (e) {\n            var chart = charts[hoverChartIndex];\n            if (chart && (e.relatedTarget || e.toElement)) { // #4886, MS Touch end fires mouseleave but with no related target\n                chart.pointer.reset();\n                chart.pointer.chartPosition = null; // also reset the chart position, used in #149 fix\n            }\n        },\n\n        // The mousemove, touchmove and touchstart event handler\n        onContainerMouseMove: function (e) {\n\n            var chart = this.chart;\n\n            if (!defined(hoverChartIndex) || !charts[hoverChartIndex] || !charts[hoverChartIndex].mouseIsDown) {\n                hoverChartIndex = chart.index;\n            }\n\n            e = this.normalize(e);\n            e.returnValue = false; // #2251, #3224\n\n            if (chart.mouseIsDown === 'mousedown') {\n                this.drag(e);\n            }\n\n            // Show the tooltip and run mouse over events (#977)\n            if ((this.inClass(e.target, 'highcharts-tracker') ||\n                    chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {\n                this.runPointActions(e);\n            }\n        },\n\n        /**\n         * Utility to detect whether an element has, or has a parent with, a specific\n         * class name. Used on detection of tracker objects and on deciding whether\n         * hovering the tooltip should cause the active series to mouse out.\n         */\n        inClass: function (element, className) {\n            var elemClassName;\n            while (element) {\n                elemClassName = attr(element, 'class');\n                if (elemClassName) {\n                    if (elemClassName.indexOf(className) !== -1) {\n                        return true;\n                    }\n                    if (elemClassName.indexOf(PREFIX + 'container') !== -1) {\n                        return false;\n                    }\n                }\n                element = element.parentNode;\n            }\n        },\n\n        onTrackerMouseOut: function (e) {\n            var series = this.chart.hoverSeries,\n                relatedTarget = e.relatedTarget || e.toElement;\n\n            if (series && relatedTarget && !series.options.stickyTracking && // #4886\n                    !this.inClass(relatedTarget, PREFIX + 'tooltip') &&\n                    !this.inClass(relatedTarget, PREFIX + 'series-' + series.index)) { // #2499, #4465\n                series.onMouseOut();\n            }\n        },\n\n        onContainerClick: function (e) {\n            var chart = this.chart,\n                hoverPoint = chart.hoverPoint,\n                plotLeft = chart.plotLeft,\n                plotTop = chart.plotTop;\n\n            e = this.normalize(e);\n\n            if (!chart.cancelClick) {\n\n                // On tracker click, fire the series and point events. #783, #1583\n                if (hoverPoint && this.inClass(e.target, PREFIX + 'tracker')) {\n\n                    // the series click event\n                    fireEvent(hoverPoint.series, 'click', extend(e, {\n                        point: hoverPoint\n                    }));\n\n                    // the point click event\n                    if (chart.hoverPoint) { // it may be destroyed (#1844)\n                        hoverPoint.firePointEvent('click', e);\n                    }\n\n                // When clicking outside a tracker, fire a chart event\n                } else {\n                    extend(e, this.getCoordinates(e));\n\n                    // fire a click event in the chart\n                    if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {\n                        fireEvent(chart, 'click', e);\n                    }\n                }\n\n\n            }\n        },\n\n        /**\n         * Set the JS DOM events on the container and document. This method should contain\n         * a one-to-one assignment between methods and their handlers. Any advanced logic should\n         * be moved to the handler reflecting the event's name.\n         */\n        setDOMEvents: function () {\n\n            var pointer = this,\n                container = pointer.chart.container;\n\n            container.onmousedown = function (e) {\n                pointer.onContainerMouseDown(e);\n            };\n            container.onmousemove = function (e) {\n                pointer.onContainerMouseMove(e);\n            };\n            container.onclick = function (e) {\n                pointer.onContainerClick(e);\n            };\n            addEvent(container, 'mouseleave', pointer.onContainerMouseLeave);\n            if (chartCount === 1) {\n                addEvent(doc, 'mouseup', pointer.onDocumentMouseUp);\n            }\n            if (hasTouch) {\n                container.ontouchstart = function (e) {\n                    pointer.onContainerTouchStart(e);\n                };\n                container.ontouchmove = function (e) {\n                    pointer.onContainerTouchMove(e);\n                };\n                if (chartCount === 1) {\n                    addEvent(doc, 'touchend', pointer.onDocumentTouchEnd);\n                }\n            }\n\n        },\n\n        /**\n         * Destroys the Pointer object and disconnects DOM events.\n         */\n        destroy: function () {\n            var prop;\n\n            removeEvent(this.chart.container, 'mouseleave', this.onContainerMouseLeave);\n            if (!chartCount) {\n                removeEvent(doc, 'mouseup', this.onDocumentMouseUp);\n                removeEvent(doc, 'touchend', this.onDocumentTouchEnd);\n            }\n\n            // memory and CPU leak\n            clearInterval(this.tooltipTimeout);\n\n            for (prop in this) {\n                this[prop] = null;\n            }\n        }\n    };\n\n\n    /* Support for touch devices */\n    extend(Highcharts.Pointer.prototype, {\n\n        /**\n         * Run translation operations\n         */\n        pinchTranslate: function (pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {\n            if (this.zoomHor || this.pinchHor) {\n                this.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n            }\n            if (this.zoomVert || this.pinchVert) {\n                this.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n            }\n        },\n\n        /**\n         * Run translation operations for each direction (horizontal and vertical) independently\n         */\n        pinchTranslateDirection: function (horiz, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch, forcedScale) {\n            var chart = this.chart,\n                xy = horiz ? 'x' : 'y',\n                XY = horiz ? 'X' : 'Y',\n                sChartXY = 'chart' + XY,\n                wh = horiz ? 'width' : 'height',\n                plotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')],\n                selectionWH,\n                selectionXY,\n                clipXY,\n                scale = forcedScale || 1,\n                inverted = chart.inverted,\n                bounds = chart.bounds[horiz ? 'h' : 'v'],\n                singleTouch = pinchDown.length === 1,\n                touch0Start = pinchDown[0][sChartXY],\n                touch0Now = touches[0][sChartXY],\n                touch1Start = !singleTouch && pinchDown[1][sChartXY],\n                touch1Now = !singleTouch && touches[1][sChartXY],\n                outOfBounds,\n                transformScale,\n                scaleKey,\n                setScale = function () {\n                    if (!singleTouch && mathAbs(touch0Start - touch1Start) > 20) { // Don't zoom if fingers are too close on this axis\n                        scale = forcedScale || mathAbs(touch0Now - touch1Now) / mathAbs(touch0Start - touch1Start);\n                    }\n\n                    clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;\n                    selectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] / scale;\n                };\n\n            // Set the scale, first pass\n            setScale();\n\n            selectionXY = clipXY; // the clip position (x or y) is altered if out of bounds, the selection position is not\n\n            // Out of bounds\n            if (selectionXY < bounds.min) {\n                selectionXY = bounds.min;\n                outOfBounds = true;\n            } else if (selectionXY + selectionWH > bounds.max) {\n                selectionXY = bounds.max - selectionWH;\n                outOfBounds = true;\n            }\n\n            // Is the chart dragged off its bounds, determined by dataMin and dataMax?\n            if (outOfBounds) {\n\n                // Modify the touchNow position in order to create an elastic drag movement. This indicates\n                // to the user that the chart is responsive but can't be dragged further.\n                touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);\n                if (!singleTouch) {\n                    touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);\n                }\n\n                // Set the scale, second pass to adapt to the modified touchNow positions\n                setScale();\n\n            } else {\n                lastValidTouch[xy] = [touch0Now, touch1Now];\n            }\n\n            // Set geometry for clipping, selection and transformation\n            if (!inverted) {\n                clip[xy] = clipXY - plotLeftTop;\n                clip[wh] = selectionWH;\n            }\n            scaleKey = inverted ? (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;\n            transformScale = inverted ? 1 / scale : scale;\n\n            selectionMarker[wh] = selectionWH;\n            selectionMarker[xy] = selectionXY;\n            transform[scaleKey] = scale;\n            transform['translate' + XY] = (transformScale * plotLeftTop) + (touch0Now - (transformScale * touch0Start));\n        },\n\n        /**\n         * Handle touch events with two touches\n         */\n        pinch: function (e) {\n\n            var self = this,\n                chart = self.chart,\n                pinchDown = self.pinchDown,\n                touches = e.touches,\n                touchesLength = touches.length,\n                lastValidTouch = self.lastValidTouch,\n                hasZoom = self.hasZoom,\n                selectionMarker = self.selectionMarker,\n                transform = {},\n                fireClickEvent = touchesLength === 1 && ((self.inClass(e.target, PREFIX + 'tracker') &&\n                    chart.runTrackerClick) || self.runChartClick),\n                clip = {};\n\n            // Don't initiate panning until the user has pinched. This prevents us from\n            // blocking page scrolling as users scroll down a long page (#4210).\n            if (touchesLength > 1) {\n                self.initiated = true;\n            }\n\n            // On touch devices, only proceed to trigger click if a handler is defined\n            if (hasZoom && self.initiated && !fireClickEvent) {\n                e.preventDefault();\n            }\n\n            // Normalize each touch\n            map(touches, function (e) {\n                return self.normalize(e);\n            });\n\n            // Register the touch start position\n            if (e.type === 'touchstart') {\n                each(touches, function (e, i) {\n                    pinchDown[i] = { chartX: e.chartX, chartY: e.chartY };\n                });\n                lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];\n                lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];\n\n                // Identify the data bounds in pixels\n                each(chart.axes, function (axis) {\n                    if (axis.zoomEnabled) {\n                        var bounds = chart.bounds[axis.horiz ? 'h' : 'v'],\n                            minPixelPadding = axis.minPixelPadding,\n                            min = axis.toPixels(pick(axis.options.min, axis.dataMin)),\n                            max = axis.toPixels(pick(axis.options.max, axis.dataMax)),\n                            absMin = mathMin(min, max),\n                            absMax = mathMax(min, max);\n\n                        // Store the bounds for use in the touchmove handler\n                        bounds.min = mathMin(axis.pos, absMin - minPixelPadding);\n                        bounds.max = mathMax(axis.pos + axis.len, absMax + minPixelPadding);\n                    }\n                });\n                self.res = true; // reset on next move\n\n            // Event type is touchmove, handle panning and pinching\n            } else if (pinchDown.length) { // can be 0 when releasing, if touchend fires first\n\n\n                // Set the marker\n                if (!selectionMarker) {\n                    self.selectionMarker = selectionMarker = extend({\n                        destroy: noop,\n                        touch: true\n                    }, chart.plotBox);\n                }\n\n                self.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n\n                self.hasPinched = hasZoom;\n\n                // Scale and translate the groups to provide visual feedback during pinching\n                self.scaleGroups(transform, clip);\n\n                // Optionally move the tooltip on touchmove\n                if (!hasZoom && self.followTouchMove && touchesLength === 1) {\n                    this.runPointActions(self.normalize(e));\n                } else if (self.res) {\n                    self.res = false;\n                    this.reset(false, 0);\n                }\n            }\n        },\n\n        /**\n         * General touch handler shared by touchstart and touchmove.\n         */\n        touch: function (e, start) {\n            var chart = this.chart,\n                hasMoved,\n                pinchDown;\n\n            hoverChartIndex = chart.index;\n\n            if (e.touches.length === 1) {\n\n                e = this.normalize(e);\n\n                if (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop) && !chart.openMenu) {\n\n                    // Run mouse events and display tooltip etc\n                    if (start) {\n                        this.runPointActions(e);\n                    }\n\n                    // Android fires touchmove events after the touchstart even if the\n                    // finger hasn't moved, or moved only a pixel or two. In iOS however,\n                    // the touchmove doesn't fire unless the finger moves more than ~4px.\n                    // So we emulate this behaviour in Android by checking how much it\n                    // moved, and cancelling on small distances. #3450.\n                    if (e.type === 'touchmove') {\n                        pinchDown = this.pinchDown;\n                        hasMoved = pinchDown[0] ? Math.sqrt( // #5266\n                            Math.pow(pinchDown[0].chartX - e.chartX, 2) +\n                            Math.pow(pinchDown[0].chartY - e.chartY, 2)\n                        ) >= 4 : false;\n                    }\n\n                    if (pick(hasMoved, true)) {\n                        this.pinch(e);\n                    }\n\n                } else if (start) {\n                    // Hide the tooltip on touching outside the plot area (#1203)\n                    this.reset();\n                }\n\n            } else if (e.touches.length === 2) {\n                this.pinch(e);\n            }\n        },\n\n        onContainerTouchStart: function (e) {\n            this.touch(e, true);\n        },\n\n        onContainerTouchMove: function (e) {\n            this.touch(e);\n        },\n\n        onDocumentTouchEnd: function (e) {\n            if (charts[hoverChartIndex]) {\n                charts[hoverChartIndex].pointer.drop(e);\n            }\n        }\n\n    });\n    if (win.PointerEvent || win.MSPointerEvent) {\n\n        // The touches object keeps track of the points being touched at all times\n        var touches = {},\n            hasPointerEvent = !!win.PointerEvent,\n            getWebkitTouches = function () {\n                var key,\n                    fake = [];\n                fake.item = function (i) {\n                    return this[i];\n                };\n                for (key in touches) {\n                    if (touches.hasOwnProperty(key)) {\n                        fake.push({\n                            pageX: touches[key].pageX,\n                            pageY: touches[key].pageY,\n                            target: touches[key].target\n                        });\n                    }\n                }\n                return fake;\n            },\n            translateMSPointer = function (e, method, wktype, func) {\n                var p;\n                if ((e.pointerType === 'touch' || e.pointerType === e.MSPOINTER_TYPE_TOUCH) && charts[hoverChartIndex]) {\n                    func(e);\n                    p = charts[hoverChartIndex].pointer;\n                    p[method]({\n                        type: wktype,\n                        target: e.currentTarget,\n                        preventDefault: noop,\n                        touches: getWebkitTouches()\n                    });\n                }\n            };\n\n        /**\n         * Extend the Pointer prototype with methods for each event handler and more\n         */\n        extend(Pointer.prototype, {\n            onContainerPointerDown: function (e) {\n                translateMSPointer(e, 'onContainerTouchStart', 'touchstart', function (e) {\n                    touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY, target: e.currentTarget };\n                });\n            },\n            onContainerPointerMove: function (e) {\n                translateMSPointer(e, 'onContainerTouchMove', 'touchmove', function (e) {\n                    touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY };\n                    if (!touches[e.pointerId].target) {\n                        touches[e.pointerId].target = e.currentTarget;\n                    }\n                });\n            },\n            onDocumentPointerUp: function (e) {\n                translateMSPointer(e, 'onDocumentTouchEnd', 'touchend', function (e) {\n                    delete touches[e.pointerId];\n                });\n            },\n\n            /**\n             * Add or remove the MS Pointer specific events\n             */\n            batchMSEvents: function (fn) {\n                fn(this.chart.container, hasPointerEvent ? 'pointerdown' : 'MSPointerDown', this.onContainerPointerDown);\n                fn(this.chart.container, hasPointerEvent ? 'pointermove' : 'MSPointerMove', this.onContainerPointerMove);\n                fn(doc, hasPointerEvent ? 'pointerup' : 'MSPointerUp', this.onDocumentPointerUp);\n            }\n        });\n\n        // Disable default IE actions for pinch and such on chart element\n        wrap(Pointer.prototype, 'init', function (proceed, chart, options) {\n            proceed.call(this, chart, options);\n            if (this.hasZoom) { // #4014\n                css(chart.container, {\n                    '-ms-touch-action': NONE,\n                    'touch-action': NONE\n                });\n            }\n        });\n\n        // Add IE specific touch events to chart\n        wrap(Pointer.prototype, 'setDOMEvents', function (proceed) {\n            proceed.apply(this);\n            if (this.hasZoom || this.followTouchMove) {\n                this.batchMSEvents(addEvent);\n            }\n        });\n        // Destroy MS events also\n        wrap(Pointer.prototype, 'destroy', function (proceed) {\n            this.batchMSEvents(removeEvent);\n            proceed.call(this);\n        });\n    }\n    /**\n     * The overview of the chart's series\n     */\n    var Legend = Highcharts.Legend = function (chart, options) {\n        this.init(chart, options);\n    };\n\n    Legend.prototype = {\n\n        /**\n         * Initialize the legend\n         */\n        init: function (chart, options) {\n\n            var legend = this,\n                itemStyle = options.itemStyle,\n                padding,\n                itemMarginTop = options.itemMarginTop || 0;\n\n            this.options = options;\n\n            if (!options.enabled) {\n                return;\n            }\n\n            legend.itemStyle = itemStyle;\n            legend.itemHiddenStyle = merge(itemStyle, options.itemHiddenStyle);\n            legend.itemMarginTop = itemMarginTop;\n            legend.padding = padding = pick(options.padding, 8);\n            legend.initialItemX = padding;\n            legend.initialItemY = padding - 5; // 5 is the number of pixels above the text\n            legend.maxItemWidth = 0;\n            legend.chart = chart;\n            legend.itemHeight = 0;\n            legend.symbolWidth = pick(options.symbolWidth, 16);\n            legend.pages = [];\n\n\n            // Render it\n            legend.render();\n\n            // move checkboxes\n            addEvent(legend.chart, 'endResize', function () {\n                legend.positionCheckboxes();\n            });\n\n        },\n\n        /**\n         * Set the colors for the legend item\n         * @param {Object} item A Series or Point instance\n         * @param {Object} visible Dimmed or colored\n         */\n        colorizeItem: function (item, visible) {\n            var legend = this,\n                options = legend.options,\n                legendItem = item.legendItem,\n                legendLine = item.legendLine,\n                legendSymbol = item.legendSymbol,\n                hiddenColor = legend.itemHiddenStyle.color,\n                textColor = visible ? options.itemStyle.color : hiddenColor,\n                symbolColor = visible ? (item.legendColor || item.color || '#CCC') : hiddenColor,\n                markerOptions = item.options && item.options.marker,\n                symbolAttr = { fill: symbolColor },\n                key,\n                val;\n\n            if (legendItem) {\n                legendItem.css({ fill: textColor, color: textColor }); // color for #1553, oldIE\n            }\n            if (legendLine) {\n                legendLine.attr({ stroke: symbolColor });\n            }\n\n            if (legendSymbol) {\n\n                // Apply marker options\n                if (markerOptions && legendSymbol.isMarker) { // #585\n                    symbolAttr.stroke = symbolColor;\n                    markerOptions = item.convertAttribs(markerOptions);\n                    for (key in markerOptions) {\n                        val = markerOptions[key];\n                        if (val !== UNDEFINED) {\n                            symbolAttr[key] = val;\n                        }\n                    }\n                }\n\n                legendSymbol.attr(symbolAttr);\n            }\n        },\n\n        /**\n         * Position the legend item\n         * @param {Object} item A Series or Point instance\n         */\n        positionItem: function (item) {\n            var legend = this,\n                options = legend.options,\n                symbolPadding = options.symbolPadding,\n                ltr = !options.rtl,\n                legendItemPos = item._legendItemPos,\n                itemX = legendItemPos[0],\n                itemY = legendItemPos[1],\n                checkbox = item.checkbox,\n                legendGroup = item.legendGroup;\n\n            if (legendGroup && legendGroup.element) {\n                legendGroup.translate(\n                    ltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4,\n                    itemY\n                );\n            }\n\n            if (checkbox) {\n                checkbox.x = itemX;\n                checkbox.y = itemY;\n            }\n        },\n\n        /**\n         * Destroy a single legend item\n         * @param {Object} item The series or point\n         */\n        destroyItem: function (item) {\n            var checkbox = item.checkbox;\n\n            // destroy SVG elements\n            each(['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'], function (key) {\n                if (item[key]) {\n                    item[key] = item[key].destroy();\n                }\n            });\n\n            if (checkbox) {\n                discardElement(item.checkbox);\n            }\n        },\n\n        /**\n         * Destroys the legend.\n         */\n        destroy: function () {\n            var legend = this,\n                legendGroup = legend.group,\n                box = legend.box;\n\n            if (box) {\n                legend.box = box.destroy();\n            }\n\n            if (legendGroup) {\n                legend.group = legendGroup.destroy();\n            }\n        },\n\n        /**\n         * Position the checkboxes after the width is determined\n         */\n        positionCheckboxes: function (scrollOffset) {\n            var alignAttr = this.group.alignAttr,\n                translateY,\n                clipHeight = this.clipHeight || this.legendHeight,\n                titleHeight = this.titleHeight;\n\n            if (alignAttr) {\n                translateY = alignAttr.translateY;\n                each(this.allItems, function (item) {\n                    var checkbox = item.checkbox,\n                        top;\n\n                    if (checkbox) {\n                        top = translateY + titleHeight + checkbox.y + (scrollOffset || 0) + 3;\n                        css(checkbox, {\n                            left: (alignAttr.translateX + item.checkboxOffset + checkbox.x - 20) + PX,\n                            top: top + PX,\n                            display: top > translateY - 6 && top < translateY + clipHeight - 6 ? '' : NONE\n                        });\n                    }\n                });\n            }\n        },\n\n        /**\n         * Render the legend title on top of the legend\n         */\n        renderTitle: function () {\n            var options = this.options,\n                padding = this.padding,\n                titleOptions = options.title,\n                titleHeight = 0,\n                bBox;\n\n            if (titleOptions.text) {\n                if (!this.title) {\n                    this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, null, null, 'legend-title')\n                        .attr({ zIndex: 1 })\n                        .css(titleOptions.style)\n                        .add(this.group);\n                }\n                bBox = this.title.getBBox();\n                titleHeight = bBox.height;\n                this.offsetWidth = bBox.width; // #1717\n                this.contentGroup.attr({ translateY: titleHeight });\n            }\n            this.titleHeight = titleHeight;\n        },\n\n        /**\n         * Set the legend item text\n         */\n        setText: function (item) {\n            var options = this.options;\n            item.legendItem.attr({\n                text: options.labelFormat ? format(options.labelFormat, item) : options.labelFormatter.call(item)\n            });\n        },\n\n        /**\n         * Render a single specific legend item\n         * @param {Object} item A series or point\n         */\n        renderItem: function (item) {\n            var legend = this,\n                chart = legend.chart,\n                renderer = chart.renderer,\n                options = legend.options,\n                horizontal = options.layout === 'horizontal',\n                symbolWidth = legend.symbolWidth,\n                symbolPadding = options.symbolPadding,\n                itemStyle = legend.itemStyle,\n                itemHiddenStyle = legend.itemHiddenStyle,\n                padding = legend.padding,\n                itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,\n                ltr = !options.rtl,\n                itemHeight,\n                widthOption = options.width,\n                itemMarginBottom = options.itemMarginBottom || 0,\n                itemMarginTop = legend.itemMarginTop,\n                initialItemX = legend.initialItemX,\n                bBox,\n                itemWidth,\n                li = item.legendItem,\n                series = item.series && item.series.drawLegendSymbol ? item.series : item,\n                seriesOptions = series.options,\n                showCheckbox = legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox,\n                useHTML = options.useHTML;\n\n            if (!li) { // generate it once, later move it\n\n                // Generate the group box\n                // A group to hold the symbol and text. Text is to be appended in Legend class.\n                item.legendGroup = renderer.g('legend-item')\n                    .attr({ zIndex: 1 })\n                    .add(legend.scrollGroup);\n\n                // Generate the list item text and add it to the group\n                item.legendItem = li = renderer.text(\n                        '',\n                        ltr ? symbolWidth + symbolPadding : -symbolPadding,\n                        legend.baseline || 0,\n                        useHTML\n                    )\n                    .css(merge(item.visible ? itemStyle : itemHiddenStyle)) // merge to prevent modifying original (#1021)\n                    .attr({\n                        align: ltr ? 'left' : 'right',\n                        zIndex: 2\n                    })\n                    .add(item.legendGroup);\n\n                // Get the baseline for the first item - the font size is equal for all\n                if (!legend.baseline) {\n                    legend.fontMetrics = renderer.fontMetrics(itemStyle.fontSize, li);\n                    legend.baseline = legend.fontMetrics.f + 3 + itemMarginTop;\n                    li.attr('y', legend.baseline);\n                }\n\n                // Draw the legend symbol inside the group box\n                series.drawLegendSymbol(legend, item);\n\n                if (legend.setItemEvents) {\n                    legend.setItemEvents(item, li, useHTML, itemStyle, itemHiddenStyle);\n                }\n\n                // add the HTML checkbox on top\n                if (showCheckbox) {\n                    legend.createCheckboxForItem(item);\n                }\n            }\n\n            // Colorize the items\n            legend.colorizeItem(item, item.visible);\n\n            // Always update the text\n            legend.setText(item);\n\n            // calculate the positions for the next line\n            bBox = li.getBBox();\n\n            itemWidth = item.checkboxOffset =\n                options.itemWidth ||\n                item.legendItemWidth ||\n                symbolWidth + symbolPadding + bBox.width + itemDistance + (showCheckbox ? 20 : 0);\n            legend.itemHeight = itemHeight = mathRound(item.legendItemHeight || bBox.height);\n\n            // if the item exceeds the width, start a new line\n            if (horizontal && legend.itemX - initialItemX + itemWidth >\n                    (widthOption || (chart.chartWidth - 2 * padding - initialItemX - options.x))) {\n                legend.itemX = initialItemX;\n                legend.itemY += itemMarginTop + legend.lastLineHeight + itemMarginBottom;\n                legend.lastLineHeight = 0; // reset for next line (#915, #3976)\n            }\n\n            // If the item exceeds the height, start a new column\n            /*if (!horizontal && legend.itemY + options.y + itemHeight > chart.chartHeight - spacingTop - spacingBottom) {\n                legend.itemY = legend.initialItemY;\n                legend.itemX += legend.maxItemWidth;\n                legend.maxItemWidth = 0;\n            }*/\n\n            // Set the edge positions\n            legend.maxItemWidth = mathMax(legend.maxItemWidth, itemWidth);\n            legend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;\n            legend.lastLineHeight = mathMax(itemHeight, legend.lastLineHeight); // #915\n\n            // cache the position of the newly generated or reordered items\n            item._legendItemPos = [legend.itemX, legend.itemY];\n\n            // advance\n            if (horizontal) {\n                legend.itemX += itemWidth;\n\n            } else {\n                legend.itemY += itemMarginTop + itemHeight + itemMarginBottom;\n                legend.lastLineHeight = itemHeight;\n            }\n\n            // the width of the widest item\n            legend.offsetWidth = widthOption || mathMax(\n                (horizontal ? legend.itemX - initialItemX - itemDistance : itemWidth) + padding,\n                legend.offsetWidth\n            );\n        },\n\n        /**\n         * Get all items, which is one item per series for normal series and one item per point\n         * for pie series.\n         */\n        getAllItems: function () {\n            var allItems = [];\n            each(this.chart.series, function (series) {\n                var seriesOptions = series.options;\n\n                // Handle showInLegend. If the series is linked to another series, defaults to false.\n                if (!pick(seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? UNDEFINED : false, true)) {\n                    return;\n                }\n\n                // use points or series for the legend item depending on legendType\n                allItems = allItems.concat(\n                        series.legendItems ||\n                        (seriesOptions.legendType === 'point' ?\n                                series.data :\n                                series)\n                );\n            });\n            return allItems;\n        },\n\n        /**\n         * Adjust the chart margins by reserving space for the legend on only one side\n         * of the chart. If the position is set to a corner, top or bottom is reserved\n         * for horizontal legends and left or right for vertical ones.\n         */\n        adjustMargins: function (margin, spacing) {\n            var chart = this.chart,\n                options = this.options,\n                // Use the first letter of each alignment option in order to detect the side\n                alignment = options.align.charAt(0) + options.verticalAlign.charAt(0) + options.layout.charAt(0); // #4189 - use charAt(x) notation instead of [x] for IE7\n\n            if (!options.floating) {\n\n                each([\n                    /(lth|ct|rth)/,\n                    /(rtv|rm|rbv)/,\n                    /(rbh|cb|lbh)/,\n                    /(lbv|lm|ltv)/\n                ], function (alignments, side) {\n                    if (alignments.test(alignment) && !defined(margin[side])) {\n                        // Now we have detected on which side of the chart we should reserve space for the legend\n                        chart[marginNames[side]] = mathMax(\n                            chart[marginNames[side]],\n                            chart.legend[(side + 1) % 2 ? 'legendHeight' : 'legendWidth'] +\n                                [1, -1, -1, 1][side] * options[(side % 2) ? 'x' : 'y'] +\n                                pick(options.margin, 12) +\n                                spacing[side]\n                        );\n                    }\n                });\n            }\n        },\n\n        /**\n         * Render the legend. This method can be called both before and after\n         * chart.render. If called after, it will only rearrange items instead\n         * of creating new ones.\n         */\n        render: function () {\n            var legend = this,\n                chart = legend.chart,\n                renderer = chart.renderer,\n                legendGroup = legend.group,\n                allItems,\n                display,\n                legendWidth,\n                legendHeight,\n                box = legend.box,\n                options = legend.options,\n                padding = legend.padding,\n                legendBorderWidth = options.borderWidth,\n                legendBackgroundColor = options.backgroundColor;\n\n            legend.itemX = legend.initialItemX;\n            legend.itemY = legend.initialItemY;\n            legend.offsetWidth = 0;\n            legend.lastItemY = 0;\n\n            if (!legendGroup) {\n                legend.group = legendGroup = renderer.g('legend')\n                    .attr({ zIndex: 7 })\n                    .add();\n                legend.contentGroup = renderer.g()\n                    .attr({ zIndex: 1 }) // above background\n                    .add(legendGroup);\n                legend.scrollGroup = renderer.g()\n                    .add(legend.contentGroup);\n            }\n\n            legend.renderTitle();\n\n            // add each series or point\n            allItems = legend.getAllItems();\n\n            // sort by legendIndex\n            stableSort(allItems, function (a, b) {\n                return ((a.options && a.options.legendIndex) || 0) - ((b.options && b.options.legendIndex) || 0);\n            });\n\n            // reversed legend\n            if (options.reversed) {\n                allItems.reverse();\n            }\n\n            legend.allItems = allItems;\n            legend.display = display = !!allItems.length;\n\n            // render the items\n            legend.lastLineHeight = 0;\n            each(allItems, function (item) {\n                legend.renderItem(item);\n            });\n\n            // Get the box\n            legendWidth = (options.width || legend.offsetWidth) + padding;\n            legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;\n            legendHeight = legend.handleOverflow(legendHeight);\n            legendHeight += padding;\n\n            // Draw the border and/or background\n            if (legendBorderWidth || legendBackgroundColor) {\n\n                if (!box) {\n                    legend.box = box = renderer.rect(\n                        0,\n                        0,\n                        legendWidth,\n                        legendHeight,\n                        options.borderRadius,\n                        legendBorderWidth || 0\n                    ).attr({\n                        stroke: options.borderColor,\n                        'stroke-width': legendBorderWidth || 0,\n                        fill: legendBackgroundColor || NONE\n                    })\n                    .add(legendGroup)\n                    .shadow(options.shadow);\n                    box.isNew = true;\n\n                } else if (legendWidth > 0 && legendHeight > 0) {\n                    box[box.isNew ? 'attr' : 'animate'](\n                        box.crisp({ width: legendWidth, height: legendHeight })\n                    );\n                    box.isNew = false;\n                }\n\n                // hide the border if no items\n                box[display ? 'show' : 'hide']();\n            }\n\n            legend.legendWidth = legendWidth;\n            legend.legendHeight = legendHeight;\n\n            // Now that the legend width and height are established, put the items in the\n            // final position\n            each(allItems, function (item) {\n                legend.positionItem(item);\n            });\n\n            // 1.x compatibility: positioning based on style\n            /*var props = ['left', 'right', 'top', 'bottom'],\n                prop,\n                i = 4;\n            while (i--) {\n                prop = props[i];\n                if (options.style[prop] && options.style[prop] !== 'auto') {\n                    options[i < 2 ? 'align' : 'verticalAlign'] = prop;\n                    options[i < 2 ? 'x' : 'y'] = pInt(options.style[prop]) * (i % 2 ? -1 : 1);\n                }\n            }*/\n\n            if (display) {\n                legendGroup.align(extend({\n                    width: legendWidth,\n                    height: legendHeight\n                }, options), true, 'spacingBox');\n            }\n\n            if (!chart.isResizing) {\n                this.positionCheckboxes();\n            }\n        },\n\n        /**\n         * Set up the overflow handling by adding navigation with up and down arrows below the\n         * legend.\n         */\n        handleOverflow: function (legendHeight) {\n            var legend = this,\n                chart = this.chart,\n                renderer = chart.renderer,\n                options = this.options,\n                optionsY = options.y,\n                alignTop = options.verticalAlign === 'top',\n                spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - this.padding,\n                maxHeight = options.maxHeight,\n                clipHeight,\n                clipRect = this.clipRect,\n                navOptions = options.navigation,\n                animation = pick(navOptions.animation, true),\n                arrowSize = navOptions.arrowSize || 12,\n                nav = this.nav,\n                pages = this.pages,\n                padding = this.padding,\n                lastY,\n                allItems = this.allItems,\n                clipToHeight = function (height) {\n                    clipRect.attr({\n                        height: height\n                    });\n\n                    // useHTML\n                    if (legend.contentGroup.div) {\n                        legend.contentGroup.div.style.clip = 'rect(' + padding + 'px,9999px,' + (padding + height) + 'px,0)';\n                    }\n                };\n\n\n            // Adjust the height\n            if (options.layout === 'horizontal') {\n                spaceHeight /= 2;\n            }\n            if (maxHeight) {\n                spaceHeight = mathMin(spaceHeight, maxHeight);\n            }\n\n            // Reset the legend height and adjust the clipping rectangle\n            pages.length = 0;\n            if (legendHeight > spaceHeight && navOptions.enabled !== false) {\n\n                this.clipHeight = clipHeight = mathMax(spaceHeight - 20 - this.titleHeight - padding, 0);\n                this.currentPage = pick(this.currentPage, 1);\n                this.fullHeight = legendHeight;\n\n                // Fill pages with Y positions so that the top of each a legend item defines\n                // the scroll top for each page (#2098)\n                each(allItems, function (item, i) {\n                    var y = item._legendItemPos[1],\n                        h = mathRound(item.legendItem.getBBox().height),\n                        len = pages.length;\n\n                    if (!len || (y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1])) {\n                        pages.push(lastY || y);\n                        len++;\n                    }\n\n                    if (i === allItems.length - 1 && y + h - pages[len - 1] > clipHeight) {\n                        pages.push(y);\n                    }\n                    if (y !== lastY) {\n                        lastY = y;\n                    }\n                });\n\n                // Only apply clipping if needed. Clipping causes blurred legend in PDF export (#1787)\n                if (!clipRect) {\n                    clipRect = legend.clipRect = renderer.clipRect(0, padding, 9999, 0);\n                    legend.contentGroup.clip(clipRect);\n                }\n\n                clipToHeight(clipHeight);\n\n                // Add navigation elements\n                if (!nav) {\n                    this.nav = nav = renderer.g().attr({ zIndex: 1 }).add(this.group);\n                    this.up = renderer.symbol('triangle', 0, 0, arrowSize, arrowSize)\n                        .on('click', function () {\n                            legend.scroll(-1, animation);\n                        })\n                        .add(nav);\n                    this.pager = renderer.text('', 15, 10)\n                        .css(navOptions.style)\n                        .add(nav);\n                    this.down = renderer.symbol('triangle-down', 0, 0, arrowSize, arrowSize)\n                        .on('click', function () {\n                            legend.scroll(1, animation);\n                        })\n                        .add(nav);\n                }\n\n                // Set initial position\n                legend.scroll(0);\n\n                legendHeight = spaceHeight;\n\n            } else if (nav) {\n                clipToHeight(chart.chartHeight);\n                nav.hide();\n                this.scrollGroup.attr({\n                    translateY: 1\n                });\n                this.clipHeight = 0; // #1379\n            }\n\n            return legendHeight;\n        },\n\n        /**\n         * Scroll the legend by a number of pages\n         * @param {Object} scrollBy\n         * @param {Object} animation\n         */\n        scroll: function (scrollBy, animation) {\n            var pages = this.pages,\n                pageCount = pages.length,\n                currentPage = this.currentPage + scrollBy,\n                clipHeight = this.clipHeight,\n                navOptions = this.options.navigation,\n                activeColor = navOptions.activeColor,\n                inactiveColor = navOptions.inactiveColor,\n                pager = this.pager,\n                padding = this.padding,\n                scrollOffset;\n\n            // When resizing while looking at the last page\n            if (currentPage > pageCount) {\n                currentPage = pageCount;\n            }\n\n            if (currentPage > 0) {\n\n                if (animation !== UNDEFINED) {\n                    setAnimation(animation, this.chart);\n                }\n\n                this.nav.attr({\n                    translateX: padding,\n                    translateY: clipHeight + this.padding + 7 + this.titleHeight,\n                    visibility: VISIBLE\n                });\n                this.up.attr({\n                        fill: currentPage === 1 ? inactiveColor : activeColor\n                    })\n                    .css({\n                        cursor: currentPage === 1 ? 'default' : 'pointer'\n                    });\n                pager.attr({\n                    text: currentPage + '/' + pageCount\n                });\n                this.down.attr({\n                        x: 18 + this.pager.getBBox().width, // adjust to text width\n                        fill: currentPage === pageCount ? inactiveColor : activeColor\n                    })\n                    .css({\n                        cursor: currentPage === pageCount ? 'default' : 'pointer'\n                    });\n\n                scrollOffset = -pages[currentPage - 1] + this.initialItemY;\n\n                this.scrollGroup.animate({\n                    translateY: scrollOffset\n                });\n\n                this.currentPage = currentPage;\n                this.positionCheckboxes(scrollOffset);\n            }\n\n        }\n\n    };\n\n    /*\n     * LegendSymbolMixin\n     */\n\n    var LegendSymbolMixin = Highcharts.LegendSymbolMixin = {\n\n        /**\n         * Get the series' symbol in the legend\n         *\n         * @param {Object} legend The legend object\n         * @param {Object} item The series (this) or point\n         */\n        drawRectangle: function (legend, item) {\n            var symbolHeight = legend.options.symbolHeight || legend.fontMetrics.f;\n\n            item.legendSymbol = this.chart.renderer.rect(\n                0,\n                legend.baseline - symbolHeight + 1, // #3988\n                legend.symbolWidth,\n                symbolHeight,\n                legend.options.symbolRadius || 0\n            ).attr({\n                zIndex: 3\n            }).add(item.legendGroup);\n\n        },\n\n        /**\n         * Get the series' symbol in the legend. This method should be overridable to create custom\n         * symbols through Highcharts.seriesTypes[type].prototype.drawLegendSymbols.\n         *\n         * @param {Object} legend The legend object\n         */\n        drawLineMarker: function (legend) {\n\n            var options = this.options,\n                markerOptions = options.marker,\n                radius,\n                legendSymbol,\n                symbolWidth = legend.symbolWidth,\n                renderer = this.chart.renderer,\n                legendItemGroup = this.legendGroup,\n                verticalCenter = legend.baseline - mathRound(legend.fontMetrics.b * 0.3),\n                attr;\n\n            // Draw the line\n            if (options.lineWidth) {\n                attr = {\n                    'stroke-width': options.lineWidth\n                };\n                if (options.dashStyle) {\n                    attr.dashstyle = options.dashStyle;\n                }\n                this.legendLine = renderer.path([\n                    M,\n                    0,\n                    verticalCenter,\n                    L,\n                    symbolWidth,\n                    verticalCenter\n                ])\n                .attr(attr)\n                .add(legendItemGroup);\n            }\n\n            // Draw the marker\n            if (markerOptions && markerOptions.enabled !== false) {\n                radius = markerOptions.radius;\n                this.legendSymbol = legendSymbol = renderer.symbol(\n                    this.symbol,\n                    (symbolWidth / 2) - radius,\n                    verticalCenter - radius,\n                    2 * radius,\n                    2 * radius,\n                    markerOptions\n                )\n                .add(legendItemGroup);\n                legendSymbol.isMarker = true;\n            }\n        }\n    };\n\n    // Workaround for #2030, horizontal legend items not displaying in IE11 Preview,\n    // and for #2580, a similar drawing flaw in Firefox 26.\n    // Explore if there's a general cause for this. The problem may be related\n    // to nested group elements, as the legend item texts are within 4 group elements.\n    if (/Trident\\/7\\.0/.test(userAgent) || isFirefox) {\n        wrap(Legend.prototype, 'positionItem', function (proceed, item) {\n            var legend = this,\n                runPositionItem = function () { // If chart destroyed in sync, this is undefined (#2030)\n                    if (item._legendItemPos) {\n                        proceed.call(legend, item);\n                    }\n                };\n\n            // Do it now, for export and to get checkbox placement\n            runPositionItem();\n\n            // Do it after to work around the core issue\n            setTimeout(runPositionItem);\n        });\n    }\n    /**\n     * The Chart class\n     * @param {String|Object} renderTo The DOM element to render to, or its id\n     * @param {Object} options\n     * @param {Function} callback Function to run when the chart has loaded\n     */\n    var Chart = Highcharts.Chart = function () {\n        this.getArgs.apply(this, arguments);\n    };\n\n    Highcharts.chart = function (a, b, c) {\n        return new Chart(a, b, c);\n    };\n\n    Chart.prototype = {\n\n        /**\n         * Hook for modules\n         */\n        callbacks: [],\n\n        /**\n         * Handle the arguments passed to the constructor\n         * @returns {Array} Arguments without renderTo\n         */\n        getArgs: function () {\n            var args = [].slice.call(arguments);\n        \n            // Remove the optional first argument, renderTo, and\n            // set it on this.\n            if (isString(args[0]) || args[0].nodeName) {\n                this.renderTo = args.shift();\n            }\n            this.init(args[0], args[1]);\n        },\n\n        /**\n         * Initialize the chart\n         */\n        init: function (userOptions, callback) {\n\n            // Handle regular options\n            var options,\n                seriesOptions = userOptions.series; // skip merging data points to increase performance\n\n            userOptions.series = null;\n            options = merge(defaultOptions, userOptions); // do the merge\n            options.series = userOptions.series = seriesOptions; // set back the series data\n            this.userOptions = userOptions;\n\n            var optionsChart = options.chart;\n\n            // Create margin & spacing array\n            this.margin = this.splashArray('margin', optionsChart);\n            this.spacing = this.splashArray('spacing', optionsChart);\n\n            var chartEvents = optionsChart.events;\n\n            //this.runChartClick = chartEvents && !!chartEvents.click;\n            this.bounds = { h: {}, v: {} }; // Pixel data bounds for touch zoom\n\n            this.callback = callback;\n            this.isResizing = 0;\n            this.options = options;\n            //chartTitleOptions = UNDEFINED;\n            //chartSubtitleOptions = UNDEFINED;\n\n            this.axes = [];\n            this.series = [];\n            this.hasCartesianSeries = optionsChart.showAxes;\n            //this.axisOffset = UNDEFINED;\n            //this.maxTicks = UNDEFINED; // handle the greatest amount of ticks on grouped axes\n            //this.inverted = UNDEFINED;\n            //this.loadingShown = UNDEFINED;\n            //this.container = UNDEFINED;\n            //this.chartWidth = UNDEFINED;\n            //this.chartHeight = UNDEFINED;\n            //this.marginRight = UNDEFINED;\n            //this.marginBottom = UNDEFINED;\n            //this.containerWidth = UNDEFINED;\n            //this.containerHeight = UNDEFINED;\n            //this.oldChartWidth = UNDEFINED;\n            //this.oldChartHeight = UNDEFINED;\n\n            //this.renderTo = UNDEFINED;\n            //this.renderToClone = UNDEFINED;\n\n            //this.spacingBox = UNDEFINED\n\n            //this.legend = UNDEFINED;\n\n            // Elements\n            //this.chartBackground = UNDEFINED;\n            //this.plotBackground = UNDEFINED;\n            //this.plotBGImage = UNDEFINED;\n            //this.plotBorder = UNDEFINED;\n            //this.loadingDiv = UNDEFINED;\n            //this.loadingSpan = UNDEFINED;\n\n            var chart = this,\n                eventType;\n\n            // Add the chart to the global lookup\n            chart.index = charts.length;\n            charts.push(chart);\n            chartCount++;\n\n            // Set up auto resize\n            if (optionsChart.reflow !== false) {\n                addEvent(chart, 'load', function () {\n                    chart.initReflow();\n                });\n            }\n\n            // Chart event handlers\n            if (chartEvents) {\n                for (eventType in chartEvents) {\n                    addEvent(chart, eventType, chartEvents[eventType]);\n                }\n            }\n\n            chart.xAxis = [];\n            chart.yAxis = [];\n\n            // Expose methods and variables\n            chart.animation = useCanVG ? false : pick(optionsChart.animation, true);\n            chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;\n\n            chart.firstRender();\n        },\n\n        /**\n         * Initialize an individual series, called internally before render time\n         */\n        initSeries: function (options) {\n            var chart = this,\n                optionsChart = chart.options.chart,\n                type = options.type || optionsChart.type || optionsChart.defaultSeriesType,\n                series,\n                constr = seriesTypes[type];\n\n            // No such series type\n            if (!constr) {\n                error(17, true);\n            }\n\n            series = new constr();\n            series.init(this, options);\n            return series;\n        },\n\n        /**\n         * Check whether a given point is within the plot area\n         *\n         * @param {Number} plotX Pixel x relative to the plot area\n         * @param {Number} plotY Pixel y relative to the plot area\n         * @param {Boolean} inverted Whether the chart is inverted\n         */\n        isInsidePlot: function (plotX, plotY, inverted) {\n            var x = inverted ? plotY : plotX,\n                y = inverted ? plotX : plotY;\n\n            return x >= 0 &&\n                x <= this.plotWidth &&\n                y >= 0 &&\n                y <= this.plotHeight;\n        },\n\n        /**\n         * Redraw legend, axes or series based on updated data\n         *\n         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n         *    configuration\n         */\n        redraw: function (animation) {\n            var chart = this,\n                axes = chart.axes,\n                series = chart.series,\n                pointer = chart.pointer,\n                legend = chart.legend,\n                redrawLegend = chart.isDirtyLegend,\n                hasStackedSeries,\n                hasDirtyStacks,\n                hasCartesianSeries = chart.hasCartesianSeries,\n                isDirtyBox = chart.isDirtyBox,\n                seriesLength = series.length,\n                i = seriesLength,\n                serie,\n                renderer = chart.renderer,\n                isHiddenChart = renderer.isHidden(),\n                afterRedraw = [];\n\n            setAnimation(animation, chart);\n\n            if (isHiddenChart) {\n                chart.cloneRenderTo();\n            }\n\n            // Adjust title layout (reflow multiline text)\n            chart.layOutTitles();\n\n            // link stacked series\n            while (i--) {\n                serie = series[i];\n\n                if (serie.options.stacking) {\n                    hasStackedSeries = true;\n\n                    if (serie.isDirty) {\n                        hasDirtyStacks = true;\n                        break;\n                    }\n                }\n            }\n            if (hasDirtyStacks) { // mark others as dirty\n                i = seriesLength;\n                while (i--) {\n                    serie = series[i];\n                    if (serie.options.stacking) {\n                        serie.isDirty = true;\n                    }\n                }\n            }\n\n            // Handle updated data in the series\n            each(series, function (serie) {\n                if (serie.isDirty) {\n                    if (serie.options.legendType === 'point') {\n                        if (serie.updateTotals) {\n                            serie.updateTotals();\n                        }\n                        redrawLegend = true;\n                    }\n                }\n                if (serie.isDirtyData) {\n                    fireEvent(serie, 'updatedData');\n                }\n            });\n\n            // handle added or removed series\n            if (redrawLegend && legend.options.enabled) { // series or pie points are added or removed\n                // draw legend graphics\n                legend.render();\n\n                chart.isDirtyLegend = false;\n            }\n\n            // reset stacks\n            if (hasStackedSeries) {\n                chart.getStacks();\n            }\n\n\n            if (hasCartesianSeries) {\n                if (!chart.isResizing) {\n\n                    // reset maxTicks\n                    chart.maxTicks = null;\n\n                    // set axes scales\n                    each(axes, function (axis) {\n                        axis.updateNames();\n                        axis.setScale();\n                    });\n                }\n            }\n\n            chart.getMargins(); // #3098\n\n            if (hasCartesianSeries) {\n                // If one axis is dirty, all axes must be redrawn (#792, #2169)\n                each(axes, function (axis) {\n                    if (axis.isDirty) {\n                        isDirtyBox = true;\n                    }\n                });\n\n                // redraw axes\n                each(axes, function (axis) {\n\n                    // Fire 'afterSetExtremes' only if extremes are set\n                    var key = axis.min + ',' + axis.max;\n                    if (axis.extKey !== key) { // #821, #4452\n                        axis.extKey = key;\n                        afterRedraw.push(function () { // prevent a recursive call to chart.redraw() (#1119)\n                            fireEvent(axis, 'afterSetExtremes', extend(axis.eventArgs, axis.getExtremes())); // #747, #751\n                            delete axis.eventArgs;\n                        });\n                    }\n                    if (isDirtyBox || hasStackedSeries) {\n                        axis.redraw();\n                    }\n                });\n            }\n\n            // the plot areas size has changed\n            if (isDirtyBox) {\n                chart.drawChartBox();\n            }\n\n\n            // redraw affected series\n            each(series, function (serie) {\n                if (serie.isDirty && serie.visible &&\n                        (!serie.isCartesian || serie.xAxis)) { // issue #153\n                    serie.redraw();\n                }\n            });\n\n            // move tooltip or reset\n            if (pointer) {\n                pointer.reset(true);\n            }\n\n            // redraw if canvas\n            renderer.draw();\n\n            // fire the event\n            fireEvent(chart, 'redraw');\n\n            if (isHiddenChart) {\n                chart.cloneRenderTo(true);\n            }\n\n            // Fire callbacks that are put on hold until after the redraw\n            each(afterRedraw, function (callback) {\n                callback.call();\n            });\n        },\n\n        /**\n         * Get an axis, series or point object by id.\n         * @param id {String} The id as given in the configuration options\n         */\n        get: function (id) {\n            var chart = this,\n                axes = chart.axes,\n                series = chart.series;\n\n            var i,\n                j,\n                points;\n\n            // search axes\n            for (i = 0; i < axes.length; i++) {\n                if (axes[i].options.id === id) {\n                    return axes[i];\n                }\n            }\n\n            // search series\n            for (i = 0; i < series.length; i++) {\n                if (series[i].options.id === id) {\n                    return series[i];\n                }\n            }\n\n            // search points\n            for (i = 0; i < series.length; i++) {\n                points = series[i].points || [];\n                for (j = 0; j < points.length; j++) {\n                    if (points[j].id === id) {\n                        return points[j];\n                    }\n                }\n            }\n            return null;\n        },\n\n        /**\n         * Create the Axis instances based on the config options\n         */\n        getAxes: function () {\n            var chart = this,\n                options = this.options,\n                xAxisOptions = options.xAxis = splat(options.xAxis || {}),\n                yAxisOptions = options.yAxis = splat(options.yAxis || {}),\n                optionsArray;\n\n            // make sure the options are arrays and add some members\n            each(xAxisOptions, function (axis, i) {\n                axis.index = i;\n                axis.isX = true;\n            });\n\n            each(yAxisOptions, function (axis, i) {\n                axis.index = i;\n            });\n\n            // concatenate all axis options into one array\n            optionsArray = xAxisOptions.concat(yAxisOptions);\n\n            each(optionsArray, function (axisOptions) {\n                new Axis(chart, axisOptions); // eslint-disable-line no-new\n            });\n        },\n\n\n        /**\n         * Get the currently selected points from all series\n         */\n        getSelectedPoints: function () {\n            var points = [];\n            each(this.series, function (serie) {\n                points = points.concat(grep(serie.points || [], function (point) {\n                    return point.selected;\n                }));\n            });\n            return points;\n        },\n\n        /**\n         * Get the currently selected series\n         */\n        getSelectedSeries: function () {\n            return grep(this.series, function (serie) {\n                return serie.selected;\n            });\n        },\n\n        /**\n         * Show the title and subtitle of the chart\n         *\n         * @param titleOptions {Object} New title options\n         * @param subtitleOptions {Object} New subtitle options\n         *\n         */\n        setTitle: function (titleOptions, subtitleOptions, redraw) {\n            var chart = this,\n                options = chart.options,\n                chartTitleOptions,\n                chartSubtitleOptions;\n\n            chartTitleOptions = options.title = merge(options.title, titleOptions);\n            chartSubtitleOptions = options.subtitle = merge(options.subtitle, subtitleOptions);\n\n            // add title and subtitle\n            each([\n                ['title', titleOptions, chartTitleOptions],\n                ['subtitle', subtitleOptions, chartSubtitleOptions]\n            ], function (arr) {\n                var name = arr[0],\n                    title = chart[name],\n                    titleOptions = arr[1],\n                    chartTitleOptions = arr[2];\n\n                if (title && titleOptions) {\n                    chart[name] = title = title.destroy(); // remove old\n                }\n\n                if (chartTitleOptions && chartTitleOptions.text && !title) {\n                    chart[name] = chart.renderer.text(\n                        chartTitleOptions.text,\n                        0,\n                        0,\n                        chartTitleOptions.useHTML\n                    )\n                    .attr({\n                        align: chartTitleOptions.align,\n                        'class': PREFIX + name,\n                        zIndex: chartTitleOptions.zIndex || 4\n                    })\n                    .css(chartTitleOptions.style)\n                    .add();\n            \n                }\n            });\n            chart.layOutTitles(redraw);\n        },\n\n        /**\n         * Lay out the chart titles and cache the full offset height for use in getMargins\n         */\n        layOutTitles: function (redraw) {\n            var titleOffset = 0,\n                title = this.title,\n                subtitle = this.subtitle,\n                options = this.options,\n                titleOptions = options.title,\n                subtitleOptions = options.subtitle,\n                requiresDirtyBox,\n                renderer = this.renderer,\n                spacingBox = this.spacingBox;\n\n            if (title) {\n                title\n                    .css({ width: (titleOptions.width || spacingBox.width + titleOptions.widthAdjust) + PX })\n                    .align(extend({\n                        y: renderer.fontMetrics(titleOptions.style.fontSize, title).b - 3\n                    }, titleOptions), false, spacingBox);\n\n                if (!titleOptions.floating && !titleOptions.verticalAlign) {\n                    titleOffset = title.getBBox().height;\n                }\n            }\n            if (subtitle) {\n                subtitle\n                    .css({ width: (subtitleOptions.width || spacingBox.width + subtitleOptions.widthAdjust) + PX })\n                    .align(extend({\n                        y: titleOffset + (titleOptions.margin - 13) + renderer.fontMetrics(subtitleOptions.style.fontSize, title).b\n                    }, subtitleOptions), false, spacingBox);\n\n                if (!subtitleOptions.floating && !subtitleOptions.verticalAlign) {\n                    titleOffset = mathCeil(titleOffset + subtitle.getBBox().height);\n                }\n            }\n\n            requiresDirtyBox = this.titleOffset !== titleOffset;\n            this.titleOffset = titleOffset; // used in getMargins\n\n            if (!this.isDirtyBox && requiresDirtyBox) {\n                this.isDirtyBox = requiresDirtyBox;\n                // Redraw if necessary (#2719, #2744)\n                if (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {\n                    this.redraw();\n                }\n            }\n        },\n\n        /**\n         * Get chart width and height according to options and container size\n         */\n        getChartSize: function () {\n            var chart = this,\n                optionsChart = chart.options.chart,\n                widthOption = optionsChart.width,\n                heightOption = optionsChart.height,\n                renderTo = chart.renderToClone || chart.renderTo;\n\n            // Get inner width and height\n            if (!defined(widthOption)) {\n                chart.containerWidth = getStyle(renderTo, 'width');\n            }\n            if (!defined(heightOption)) {\n                chart.containerHeight = getStyle(renderTo, 'height');\n            }\n\n            chart.chartWidth = mathMax(0, widthOption || chart.containerWidth || 600); // #1393, 1460\n            chart.chartHeight = mathMax(0, pick(heightOption,\n                // the offsetHeight of an empty container is 0 in standard browsers, but 19 in IE7:\n                chart.containerHeight > 19 ? chart.containerHeight : 400));\n        },\n\n        /**\n         * Create a clone of the chart's renderTo div and place it outside the viewport to allow\n         * size computation on chart.render and chart.redraw\n         */\n        cloneRenderTo: function (revert) {\n            var clone = this.renderToClone,\n                container = this.container;\n\n            // Destroy the clone and bring the container back to the real renderTo div\n            if (revert) {\n                if (clone) {\n                    while (clone.childNodes.length) { // #5231\n                        this.renderTo.appendChild(clone.firstChild);\n                    }\n                    discardElement(clone);\n                    delete this.renderToClone;\n                }\n\n            // Set up the clone\n            } else {\n                if (container && container.parentNode === this.renderTo) {\n                    this.renderTo.removeChild(container); // do not clone this\n                }\n                this.renderToClone = clone = this.renderTo.cloneNode(0);\n                css(clone, {\n                    position: ABSOLUTE,\n                    top: '-9999px',\n                    display: 'block' // #833\n                });\n                if (clone.style.setProperty) { // #2631\n                    clone.style.setProperty('display', 'block', 'important');\n                }\n                doc.body.appendChild(clone);\n                if (container) {\n                    clone.appendChild(container);\n                }\n            }\n        },\n\n        /**\n         * Get the containing element, determine the size and create the inner container\n         * div to hold the chart\n         */\n        getContainer: function () {\n            var chart = this,\n                container,\n                options = chart.options,\n                optionsChart = options.chart,\n                chartWidth,\n                chartHeight,\n                renderTo = chart.renderTo,\n                indexAttrName = 'data-highcharts-chart',\n                oldChartIndex,\n                Ren,\n                containerId = 'highcharts-' + idCounter++;\n\n            if (!renderTo) {\n                chart.renderTo = renderTo = optionsChart.renderTo;\n            }\n        \n            if (isString(renderTo)) {\n                chart.renderTo = renderTo = doc.getElementById(renderTo);\n            }\n\n            // Display an error if the renderTo is wrong\n            if (!renderTo) {\n                error(13, true);\n            }\n\n            // If the container already holds a chart, destroy it. The check for hasRendered is there\n            // because web pages that are saved to disk from the browser, will preserve the data-highcharts-chart\n            // attribute and the SVG contents, but not an interactive chart. So in this case,\n            // charts[oldChartIndex] will point to the wrong chart if any (#2609).\n            oldChartIndex = pInt(attr(renderTo, indexAttrName));\n            if (isNumber(oldChartIndex) && charts[oldChartIndex] && charts[oldChartIndex].hasRendered) {\n                charts[oldChartIndex].destroy();\n            }\n\n            // Make a reference to the chart from the div\n            attr(renderTo, indexAttrName, chart.index);\n\n            // remove previous chart\n            renderTo.innerHTML = '';\n\n            // If the container doesn't have an offsetWidth, it has or is a child of a node\n            // that has display:none. We need to temporarily move it out to a visible\n            // state to determine the size, else the legend and tooltips won't render\n            // properly. The allowClone option is used in sparklines as a micro optimization,\n            // saving about 1-2 ms each chart.\n            if (!optionsChart.skipClone && !renderTo.offsetWidth) {\n                chart.cloneRenderTo();\n            }\n\n            // get the width and height\n            chart.getChartSize();\n            chartWidth = chart.chartWidth;\n            chartHeight = chart.chartHeight;\n\n            // create the inner container\n            chart.container = container = createElement(DIV, {\n                    className: PREFIX + 'container' +\n                        (optionsChart.className ? ' ' + optionsChart.className : ''),\n                    id: containerId\n                }, extend({\n                    position: RELATIVE,\n                    overflow: HIDDEN, // needed for context menu (avoid scrollbars) and\n                        // content overflow in IE\n                    width: chartWidth + PX,\n                    height: chartHeight + PX,\n                    textAlign: 'left',\n                    lineHeight: 'normal', // #427\n                    zIndex: 0, // #1072\n                    '-webkit-tap-highlight-color': 'rgba(0,0,0,0)'\n                }, optionsChart.style),\n                chart.renderToClone || renderTo\n            );\n\n            // cache the cursor (#1650)\n            chart._cursor = container.style.cursor;\n\n            // Initialize the renderer\n            Ren = Highcharts[optionsChart.renderer] || Renderer;\n            chart.renderer = new Ren(\n                container,\n                chartWidth,\n                chartHeight,\n                optionsChart.style,\n                optionsChart.forExport,\n                options.exporting && options.exporting.allowHTML\n            );\n\n            if (useCanVG) {\n                // If we need canvg library, extend and configure the renderer\n                // to get the tracker for translating mouse events\n                chart.renderer.create(chart, container, chartWidth, chartHeight);\n            }\n            // Add a reference to the charts index\n            chart.renderer.chartIndex = chart.index;\n        },\n\n        /**\n         * Calculate margins by rendering axis labels in a preliminary position. Title,\n         * subtitle and legend have already been rendered at this stage, but will be\n         * moved into their final positions\n         */\n        getMargins: function (skipAxes) {\n            var chart = this,\n                spacing = chart.spacing,\n                margin = chart.margin,\n                titleOffset = chart.titleOffset;\n\n            chart.resetMargins();\n\n            // Adjust for title and subtitle\n            if (titleOffset && !defined(margin[0])) {\n                chart.plotTop = mathMax(chart.plotTop, titleOffset + chart.options.title.margin + spacing[0]);\n            }\n\n            // Adjust for legend\n            if (chart.legend.display) {\n                chart.legend.adjustMargins(margin, spacing);\n            }\n\n            // adjust for scroller\n            if (chart.extraBottomMargin) {\n                chart.marginBottom += chart.extraBottomMargin;\n            }\n            if (chart.extraTopMargin) {\n                chart.plotTop += chart.extraTopMargin;\n            }\n            if (!skipAxes) {\n                this.getAxisMargins();\n            }\n        },\n\n        getAxisMargins: function () {\n\n            var chart = this,\n                axisOffset = chart.axisOffset = [0, 0, 0, 0], // top, right, bottom, left\n                margin = chart.margin;\n\n            // pre-render axes to get labels offset width\n            if (chart.hasCartesianSeries) {\n                each(chart.axes, function (axis) {\n                    if (axis.visible) {\n                        axis.getOffset();\n                    }\n                });\n            }\n\n            // Add the axis offsets\n            each(marginNames, function (m, side) {\n                if (!defined(margin[side])) {\n                    chart[m] += axisOffset[side];\n                }\n            });\n\n            chart.setChartSize();\n\n        },\n\n        /**\n         * Resize the chart to its container if size is not explicitly set\n         */\n        reflow: function (e) {\n            var chart = this,\n                optionsChart = chart.options.chart,\n                renderTo = chart.renderTo,\n                hasUserWidth = defined(optionsChart.width),\n                width = optionsChart.width || getStyle(renderTo, 'width'),\n                height = optionsChart.height || getStyle(renderTo, 'height'),\n                target = e ? e.target : win;\n\n            // Width and height checks for display:none. Target is doc in IE8 and Opera,\n            // win in Firefox, Chrome and IE9.\n            if (!hasUserWidth && !chart.isPrinting && width && height && (target === win || target === doc)) { // #1093\n                if (width !== chart.containerWidth || height !== chart.containerHeight) {\n                    clearTimeout(chart.reflowTimeout);\n                    // When called from window.resize, e is set, else it's called directly (#2224)\n                    chart.reflowTimeout = syncTimeout(function () {\n                        if (chart.container) { // It may have been destroyed in the meantime (#1257)\n                            chart.setSize(undefined, undefined, false);\n                        }\n                    }, e ? 100 : 0);\n                }\n                chart.containerWidth = width;\n                chart.containerHeight = height;\n            }\n        },\n\n        /**\n         * Add the event handlers necessary for auto resizing\n         */\n        initReflow: function () {\n            var chart = this,\n                reflow = function (e) {\n                    chart.reflow(e);\n                };\n\n\n            addEvent(win, 'resize', reflow);\n            addEvent(chart, 'destroy', function () {\n                removeEvent(win, 'resize', reflow);\n            });\n        },\n\n        /**\n         * Resize the chart to a given width and height\n         * @param {Number} width\n         * @param {Number} height\n         * @param {Object|Boolean} animation\n         */\n        setSize: function (width, height, animation) {\n            var chart = this,\n                renderer = chart.renderer,\n                globalAnimation;\n\n            // Handle the isResizing counter\n            chart.isResizing += 1;\n        \n            // set the animation for the current process\n            setAnimation(animation, chart);\n\n            chart.oldChartHeight = chart.chartHeight;\n            chart.oldChartWidth = chart.chartWidth;\n            if (width !== undefined) {\n                chart.options.chart.width = width;\n            }\n            if (height !== undefined) {\n                chart.options.chart.height = height;\n            }\n            chart.getChartSize();\n\n            // Resize the container with the global animation applied if enabled (#2503)\n            globalAnimation = renderer.globalAnimation;\n            (globalAnimation ? animate : css)(chart.container, {\n                width: chart.chartWidth + PX,\n                height: chart.chartHeight + PX\n            }, globalAnimation);\n\n            chart.setChartSize(true);\n            renderer.setSize(chart.chartWidth, chart.chartHeight, animation);\n\n            // handle axes\n            chart.maxTicks = null;\n            each(chart.axes, function (axis) {\n                axis.isDirty = true;\n                axis.setScale();\n            });\n\n            // make sure non-cartesian series are also handled\n            each(chart.series, function (serie) {\n                serie.isDirty = true;\n            });\n\n            chart.isDirtyLegend = true; // force legend redraw\n            chart.isDirtyBox = true; // force redraw of plot and chart border\n\n            chart.layOutTitles(); // #2857\n            chart.getMargins();\n\n            chart.redraw(animation);\n\n\n            chart.oldChartHeight = null;\n            fireEvent(chart, 'resize');\n\n            // Fire endResize and set isResizing back. If animation is disabled, fire without delay\n            syncTimeout(function () {\n                if (chart) {\n                    fireEvent(chart, 'endResize', null, function () {\n                        chart.isResizing -= 1;\n                    });\n                }\n            }, animObject(globalAnimation).duration);\n        },\n\n        /**\n         * Set the public chart properties. This is done before and after the pre-render\n         * to determine margin sizes\n         */\n        setChartSize: function (skipAxes) {\n            var chart = this,\n                inverted = chart.inverted,\n                renderer = chart.renderer,\n                chartWidth = chart.chartWidth,\n                chartHeight = chart.chartHeight,\n                optionsChart = chart.options.chart,\n                spacing = chart.spacing,\n                clipOffset = chart.clipOffset,\n                clipX,\n                clipY,\n                plotLeft,\n                plotTop,\n                plotWidth,\n                plotHeight,\n                plotBorderWidth;\n\n            chart.plotLeft = plotLeft = mathRound(chart.plotLeft);\n            chart.plotTop = plotTop = mathRound(chart.plotTop);\n            chart.plotWidth = plotWidth = mathMax(0, mathRound(chartWidth - plotLeft - chart.marginRight));\n            chart.plotHeight = plotHeight = mathMax(0, mathRound(chartHeight - plotTop - chart.marginBottom));\n\n            chart.plotSizeX = inverted ? plotHeight : plotWidth;\n            chart.plotSizeY = inverted ? plotWidth : plotHeight;\n\n            chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;\n\n            // Set boxes used for alignment\n            chart.spacingBox = renderer.spacingBox = {\n                x: spacing[3],\n                y: spacing[0],\n                width: chartWidth - spacing[3] - spacing[1],\n                height: chartHeight - spacing[0] - spacing[2]\n            };\n            chart.plotBox = renderer.plotBox = {\n                x: plotLeft,\n                y: plotTop,\n                width: plotWidth,\n                height: plotHeight\n            };\n\n            plotBorderWidth = 2 * mathFloor(chart.plotBorderWidth / 2);\n            clipX = mathCeil(mathMax(plotBorderWidth, clipOffset[3]) / 2);\n            clipY = mathCeil(mathMax(plotBorderWidth, clipOffset[0]) / 2);\n            chart.clipBox = {\n                x: clipX,\n                y: clipY,\n                width: mathFloor(chart.plotSizeX - mathMax(plotBorderWidth, clipOffset[1]) / 2 - clipX),\n                height: mathMax(0, mathFloor(chart.plotSizeY - mathMax(plotBorderWidth, clipOffset[2]) / 2 - clipY))\n            };\n\n            if (!skipAxes) {\n                each(chart.axes, function (axis) {\n                    axis.setAxisSize();\n                    axis.setAxisTranslation();\n                });\n            }\n        },\n\n        /**\n         * Initial margins before auto size margins are applied\n         */\n        resetMargins: function () {\n            var chart = this;\n\n            each(marginNames, function (m, side) {\n                chart[m] = pick(chart.margin[side], chart.spacing[side]);\n            });\n            chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left\n            chart.clipOffset = [0, 0, 0, 0];\n        },\n\n        /**\n         * Draw the borders and backgrounds for chart and plot area\n         */\n        drawChartBox: function () {\n            var chart = this,\n                optionsChart = chart.options.chart,\n                renderer = chart.renderer,\n                chartWidth = chart.chartWidth,\n                chartHeight = chart.chartHeight,\n                chartBackground = chart.chartBackground,\n                plotBackground = chart.plotBackground,\n                plotBorder = chart.plotBorder,\n                plotBGImage = chart.plotBGImage,\n                chartBorderWidth = optionsChart.borderWidth || 0,\n                chartBackgroundColor = optionsChart.backgroundColor,\n                plotBackgroundColor = optionsChart.plotBackgroundColor,\n                plotBackgroundImage = optionsChart.plotBackgroundImage,\n                plotBorderWidth = optionsChart.plotBorderWidth || 0,\n                mgn,\n                bgAttr,\n                plotLeft = chart.plotLeft,\n                plotTop = chart.plotTop,\n                plotWidth = chart.plotWidth,\n                plotHeight = chart.plotHeight,\n                plotBox = chart.plotBox,\n                clipRect = chart.clipRect,\n                clipBox = chart.clipBox;\n\n            // Chart area\n            mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);\n\n            if (chartBorderWidth || chartBackgroundColor) {\n                if (!chartBackground) {\n\n                    bgAttr = {\n                        fill: chartBackgroundColor || NONE\n                    };\n                    if (chartBorderWidth) { // #980\n                        bgAttr.stroke = optionsChart.borderColor;\n                        bgAttr['stroke-width'] = chartBorderWidth;\n                    }\n                    chart.chartBackground = renderer.rect(mgn / 2, mgn / 2, chartWidth - mgn, chartHeight - mgn,\n                            optionsChart.borderRadius, chartBorderWidth)\n                        .attr(bgAttr)\n                        .addClass(PREFIX + 'background')\n                        .add()\n                        .shadow(optionsChart.shadow);\n\n                } else { // resize\n                    chartBackground.animate(\n                        chartBackground.crisp({ width: chartWidth - mgn, height: chartHeight - mgn })\n                    );\n                }\n            }\n\n\n            // Plot background\n            if (plotBackgroundColor) {\n                if (!plotBackground) {\n                    chart.plotBackground = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0)\n                        .attr({\n                            fill: plotBackgroundColor\n                        })\n                        .add()\n                        .shadow(optionsChart.plotShadow);\n                } else {\n                    plotBackground.animate(plotBox);\n                }\n            }\n            if (plotBackgroundImage) {\n                if (!plotBGImage) {\n                    chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight)\n                        .add();\n                } else {\n                    plotBGImage.animate(plotBox);\n                }\n            }\n\n            // Plot clip\n            if (!clipRect) {\n                chart.clipRect = renderer.clipRect(clipBox);\n            } else {\n                clipRect.animate({\n                    width: clipBox.width,\n                    height: clipBox.height\n                });\n            }\n\n            // Plot area border\n            if (plotBorderWidth) {\n                if (!plotBorder) {\n                    chart.plotBorder = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0, -plotBorderWidth)\n                        .attr({\n                            stroke: optionsChart.plotBorderColor,\n                            'stroke-width': plotBorderWidth,\n                            fill: NONE,\n                            zIndex: 1\n                        })\n                        .add();\n                } else {\n                    plotBorder.strokeWidth = -plotBorderWidth;\n                    plotBorder.animate(\n                        plotBorder.crisp({ x: plotLeft, y: plotTop, width: plotWidth, height: plotHeight }) //#3282 plotBorder should be negative\n                    );\n                }\n            }\n\n            // reset\n            chart.isDirtyBox = false;\n        },\n\n        /**\n         * Detect whether a certain chart property is needed based on inspecting its options\n         * and series. This mainly applies to the chart.invert property, and in extensions to\n         * the chart.angular and chart.polar properties.\n         */\n        propFromSeries: function () {\n            var chart = this,\n                optionsChart = chart.options.chart,\n                klass,\n                seriesOptions = chart.options.series,\n                i,\n                value;\n\n\n            each(['inverted', 'angular', 'polar'], function (key) {\n\n                // The default series type's class\n                klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType];\n\n                // Get the value from available chart-wide properties\n                value = (\n                    chart[key] || // 1. it is set before\n                    optionsChart[key] || // 2. it is set in the options\n                    (klass && klass.prototype[key]) // 3. it's default series class requires it\n                );\n\n                // 4. Check if any the chart's series require it\n                i = seriesOptions && seriesOptions.length;\n                while (!value && i--) {\n                    klass = seriesTypes[seriesOptions[i].type];\n                    if (klass && klass.prototype[key]) {\n                        value = true;\n                    }\n                }\n\n                // Set the chart property\n                chart[key] = value;\n            });\n\n        },\n\n        /**\n         * Link two or more series together. This is done initially from Chart.render,\n         * and after Chart.addSeries and Series.remove.\n         */\n        linkSeries: function () {\n            var chart = this,\n                chartSeries = chart.series;\n\n            // Reset links\n            each(chartSeries, function (series) {\n                series.linkedSeries.length = 0;\n            });\n\n            // Apply new links\n            each(chartSeries, function (series) {\n                var linkedTo = series.options.linkedTo;\n                if (isString(linkedTo)) {\n                    if (linkedTo === ':previous') {\n                        linkedTo = chart.series[series.index - 1];\n                    } else {\n                        linkedTo = chart.get(linkedTo);\n                    }\n                    if (linkedTo && linkedTo.linkedParent !== series) { // #3341 avoid mutual linking\n                        linkedTo.linkedSeries.push(series);\n                        series.linkedParent = linkedTo;\n                        series.visible = pick(series.options.visible, linkedTo.options.visible, series.visible); // #3879\n                    }\n                }\n            });\n        },\n\n        /**\n         * Render series for the chart\n         */\n        renderSeries: function () {\n            each(this.series, function (serie) {\n                serie.translate();\n                serie.render();\n            });\n        },\n\n        /**\n         * Render labels for the chart\n         */\n        renderLabels: function () {\n            var chart = this,\n                labels = chart.options.labels;\n            if (labels.items) {\n                each(labels.items, function (label) {\n                    var style = extend(labels.style, label.style),\n                        x = pInt(style.left) + chart.plotLeft,\n                        y = pInt(style.top) + chart.plotTop + 12;\n\n                    // delete to prevent rewriting in IE\n                    delete style.left;\n                    delete style.top;\n\n                    chart.renderer.text(\n                        label.html,\n                        x,\n                        y\n                    )\n                    .attr({ zIndex: 2 })\n                    .css(style)\n                    .add();\n\n                });\n            }\n        },\n\n        /**\n         * Render all graphics for the chart\n         */\n        render: function () {\n            var chart = this,\n                axes = chart.axes,\n                renderer = chart.renderer,\n                options = chart.options,\n                tempWidth,\n                tempHeight,\n                redoHorizontal,\n                redoVertical;\n\n            // Title\n            chart.setTitle();\n\n\n            // Legend\n            chart.legend = new Legend(chart, options.legend);\n\n            // Get stacks\n            if (chart.getStacks) {\n                chart.getStacks();\n            }\n\n            // Get chart margins\n            chart.getMargins(true);\n            chart.setChartSize();\n\n            // Record preliminary dimensions for later comparison\n            tempWidth = chart.plotWidth;\n            tempHeight = chart.plotHeight = chart.plotHeight - 21; // 21 is the most common correction for X axis labels\n\n            // Get margins by pre-rendering axes\n            each(axes, function (axis) {\n                axis.setScale();\n            });\n            chart.getAxisMargins();\n\n            // If the plot area size has changed significantly, calculate tick positions again\n            redoHorizontal = tempWidth / chart.plotWidth > 1.1;\n            redoVertical = tempHeight / chart.plotHeight > 1.05; // Height is more sensitive\n\n            if (redoHorizontal || redoVertical) {\n\n                chart.maxTicks = null; // reset for second pass\n                each(axes, function (axis) {\n                    if ((axis.horiz && redoHorizontal) || (!axis.horiz && redoVertical)) {\n                        axis.setTickInterval(true); // update to reflect the new margins\n                    }\n                });\n                chart.getMargins(); // second pass to check for new labels\n            }\n\n            // Draw the borders and backgrounds\n            chart.drawChartBox();\n\n\n            // Axes\n            if (chart.hasCartesianSeries) {\n                each(axes, function (axis) {\n                    if (axis.visible) {\n                        axis.render();\n                    }\n                });\n            }\n\n            // The series\n            if (!chart.seriesGroup) {\n                chart.seriesGroup = renderer.g('series-group')\n                    .attr({ zIndex: 3 })\n                    .add();\n            }\n            chart.renderSeries();\n\n            // Labels\n            chart.renderLabels();\n\n            // Credits\n            chart.showCredits(options.credits);\n\n            // Set flag\n            chart.hasRendered = true;\n\n        },\n\n        /**\n         * Show chart credits based on config options\n         */\n        showCredits: function (credits) {\n            if (credits.enabled && !this.credits) {\n                this.credits = this.renderer.text(\n                    credits.text,\n                    0,\n                    0\n                )\n                .on('click', function () {\n                    if (credits.href) {\n                        win.location.href = credits.href;\n                    }\n                })\n                .attr({\n                    align: credits.position.align,\n                    zIndex: 8\n                })\n                .css(credits.style)\n                .add()\n                .align(credits.position);\n            }\n        },\n\n        /**\n         * Clean up memory usage\n         */\n        destroy: function () {\n            var chart = this,\n                axes = chart.axes,\n                series = chart.series,\n                container = chart.container,\n                i,\n                parentNode = container && container.parentNode;\n\n            // fire the chart.destoy event\n            fireEvent(chart, 'destroy');\n\n            // Delete the chart from charts lookup array\n            charts[chart.index] = UNDEFINED;\n            chartCount--;\n            chart.renderTo.removeAttribute('data-highcharts-chart');\n\n            // remove events\n            removeEvent(chart);\n\n            // ==== Destroy collections:\n            // Destroy axes\n            i = axes.length;\n            while (i--) {\n                axes[i] = axes[i].destroy();\n            }\n\n            // Destroy each series\n            i = series.length;\n            while (i--) {\n                series[i] = series[i].destroy();\n            }\n\n            // ==== Destroy chart properties:\n            each(['title', 'subtitle', 'chartBackground', 'plotBackground', 'plotBGImage',\n                    'plotBorder', 'seriesGroup', 'clipRect', 'credits', 'pointer', 'scroller',\n                    'rangeSelector', 'legend', 'resetZoomButton', 'tooltip', 'renderer'], function (name) {\n                var prop = chart[name];\n\n                if (prop && prop.destroy) {\n                    chart[name] = prop.destroy();\n                }\n            });\n\n            // remove container and all SVG\n            if (container) { // can break in IE when destroyed before finished loading\n                container.innerHTML = '';\n                removeEvent(container);\n                if (parentNode) {\n                    discardElement(container);\n                }\n\n            }\n\n            // clean it all up\n            for (i in chart) {\n                delete chart[i];\n            }\n\n        },\n\n\n        /**\n         * VML namespaces can't be added until after complete. Listening\n         * for Perini's doScroll hack is not enough.\n         */\n        isReadyToRender: function () {\n            var chart = this;\n\n            // Note: win == win.top is required\n            if ((!hasSVG && (win == win.top && doc.readyState !== 'complete')) || (useCanVG && !win.canvg)) { // eslint-disable-line eqeqeq\n                if (useCanVG) {\n                    // Delay rendering until canvg library is downloaded and ready\n                    CanVGController.push(function () {\n                        chart.firstRender();\n                    }, chart.options.global.canvasToolsURL);\n                } else {\n                    doc.attachEvent('onreadystatechange', function () {\n                        doc.detachEvent('onreadystatechange', chart.firstRender);\n                        if (doc.readyState === 'complete') {\n                            chart.firstRender();\n                        }\n                    });\n                }\n                return false;\n            }\n            return true;\n        },\n\n        /**\n         * Prepare for first rendering after all data are loaded\n         */\n        firstRender: function () {\n            var chart = this,\n                options = chart.options;\n\n            // Check whether the chart is ready to render\n            if (!chart.isReadyToRender()) {\n                return;\n            }\n\n            // Create the container\n            chart.getContainer();\n\n            // Run an early event after the container and renderer are established\n            fireEvent(chart, 'init');\n\n\n            chart.resetMargins();\n            chart.setChartSize();\n\n            // Set the common chart properties (mainly invert) from the given series\n            chart.propFromSeries();\n\n            // get axes\n            chart.getAxes();\n\n            // Initialize the series\n            each(options.series || [], function (serieOptions) {\n                chart.initSeries(serieOptions);\n            });\n\n            chart.linkSeries();\n\n            // Run an event after axes and series are initialized, but before render. At this stage,\n            // the series data is indexed and cached in the xData and yData arrays, so we can access\n            // those before rendering. Used in Highstock.\n            fireEvent(chart, 'beforeRender');\n\n            // depends on inverted and on margins being set\n            if (Highcharts.Pointer) {\n                chart.pointer = new Pointer(chart, options);\n            }\n\n            chart.render();\n\n            // add canvas\n            chart.renderer.draw();\n        \n            // Fire the load event if there are no external images\n            if (!chart.renderer.imgCount && chart.onload) {\n                chart.onload();\n            }\n\n            // If the chart was rendered outside the top container, put it back in (#3679)\n            chart.cloneRenderTo(true);\n\n        },\n\n        /** \n         * On chart load\n         */\n        onload: function () {\n            var chart = this;\n\n            // Run callbacks\n            each([this.callback].concat(this.callbacks), function (fn) {\n                if (fn && chart.index !== undefined) { // Chart destroyed in its own callback (#3600)\n                    fn.apply(chart, [chart]);\n                }\n            });\n\n            fireEvent(chart, 'load');\n\n            // Don't run again\n            this.onload = null;\n        },\n\n        /**\n        * Creates arrays for spacing and margin from given options.\n        */\n        splashArray: function (target, options) {\n            var oVar = options[target],\n                tArray = isObject(oVar) ? oVar : [oVar, oVar, oVar, oVar];\n\n            return [pick(options[target + 'Top'], tArray[0]),\n                    pick(options[target + 'Right'], tArray[1]),\n                    pick(options[target + 'Bottom'], tArray[2]),\n                    pick(options[target + 'Left'], tArray[3])];\n        }\n    }; // end Chart\n\n    var CenteredSeriesMixin = Highcharts.CenteredSeriesMixin = {\n        /**\n         * Get the center of the pie based on the size and center options relative to the\n         * plot area. Borrowed by the polar and gauge series types.\n         */\n        getCenter: function () {\n\n            var options = this.options,\n                chart = this.chart,\n                slicingRoom = 2 * (options.slicedOffset || 0),\n                handleSlicingRoom,\n                plotWidth = chart.plotWidth - 2 * slicingRoom,\n                plotHeight = chart.plotHeight - 2 * slicingRoom,\n                centerOption = options.center,\n                positions = [pick(centerOption[0], '50%'), pick(centerOption[1], '50%'), options.size || '100%', options.innerSize || 0],\n                smallestSize = mathMin(plotWidth, plotHeight),\n                i,\n                value;\n\n            for (i = 0; i < 4; ++i) {\n                value = positions[i];\n                handleSlicingRoom = i < 2 || (i === 2 && /%$/.test(value));\n\n                // i == 0: centerX, relative to width\n                // i == 1: centerY, relative to height\n                // i == 2: size, relative to smallestSize\n                // i == 3: innerSize, relative to size\n                positions[i] = relativeLength(value, [plotWidth, plotHeight, smallestSize, positions[2]][i]) +\n                    (handleSlicingRoom ? slicingRoom : 0);\n\n            }\n            // innerSize cannot be larger than size (#3632)\n            if (positions[3] > positions[2]) {\n                positions[3] = positions[2];\n            }\n            return positions;\n        }\n    };\n\n    /**\n     * The Point object and prototype. Inheritable and used as base for PiePoint\n     */\n    var Point = function () {};\n    Point.prototype = {\n\n        /**\n         * Initialize the point\n         * @param {Object} series The series object containing this point\n         * @param {Object} options The data in either number, array or object format\n         */\n        init: function (series, options, x) {\n\n            var point = this,\n                colors;\n            point.series = series;\n            point.color = series.color; // #3445\n            point.applyOptions(options, x);\n            point.pointAttr = {};\n\n            if (series.options.colorByPoint) {\n                colors = series.options.colors || series.chart.options.colors;\n                point.color = point.color || colors[series.colorCounter++];\n                // loop back to zero\n                if (series.colorCounter === colors.length) {\n                    series.colorCounter = 0;\n                }\n            }\n\n            series.chart.pointCount++;\n            return point;\n        },\n        /**\n         * Apply the options containing the x and y data and possible some extra properties.\n         * This is called on point init or from point.update.\n         *\n         * @param {Object} options\n         */\n        applyOptions: function (options, x) {\n            var point = this,\n                series = point.series,\n                pointValKey = series.options.pointValKey || series.pointValKey;\n\n            options = Point.prototype.optionsToObject.call(this, options);\n\n            // copy options directly to point\n            extend(point, options);\n            point.options = point.options ? extend(point.options, options) : options;\n\n            // Since options are copied into the Point instance, some accidental options must be shielded (#5681)\n            if (options.group) {\n                delete point.group;\n            }\n\n            // For higher dimension series types. For instance, for ranges, point.y is mapped to point.low.\n            if (pointValKey) {\n                point.y = point[pointValKey];\n            }\n            point.isNull = pick(\n                point.isValid && !point.isValid(),\n                point.x === null || !isNumber(point.y, true)\n            ); // #3571, check for NaN\n\n            // If no x is set by now, get auto incremented value. All points must have an\n            // x value, however the y value can be null to create a gap in the series\n            if ('name' in point && x === undefined && series.xAxis && series.xAxis.hasNames) {\n                point.x = series.xAxis.nameToX(point);\n            }\n            if (point.x === undefined && series) {\n                if (x === undefined) {\n                    point.x = series.autoIncrement(point);\n                } else {\n                    point.x = x;\n                }\n            }\n        \n            return point;\n        },\n\n        /**\n         * Transform number or array configs into objects\n         */\n        optionsToObject: function (options) {\n            var ret = {},\n                series = this.series,\n                keys = series.options.keys,\n                pointArrayMap = keys || series.pointArrayMap || ['y'],\n                valueCount = pointArrayMap.length,\n                firstItemType,\n                i = 0,\n                j = 0;\n\n            if (isNumber(options) || options === null) {\n                ret[pointArrayMap[0]] = options;\n\n            } else if (isArray(options)) {\n                // with leading x value\n                if (!keys && options.length > valueCount) {\n                    firstItemType = typeof options[0];\n                    if (firstItemType === 'string') {\n                        ret.name = options[0];\n                    } else if (firstItemType === 'number') {\n                        ret.x = options[0];\n                    }\n                    i++;\n                }\n                while (j < valueCount) {\n                    if (!keys || options[i] !== undefined) { // Skip undefined positions for keys\n                        ret[pointArrayMap[j]] = options[i];\n                    }\n                    i++;\n                    j++;\n                }\n            } else if (typeof options === 'object') {\n                ret = options;\n\n                // This is the fastest way to detect if there are individual point dataLabels that need\n                // to be considered in drawDataLabels. These can only occur in object configs.\n                if (options.dataLabels) {\n                    series._hasPointLabels = true;\n                }\n\n                // Same approach as above for markers\n                if (options.marker) {\n                    series._hasPointMarkers = true;\n                }\n            }\n            return ret;\n        },\n\n        /**\n         * Destroy a point to clear memory. Its reference still stays in series.data.\n         */\n        destroy: function () {\n            var point = this,\n                series = point.series,\n                chart = series.chart,\n                hoverPoints = chart.hoverPoints,\n                prop;\n\n            chart.pointCount--;\n\n            if (hoverPoints) {\n                point.setState();\n                erase(hoverPoints, point);\n                if (!hoverPoints.length) {\n                    chart.hoverPoints = null;\n                }\n\n            }\n            if (point === chart.hoverPoint) {\n                point.onMouseOut();\n            }\n\n            // remove all events\n            if (point.graphic || point.dataLabel) { // removeEvent and destroyElements are performance expensive\n                removeEvent(point);\n                point.destroyElements();\n            }\n\n            if (point.legendItem) { // pies have legend items\n                chart.legend.destroyItem(point);\n            }\n\n            for (prop in point) {\n                point[prop] = null;\n            }\n\n\n        },\n\n        /**\n         * Destroy SVG elements associated with the point\n         */\n        destroyElements: function () {\n            var point = this,\n                props = ['graphic', 'dataLabel', 'dataLabelUpper', 'connector', 'shadowGroup'],\n                prop,\n                i = 6;\n            while (i--) {\n                prop = props[i];\n                if (point[prop]) {\n                    point[prop] = point[prop].destroy();\n                }\n            }\n        },\n\n        /**\n         * Return the configuration hash needed for the data label and tooltip formatters\n         */\n        getLabelConfig: function () {\n            return {\n                x: this.category,\n                y: this.y,\n                color: this.color,\n                key: this.name || this.category,\n                series: this.series,\n                point: this,\n                percentage: this.percentage,\n                total: this.total || this.stackTotal\n            };\n        },\n\n        /**\n         * Extendable method for formatting each point's tooltip line\n         *\n         * @return {String} A string to be concatenated in to the common tooltip text\n         */\n        tooltipFormatter: function (pointFormat) {\n\n            // Insert options for valueDecimals, valuePrefix, and valueSuffix\n            var series = this.series,\n                seriesTooltipOptions = series.tooltipOptions,\n                valueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),\n                valuePrefix = seriesTooltipOptions.valuePrefix || '',\n                valueSuffix = seriesTooltipOptions.valueSuffix || '';\n\n            // Loop over the point array map and replace unformatted values with sprintf formatting markup\n            each(series.pointArrayMap || ['y'], function (key) {\n                key = '{point.' + key; // without the closing bracket\n                if (valuePrefix || valueSuffix) {\n                    pointFormat = pointFormat.replace(key + '}', valuePrefix + key + '}' + valueSuffix);\n                }\n                pointFormat = pointFormat.replace(key + '}', key + ':,.' + valueDecimals + 'f}');\n            });\n\n            return format(pointFormat, {\n                point: this,\n                series: this.series\n            });\n        },\n\n        /**\n         * Fire an event on the Point object.\n         * @param {String} eventType\n         * @param {Object} eventArgs Additional event arguments\n         * @param {Function} defaultFunction Default event handler\n         */\n        firePointEvent: function (eventType, eventArgs, defaultFunction) {\n            var point = this,\n                series = this.series,\n                seriesOptions = series.options;\n\n            // load event handlers on demand to save time on mouseover/out\n            if (seriesOptions.point.events[eventType] || (point.options && point.options.events && point.options.events[eventType])) {\n                this.importEvents();\n            }\n\n            // add default handler if in selection mode\n            if (eventType === 'click' && seriesOptions.allowPointSelect) {\n                defaultFunction = function (event) {\n                    // Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera\n                    if (point.select) { // Could be destroyed by prior event handlers (#2911)\n                        point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);\n                    }\n                };\n            }\n\n            fireEvent(this, eventType, eventArgs, defaultFunction);\n        },\n        visible: true\n    };\n    /**\n     * @classDescription The base function which all other series types inherit from. The data in the series is stored\n     * in various arrays.\n     *\n     * - First, series.options.data contains all the original config options for\n     * each point whether added by options or methods like series.addPoint.\n     * - Next, series.data contains those values converted to points, but in case the series data length\n     * exceeds the cropThreshold, or if the data is grouped, series.data doesn't contain all the points. It\n     * only contains the points that have been created on demand.\n     * - Then there's series.points that contains all currently visible point objects. In case of cropping,\n     * the cropped-away points are not part of this array. The series.points array starts at series.cropStart\n     * compared to series.data and series.options.data. If however the series data is grouped, these can't\n     * be correlated one to one.\n     * - series.xData and series.processedXData contain clean x values, equivalent to series.data and series.points.\n     * - series.yData and series.processedYData contain clean x values, equivalent to series.data and series.points.\n     *\n     * @param {Object} chart\n     * @param {Object} options\n     */\n    var Series = Highcharts.Series = function () {};\n\n    Series.prototype = {\n\n        isCartesian: true,\n        type: 'line',\n        pointClass: Point,\n        sorted: true, // requires the data to be sorted\n        requireSorting: true,\n        pointAttrToOptions: { // mapping between SVG attributes and the corresponding options\n            stroke: 'lineColor',\n            'stroke-width': 'lineWidth',\n            fill: 'fillColor',\n            r: 'radius'\n        },\n        directTouch: false,\n        axisTypes: ['xAxis', 'yAxis'],\n        colorCounter: 0,\n        parallelArrays: ['x', 'y'], // each point's x and y values are stored in this.xData and this.yData\n        init: function (chart, options) {\n            var series = this,\n                eventType,\n                events,\n                chartSeries = chart.series,\n                sortByIndex = function (a, b) {\n                    return pick(a.options.index, a._i) - pick(b.options.index, b._i);\n                };\n\n            series.chart = chart;\n            series.options = options = series.setOptions(options); // merge with plotOptions\n            series.linkedSeries = [];\n\n            // bind the axes\n            series.bindAxes();\n\n            // set some variables\n            extend(series, {\n                name: options.name,\n                state: NORMAL_STATE,\n                pointAttr: {},\n                visible: options.visible !== false, // true by default\n                selected: options.selected === true // false by default\n            });\n\n            // special\n            if (useCanVG) {\n                options.animation = false;\n            }\n\n            // register event listeners\n            events = options.events;\n            for (eventType in events) {\n                addEvent(series, eventType, events[eventType]);\n            }\n            if (\n                (events && events.click) ||\n                (options.point && options.point.events && options.point.events.click) ||\n                options.allowPointSelect\n            ) {\n                chart.runTrackerClick = true;\n            }\n\n            series.getColor();\n            series.getSymbol();\n\n            // Set the data\n            each(series.parallelArrays, function (key) {\n                series[key + 'Data'] = [];\n            });\n            series.setData(options.data, false);\n\n            // Mark cartesian\n            if (series.isCartesian) {\n                chart.hasCartesianSeries = true;\n            }\n\n            // Register it in the chart\n            chartSeries.push(series);\n            series._i = chartSeries.length - 1;\n\n            // Sort series according to index option (#248, #1123, #2456)\n            stableSort(chartSeries, sortByIndex);\n            if (this.yAxis) {\n                stableSort(this.yAxis.series, sortByIndex);\n            }\n\n            each(chartSeries, function (series, i) {\n                series.index = i;\n                series.name = series.name || 'Series ' + (i + 1);\n            });\n\n        },\n\n        /**\n         * Set the xAxis and yAxis properties of cartesian series, and register the series\n         * in the axis.series array\n         */\n        bindAxes: function () {\n            var series = this,\n                seriesOptions = series.options,\n                chart = series.chart,\n                axisOptions;\n\n            each(series.axisTypes || [], function (AXIS) { // repeat for xAxis and yAxis\n\n                each(chart[AXIS], function (axis) { // loop through the chart's axis objects\n                    axisOptions = axis.options;\n\n                    // apply if the series xAxis or yAxis option mathches the number of the\n                    // axis, or if undefined, use the first axis\n                    if ((seriesOptions[AXIS] === axisOptions.index) ||\n                            (seriesOptions[AXIS] !== UNDEFINED && seriesOptions[AXIS] === axisOptions.id) ||\n                            (seriesOptions[AXIS] === UNDEFINED && axisOptions.index === 0)) {\n\n                        // register this series in the axis.series lookup\n                        axis.series.push(series);\n\n                        // set this series.xAxis or series.yAxis reference\n                        series[AXIS] = axis;\n\n                        // mark dirty for redraw\n                        axis.isDirty = true;\n                    }\n                });\n\n                // The series needs an X and an Y axis\n                if (!series[AXIS] && series.optionalAxis !== AXIS) {\n                    error(18, true);\n                }\n\n            });\n        },\n\n        /**\n         * For simple series types like line and column, the data values are held in arrays like\n         * xData and yData for quick lookup to find extremes and more. For multidimensional series\n         * like bubble and map, this can be extended with arrays like zData and valueData by\n         * adding to the series.parallelArrays array.\n         */\n        updateParallelArrays: function (point, i) {\n            var series = point.series,\n                args = arguments,\n                fn = isNumber(i) ?\n                    // Insert the value in the given position\n                    function (key) {\n                        var val = key === 'y' && series.toYData ? series.toYData(point) : point[key];\n                        series[key + 'Data'][i] = val;\n                    } :\n                    // Apply the method specified in i with the following arguments as arguments\n                    function (key) {\n                        Array.prototype[i].apply(series[key + 'Data'], Array.prototype.slice.call(args, 2));\n                    };\n\n            each(series.parallelArrays, fn);\n        },\n\n        /**\n         * Return an auto incremented x value based on the pointStart and pointInterval options.\n         * This is only used if an x value is not given for the point that calls autoIncrement.\n         */\n        autoIncrement: function () {\n\n            var options = this.options,\n                xIncrement = this.xIncrement,\n                date,\n                pointInterval,\n                pointIntervalUnit = options.pointIntervalUnit;\n\n            xIncrement = pick(xIncrement, options.pointStart, 0);\n\n            this.pointInterval = pointInterval = pick(this.pointInterval, options.pointInterval, 1);\n\n            // Added code for pointInterval strings\n            if (pointIntervalUnit) {\n                date = new Date(xIncrement);\n\n                if (pointIntervalUnit === 'day') {\n                    date = +date[setDate](date[getDate]() + pointInterval);\n                } else if (pointIntervalUnit === 'month') {\n                    date = +date[setMonth](date[getMonth]() + pointInterval);\n                } else if (pointIntervalUnit === 'year') {\n                    date = +date[setFullYear](date[getFullYear]() + pointInterval);\n                }\n                pointInterval = date - xIncrement;\n            }\n\n            this.xIncrement = xIncrement + pointInterval;\n            return xIncrement;\n        },\n    \n        /**\n         * Set the series options by merging from the options tree\n         * @param {Object} itemOptions\n         */\n        setOptions: function (itemOptions) {\n            var chart = this.chart,\n                chartOptions = chart.options,\n                plotOptions = chartOptions.plotOptions,\n                userOptions = chart.userOptions || {},\n                userPlotOptions = userOptions.plotOptions || {},\n                typeOptions = plotOptions[this.type],\n                options,\n                zones;\n\n            this.userOptions = itemOptions;\n\n            // General series options take precedence over type options because otherwise, default\n            // type options like column.animation would be overwritten by the general option.\n            // But issues have been raised here (#3881), and the solution may be to distinguish\n            // between default option and userOptions like in the tooltip below.\n            options = merge(\n                typeOptions,\n                plotOptions.series,\n                itemOptions\n            );\n\n            // The tooltip options are merged between global and series specific options\n            this.tooltipOptions = merge(\n                defaultOptions.tooltip,\n                defaultOptions.plotOptions[this.type].tooltip,\n                userOptions.tooltip,\n                userPlotOptions.series && userPlotOptions.series.tooltip,\n                userPlotOptions[this.type] && userPlotOptions[this.type].tooltip,\n                itemOptions.tooltip\n            );\n\n            // Delete marker object if not allowed (#1125)\n            if (typeOptions.marker === null) {\n                delete options.marker;\n            }\n\n            // Handle color zones\n            this.zoneAxis = options.zoneAxis;\n            zones = this.zones = (options.zones || []).slice();\n            if ((options.negativeColor || options.negativeFillColor) && !options.zones) {\n                zones.push({\n                    value: options[this.zoneAxis + 'Threshold'] || options.threshold || 0,\n                    color: options.negativeColor,\n                    fillColor: options.negativeFillColor\n                });\n            }\n            if (zones.length) { // Push one extra zone for the rest\n                if (defined(zones[zones.length - 1].value)) {\n                    zones.push({\n                        color: this.color,\n                        fillColor: this.fillColor\n                    });\n                }\n            }\n            return options;\n        },\n\n        getCyclic: function (prop, value, defaults) {\n            var i,\n                userOptions = this.userOptions,\n                indexName = '_' + prop + 'Index',\n                counterName = prop + 'Counter';\n\n            if (!value) {\n                if (defined(userOptions[indexName])) { // after Series.update()\n                    i = userOptions[indexName];\n                } else {\n                    userOptions[indexName] = i = this.chart[counterName] % defaults.length;\n                    this.chart[counterName] += 1;\n                }\n                value = defaults[i];\n            }\n            this[prop] = value;\n        },\n\n        /**\n         * Get the series' color\n         */\n        getColor: function () {\n            if (this.options.colorByPoint) {\n                this.options.color = null; // #4359, selected slice got series.color even when colorByPoint was set.\n            } else {\n                this.getCyclic('color', this.options.color || defaultPlotOptions[this.type].color, this.chart.options.colors);\n            }\n        },\n        /**\n         * Get the series' symbol\n         */\n        getSymbol: function () {\n            var seriesMarkerOption = this.options.marker;\n\n            this.getCyclic('symbol', seriesMarkerOption.symbol, this.chart.options.symbols);\n\n            // don't substract radius in image symbols (#604)\n            if (/^url/.test(this.symbol)) {\n                seriesMarkerOption.radius = 0;\n            }\n        },\n\n        drawLegendSymbol: LegendSymbolMixin.drawLineMarker,\n\n        /**\n         * Replace the series data with a new set of data\n         * @param {Object} data\n         * @param {Object} redraw\n         */\n        setData: function (data, redraw, animation, updatePoints) {\n            var series = this,\n                oldData = series.points,\n                oldDataLength = (oldData && oldData.length) || 0,\n                dataLength,\n                options = series.options,\n                chart = series.chart,\n                firstPoint = null,\n                xAxis = series.xAxis,\n                i,\n                turboThreshold = options.turboThreshold,\n                pt,\n                xData = this.xData,\n                yData = this.yData,\n                pointArrayMap = series.pointArrayMap,\n                valueCount = pointArrayMap && pointArrayMap.length;\n\n            data = data || [];\n            dataLength = data.length;\n            redraw = pick(redraw, true);\n\n            // If the point count is the same as is was, just run Point.update which is\n            // cheaper, allows animation, and keeps references to points.\n            if (updatePoints !== false && dataLength && oldDataLength === dataLength && !series.cropped && !series.hasGroupedData && series.visible) {\n                each(data, function (point, i) {\n                    // .update doesn't exist on a linked, hidden series (#3709)\n                    if (oldData[i].update && point !== options.data[i]) {\n                        oldData[i].update(point, false, null, false);\n                    }\n                });\n\n            } else {\n\n                // Reset properties\n                series.xIncrement = null;\n\n                series.colorCounter = 0; // for series with colorByPoint (#1547)\n\n                // Update parallel arrays\n                each(this.parallelArrays, function (key) {\n                    series[key + 'Data'].length = 0;\n                });\n\n                // In turbo mode, only one- or twodimensional arrays of numbers are allowed. The\n                // first value is tested, and we assume that all the rest are defined the same\n                // way. Although the 'for' loops are similar, they are repeated inside each\n                // if-else conditional for max performance.\n                if (turboThreshold && dataLength > turboThreshold) {\n\n                    // find the first non-null point\n                    i = 0;\n                    while (firstPoint === null && i < dataLength) {\n                        firstPoint = data[i];\n                        i++;\n                    }\n\n\n                    if (isNumber(firstPoint)) { // assume all points are numbers\n                        for (i = 0; i < dataLength; i++) {\n                            xData[i] = this.autoIncrement();\n                            yData[i] = data[i];\n                        }\n                    } else if (isArray(firstPoint)) { // assume all points are arrays\n                        if (valueCount) { // [x, low, high] or [x, o, h, l, c]\n                            for (i = 0; i < dataLength; i++) {\n                                pt = data[i];\n                                xData[i] = pt[0];\n                                yData[i] = pt.slice(1, valueCount + 1);\n                            }\n                        } else { // [x, y]\n                            for (i = 0; i < dataLength; i++) {\n                                pt = data[i];\n                                xData[i] = pt[0];\n                                yData[i] = pt[1];\n                            }\n                        }\n                    } else {\n                        error(12); // Highcharts expects configs to be numbers or arrays in turbo mode\n                    }\n                } else {\n                    for (i = 0; i < dataLength; i++) {\n                        if (data[i] !== UNDEFINED) { // stray commas in oldIE\n                            pt = { series: series };\n                            series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);\n                            series.updateParallelArrays(pt, i);\n                        }\n                    }\n                }\n\n                // Forgetting to cast strings to numbers is a common caveat when handling CSV or JSON\n                if (isString(yData[0])) {\n                    error(14, true);\n                }\n\n                series.data = [];\n                series.options.data = series.userOptions.data = data;\n\n                // destroy old points\n                i = oldDataLength;\n                while (i--) {\n                    if (oldData[i] && oldData[i].destroy) {\n                        oldData[i].destroy();\n                    }\n                }\n\n                // reset minRange (#878)\n                if (xAxis) {\n                    xAxis.minRange = xAxis.userMinRange;\n                }\n\n                // redraw\n                series.isDirty = series.isDirtyData = chart.isDirtyBox = true;\n                animation = false;\n            }\n\n            // Typically for pie series, points need to be processed and generated\n            // prior to rendering the legend\n            if (options.legendType === 'point') {\n                this.processData();\n                this.generatePoints();\n            }\n\n            if (redraw) {\n                chart.redraw(animation);\n            }\n        },\n\n        /**\n         * Process the data by cropping away unused data points if the series is longer\n         * than the crop threshold. This saves computing time for lage series.\n         */\n        processData: function (force) {\n            var series = this,\n                processedXData = series.xData, // copied during slice operation below\n                processedYData = series.yData,\n                dataLength = processedXData.length,\n                croppedData,\n                cropStart = 0,\n                cropped,\n                distance,\n                closestPointRange,\n                xAxis = series.xAxis,\n                i, // loop variable\n                options = series.options,\n                cropThreshold = options.cropThreshold,\n                getExtremesFromAll = series.getExtremesFromAll || options.getExtremesFromAll, // #4599\n                isCartesian = series.isCartesian,\n                xExtremes,\n                val2lin = xAxis && xAxis.val2lin,\n                isLog = xAxis && xAxis.isLog,\n                min,\n                max;\n\n            // If the series data or axes haven't changed, don't go through this. Return false to pass\n            // the message on to override methods like in data grouping.\n            if (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {\n                return false;\n            }\n\n            if (xAxis) {\n                xExtremes = xAxis.getExtremes(); // corrected for log axis (#3053)\n                min = xExtremes.min;\n                max = xExtremes.max;\n            }\n\n            // optionally filter out points outside the plot area\n            if (isCartesian && series.sorted && !getExtremesFromAll && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {\n\n                // it's outside current extremes\n                if (processedXData[dataLength - 1] < min || processedXData[0] > max) {\n                    processedXData = [];\n                    processedYData = [];\n\n                // only crop if it's actually spilling out\n                } else if (processedXData[0] < min || processedXData[dataLength - 1] > max) {\n                    croppedData = this.cropData(series.xData, series.yData, min, max);\n                    processedXData = croppedData.xData;\n                    processedYData = croppedData.yData;\n                    cropStart = croppedData.start;\n                    cropped = true;\n                }\n            }\n\n\n            // Find the closest distance between processed points\n            i = processedXData.length || 1;\n            while (--i) {\n                distance = isLog ?\n                    val2lin(processedXData[i]) - val2lin(processedXData[i - 1]) :\n                    processedXData[i] - processedXData[i - 1];\n\n                if (distance > 0 && (closestPointRange === UNDEFINED || distance < closestPointRange)) {\n                    closestPointRange = distance;\n\n                // Unsorted data is not supported by the line tooltip, as well as data grouping and\n                // navigation in Stock charts (#725) and width calculation of columns (#1900)\n                } else if (distance < 0 && series.requireSorting) {\n                    error(15);\n                }\n            }\n\n            // Record the properties\n            series.cropped = cropped; // undefined or true\n            series.cropStart = cropStart;\n            series.processedXData = processedXData;\n            series.processedYData = processedYData;\n\n            series.closestPointRange = closestPointRange;\n\n        },\n\n        /**\n         * Iterate over xData and crop values between min and max. Returns object containing crop start/end\n         * cropped xData with corresponding part of yData, dataMin and dataMax within the cropped range\n         */\n        cropData: function (xData, yData, min, max) {\n            var dataLength = xData.length,\n                cropStart = 0,\n                cropEnd = dataLength,\n                cropShoulder = pick(this.cropShoulder, 1), // line-type series need one point outside\n                i,\n                j;\n\n            // iterate up to find slice start\n            for (i = 0; i < dataLength; i++) {\n                if (xData[i] >= min) {\n                    cropStart = mathMax(0, i - cropShoulder);\n                    break;\n                }\n            }\n\n            // proceed to find slice end\n            for (j = i; j < dataLength; j++) {\n                if (xData[j] > max) {\n                    cropEnd = j + cropShoulder;\n                    break;\n                }\n            }\n\n            return {\n                xData: xData.slice(cropStart, cropEnd),\n                yData: yData.slice(cropStart, cropEnd),\n                start: cropStart,\n                end: cropEnd\n            };\n        },\n\n\n        /**\n         * Generate the data point after the data has been processed by cropping away\n         * unused points and optionally grouped in Highcharts Stock.\n         */\n        generatePoints: function () {\n            var series = this,\n                options = series.options,\n                dataOptions = options.data,\n                data = series.data,\n                dataLength,\n                processedXData = series.processedXData,\n                processedYData = series.processedYData,\n                pointClass = series.pointClass,\n                processedDataLength = processedXData.length,\n                cropStart = series.cropStart || 0,\n                cursor,\n                hasGroupedData = series.hasGroupedData,\n                point,\n                points = [],\n                i;\n\n            if (!data && !hasGroupedData) {\n                var arr = [];\n                arr.length = dataOptions.length;\n                data = series.data = arr;\n            }\n\n            for (i = 0; i < processedDataLength; i++) {\n                cursor = cropStart + i;\n                if (!hasGroupedData) {\n                    if (data[cursor]) {\n                        point = data[cursor];\n                    } else if (dataOptions[cursor] !== UNDEFINED) { // #970\n                        data[cursor] = point = (new pointClass()).init(series, dataOptions[cursor], processedXData[i]);\n                    }\n                    points[i] = point;\n                } else {\n                    // splat the y data in case of ohlc data array\n                    points[i] = (new pointClass()).init(series, [processedXData[i]].concat(splat(processedYData[i])));\n                    points[i].dataGroup = series.groupMap[i];\n                }\n                points[i].index = cursor; // For faster access in Point.update\n            }\n\n            // Hide cropped-away points - this only runs when the number of points is above cropThreshold, or when\n            // swithching view from non-grouped data to grouped data (#637)\n            if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {\n                for (i = 0; i < dataLength; i++) {\n                    if (i === cropStart && !hasGroupedData) { // when has grouped data, clear all points\n                        i += processedDataLength;\n                    }\n                    if (data[i]) {\n                        data[i].destroyElements();\n                        data[i].plotX = UNDEFINED; // #1003\n                    }\n                }\n            }\n\n            series.data = data;\n            series.points = points;\n        },\n\n        /**\n         * Calculate Y extremes for visible data\n         */\n        getExtremes: function (yData) {\n            var xAxis = this.xAxis,\n                yAxis = this.yAxis,\n                xData = this.processedXData,\n                yDataLength,\n                activeYData = [],\n                activeCounter = 0,\n                xExtremes = xAxis.getExtremes(), // #2117, need to compensate for log X axis\n                xMin = xExtremes.min,\n                xMax = xExtremes.max,\n                validValue,\n                withinRange,\n                x,\n                y,\n                i,\n                j;\n\n            yData = yData || this.stackedYData || this.processedYData || [];\n            yDataLength = yData.length;\n\n            for (i = 0; i < yDataLength; i++) {\n\n                x = xData[i];\n                y = yData[i];\n\n                // For points within the visible range, including the first point outside the\n                // visible range, consider y extremes\n                validValue = (isNumber(y, true) || isArray(y)) && (!yAxis.isLog || (y.length || y > 0));\n                withinRange = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped ||\n                    ((xData[i + 1] || x) >= xMin &&    (xData[i - 1] || x) <= xMax);\n\n                if (validValue && withinRange) {\n\n                    j = y.length;\n                    if (j) { // array, like ohlc or range data\n                        while (j--) {\n                            if (y[j] !== null) {\n                                activeYData[activeCounter++] = y[j];\n                            }\n                        }\n                    } else {\n                        activeYData[activeCounter++] = y;\n                    }\n                }\n            }\n            this.dataMin = arrayMin(activeYData);\n            this.dataMax = arrayMax(activeYData);\n        },\n\n        /**\n         * Translate data points from raw data values to chart specific positioning data\n         * needed later in drawPoints, drawGraph and drawTracker.\n         */\n        translate: function () {\n            if (!this.processedXData) { // hidden series\n                this.processData();\n            }\n            this.generatePoints();\n            var series = this,\n                options = series.options,\n                stacking = options.stacking,\n                xAxis = series.xAxis,\n                categories = xAxis.categories,\n                yAxis = series.yAxis,\n                points = series.points,\n                dataLength = points.length,\n                hasModifyValue = !!series.modifyValue,\n                i,\n                pointPlacement = options.pointPlacement,\n                dynamicallyPlaced = pointPlacement === 'between' || isNumber(pointPlacement),\n                threshold = options.threshold,\n                stackThreshold = options.startFromThreshold ? threshold : 0,\n                plotX,\n                plotY,\n                lastPlotX,\n                stackIndicator,\n                closestPointRangePx = Number.MAX_VALUE;\n\n            // Translate each point\n            for (i = 0; i < dataLength; i++) {\n                var point = points[i],\n                    xValue = point.x,\n                    yValue = point.y,\n                    yBottom = point.low,\n                    stack = stacking && yAxis.stacks[(series.negStacks && yValue < (stackThreshold ? 0 : threshold) ? '-' : '') + series.stackKey],\n                    pointStack,\n                    stackValues;\n\n                // Discard disallowed y values for log axes (#3434)\n                if (yAxis.isLog && yValue !== null && yValue <= 0) {\n                    point.isNull = true;\n                }\n\n                // Get the plotX translation\n                point.plotX = plotX = correctFloat( // #5236\n                    mathMin(mathMax(-1e5, xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement, this.type === 'flags')), 1e5) // #3923\n                );\n\n                // Calculate the bottom y value for stacked series\n                if (stacking && series.visible && !point.isNull && stack && stack[xValue]) {\n                    stackIndicator = series.getStackIndicator(stackIndicator, xValue, series.index);\n                    pointStack = stack[xValue];\n                    stackValues = pointStack.points[stackIndicator.key];\n                    yBottom = stackValues[0];\n                    yValue = stackValues[1];\n\n                    if (yBottom === stackThreshold && stackIndicator.key === stack[xValue].base) {\n                        yBottom = pick(threshold, yAxis.min);\n                    }\n                    if (yAxis.isLog && yBottom <= 0) { // #1200, #1232\n                        yBottom = null;\n                    }\n\n                    point.total = point.stackTotal = pointStack.total;\n                    point.percentage = pointStack.total && (point.y / pointStack.total * 100);\n                    point.stackY = yValue;\n\n                    // Place the stack label\n                    pointStack.setOffset(series.pointXOffset || 0, series.barW || 0);\n\n                }\n\n                // Set translated yBottom or remove it\n                point.yBottom = defined(yBottom) ?\n                    yAxis.translate(yBottom, 0, 1, 0, 1) :\n                    null;\n\n                // general hook, used for Highstock compare mode\n                if (hasModifyValue) {\n                    yValue = series.modifyValue(yValue, point);\n                }\n\n                // Set the the plotY value, reset it for redraws\n                point.plotY = plotY = (typeof yValue === 'number' && yValue !== Infinity) ?\n                    mathMin(mathMax(-1e5, yAxis.translate(yValue, 0, 1, 0, 1)), 1e5) : // #3201\n                    UNDEFINED;\n                point.isInside = plotY !== UNDEFINED && plotY >= 0 && plotY <= yAxis.len && // #3519\n                    plotX >= 0 && plotX <= xAxis.len;\n\n\n                // Set client related positions for mouse tracking\n                point.clientX = dynamicallyPlaced ? correctFloat(xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement)) : plotX; // #1514, #5383, #5518\n\n                point.negative = point.y < (threshold || 0);\n\n                // some API data\n                point.category = categories && categories[point.x] !== UNDEFINED ?\n                    categories[point.x] : point.x;\n\n                // Determine auto enabling of markers (#3635, #5099)\n                if (!point.isNull) {\n                    if (lastPlotX !== undefined) {\n                        closestPointRangePx = mathMin(closestPointRangePx, mathAbs(plotX - lastPlotX));\n                    }\n                    lastPlotX = plotX;\n                }\n\n            }\n            series.closestPointRangePx = closestPointRangePx;\n        },\n\n        /**\n         * Return the series points with null points filtered out\n         */\n        getValidPoints: function (points, insideOnly) {\n            var chart = this.chart;\n            return grep(points || this.points || [], function isValidPoint(point) { // #3916, #5029\n                if (insideOnly && !chart.isInsidePlot(point.plotX, point.plotY, chart.inverted)) { // #5085\n                    return false;\n                }\n                return !point.isNull;\n            });\n        },\n\n        /**\n         * Set the clipping for the series. For animated series it is called twice, first to initiate\n         * animating the clip then the second time without the animation to set the final clip.\n         */\n        setClip: function (animation) {\n            var chart = this.chart,\n                options = this.options,\n                renderer = chart.renderer,\n                inverted = chart.inverted,\n                seriesClipBox = this.clipBox,\n                clipBox = seriesClipBox || chart.clipBox,\n                sharedClipKey = this.sharedClipKey || ['_sharedClip', animation && animation.duration, animation && animation.easing, clipBox.height, options.xAxis, options.yAxis].join(','), // #4526\n                clipRect = chart[sharedClipKey],\n                markerClipRect = chart[sharedClipKey + 'm'];\n\n            // If a clipping rectangle with the same properties is currently present in the chart, use that.\n            if (!clipRect) {\n\n                // When animation is set, prepare the initial positions\n                if (animation) {\n                    clipBox.width = 0;\n\n                    chart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect(\n                        -99, // include the width of the first marker\n                        inverted ? -chart.plotLeft : -chart.plotTop,\n                        99,\n                        inverted ? chart.chartWidth : chart.chartHeight\n                    );\n                }\n                chart[sharedClipKey] = clipRect = renderer.clipRect(clipBox);\n                // Create hashmap for series indexes\n                clipRect.count = { length: 0 };\n\n            }\n            if (animation) {\n                if (!clipRect.count[this.index]) {\n                    clipRect.count[this.index] = true;\n                    clipRect.count.length += 1;\n                }\n            }\n\n            if (options.clip !== false) {\n                this.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);\n                this.markerGroup.clip(markerClipRect);\n                this.sharedClipKey = sharedClipKey;\n            }\n\n            // Remove the shared clipping rectangle when all series are shown\n            if (!animation) {\n                if (clipRect.count[this.index]) {\n                    delete clipRect.count[this.index];\n                    clipRect.count.length -= 1;\n                }\n\n                if (clipRect.count.length === 0 && sharedClipKey && chart[sharedClipKey]) {\n                    if (!seriesClipBox) {\n                        chart[sharedClipKey] = chart[sharedClipKey].destroy();\n                    }\n                    if (chart[sharedClipKey + 'm']) {\n                        chart[sharedClipKey + 'm'] = chart[sharedClipKey + 'm'].destroy();\n                    }\n                }\n            }\n        },\n\n        /**\n         * Animate in the series\n         */\n        animate: function (init) {\n            var series = this,\n                chart = series.chart,\n                clipRect,\n                animation = animObject(series.options.animation),\n                sharedClipKey;\n\n            // Initialize the animation. Set up the clipping rectangle.\n            if (init) {\n\n                series.setClip(animation);\n\n            // Run the animation\n            } else {\n                sharedClipKey = this.sharedClipKey;\n                clipRect = chart[sharedClipKey];\n                if (clipRect) {\n                    clipRect.animate({\n                        width: chart.plotSizeX\n                    }, animation);\n                }\n                if (chart[sharedClipKey + 'm']) {\n                    chart[sharedClipKey + 'm'].animate({\n                        width: chart.plotSizeX + 99\n                    }, animation);\n                }\n\n                // Delete this function to allow it only once\n                series.animate = null;\n\n            }\n        },\n\n        /**\n         * This runs after animation to land on the final plot clipping\n         */\n        afterAnimate: function () {\n            this.setClip();\n            fireEvent(this, 'afterAnimate');\n        },\n\n        /**\n         * Draw the markers\n         */\n        drawPoints: function () {\n            var series = this,\n                pointAttr,\n                points = series.points,\n                chart = series.chart,\n                plotX,\n                plotY,\n                i,\n                point,\n                radius,\n                symbol,\n                isImage,\n                graphic,\n                options = series.options,\n                seriesMarkerOptions = options.marker,\n                seriesPointAttr = series.pointAttr[''],\n                pointMarkerOptions,\n                hasPointMarker,\n                enabled,\n                isInside,\n                markerGroup = series.markerGroup,\n                xAxis = series.xAxis,\n                globallyEnabled = pick(\n                    seriesMarkerOptions.enabled,\n                    xAxis.isRadial,\n                    series.closestPointRangePx > 2 * seriesMarkerOptions.radius\n                );\n\n            if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {\n\n                i = points.length;\n                while (i--) {\n                    point = points[i];\n                    plotX = mathFloor(point.plotX); // #1843\n                    plotY = point.plotY;\n                    graphic = point.graphic;\n                    pointMarkerOptions = point.marker || {};\n                    hasPointMarker = !!point.marker;\n                    enabled = (globallyEnabled && pointMarkerOptions.enabled === UNDEFINED) || pointMarkerOptions.enabled;\n                    isInside = point.isInside;\n\n                    // only draw the point if y is defined\n                    if (enabled && isNumber(plotY) && point.y !== null) {\n\n                        // shortcuts\n                        pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || seriesPointAttr;\n                        radius = pointAttr.r;\n                        symbol = pick(pointMarkerOptions.symbol, series.symbol);\n                        isImage = symbol.indexOf('url') === 0;\n\n                        if (graphic) { // update\n                            graphic[isInside ? 'show' : 'hide'](true) // Since the marker group isn't clipped, each individual marker must be toggled\n                                .attr(pointAttr) // #4759\n                                .animate(extend({\n                                    x: plotX - radius,\n                                    y: plotY - radius\n                                }, graphic.symbolName ? { // don't apply to image symbols #507\n                                    width: 2 * radius,\n                                    height: 2 * radius\n                                } : {}));\n                        } else if (isInside && (radius > 0 || isImage)) {\n                            point.graphic = graphic = chart.renderer.symbol(\n                                symbol,\n                                plotX - radius,\n                                plotY - radius,\n                                2 * radius,\n                                2 * radius,\n                                hasPointMarker ? pointMarkerOptions : seriesMarkerOptions\n                            )\n                            .attr(pointAttr)\n                            .add(markerGroup);\n                        }\n\n                    } else if (graphic) {\n                        point.graphic = graphic.destroy(); // #1269\n                    }\n                }\n            }\n\n        },\n\n        /**\n         * Convert state properties from API naming conventions to SVG attributes\n         *\n         * @param {Object} options API options object\n         * @param {Object} base1 SVG attribute object to inherit from\n         * @param {Object} base2 Second level SVG attribute object to inherit from\n         */\n        convertAttribs: function (options, base1, base2, base3) {\n            var conversion = this.pointAttrToOptions,\n                attr,\n                option,\n                obj = {};\n\n            options = options || {};\n            base1 = base1 || {};\n            base2 = base2 || {};\n            base3 = base3 || {};\n\n            for (attr in conversion) {\n                option = conversion[attr];\n                obj[attr] = pick(options[option], base1[attr], base2[attr], base3[attr]);\n            }\n            return obj;\n        },\n\n        /**\n         * Get the state attributes. Each series type has its own set of attributes\n         * that are allowed to change on a point's state change. Series wide attributes are stored for\n         * all series, and additionally point specific attributes are stored for all\n         * points with individual marker options. If such options are not defined for the point,\n         * a reference to the series wide attributes is stored in point.pointAttr.\n         */\n        getAttribs: function () {\n            var series = this,\n                seriesOptions = series.options,\n                normalOptions = defaultPlotOptions[series.type].marker ? seriesOptions.marker : seriesOptions,\n                stateOptions = normalOptions.states,\n                stateOptionsHover = stateOptions[HOVER_STATE],\n                pointStateOptionsHover,\n                seriesColor = series.color,\n                seriesNegativeColor = series.options.negativeColor,\n                normalDefaults = {\n                    stroke: seriesColor,\n                    fill: seriesColor\n                },\n                points = series.points || [], // #927\n                i,\n                j,\n                threshold,\n                point,\n                seriesPointAttr = [],\n                pointAttr,\n                pointAttrToOptions = series.pointAttrToOptions,\n                hasPointSpecificOptions = series.hasPointSpecificOptions,\n                defaultLineColor = normalOptions.lineColor,\n                defaultFillColor = normalOptions.fillColor,\n                turboThreshold = seriesOptions.turboThreshold,\n                zones = series.zones,\n                zoneAxis = series.zoneAxis || 'y',\n                zoneColor, \n                attr,\n                key;\n\n            // series type specific modifications\n            if (seriesOptions.marker) { // line, spline, area, areaspline, scatter\n\n                // if no hover radius is given, default to normal radius + 2\n                stateOptionsHover.radius = +stateOptionsHover.radius || +normalOptions.radius + +stateOptionsHover.radiusPlus;\n                stateOptionsHover.lineWidth = stateOptionsHover.lineWidth || normalOptions.lineWidth + stateOptionsHover.lineWidthPlus;\n\n            } else { // column, bar, pie\n\n                // if no hover color is given, brighten the normal color\n                stateOptionsHover.color = stateOptionsHover.color ||\n                    Color(stateOptionsHover.color || seriesColor)\n                        .brighten(stateOptionsHover.brightness).get();\n\n                // if no hover negativeColor is given, brighten the normal negativeColor\n                stateOptionsHover.negativeColor = stateOptionsHover.negativeColor ||\n                    Color(stateOptionsHover.negativeColor || seriesNegativeColor)\n                        .brighten(stateOptionsHover.brightness).get();\n            }\n\n            // general point attributes for the series normal state\n            seriesPointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, normalDefaults);\n\n            // HOVER_STATE and SELECT_STATE states inherit from normal state except the default radius\n            each([HOVER_STATE, SELECT_STATE], function (state) {\n                seriesPointAttr[state] =\n                        series.convertAttribs(stateOptions[state], seriesPointAttr[NORMAL_STATE]);\n            });\n\n            // set it\n            series.pointAttr = seriesPointAttr;\n\n\n            // Generate the point-specific attribute collections if specific point\n            // options are given. If not, create a referance to the series wide point\n            // attributes\n            i = points.length;\n            if (!turboThreshold || i < turboThreshold || hasPointSpecificOptions) {\n                while (i--) {\n                    point = points[i];\n                    normalOptions = (point.options && point.options.marker) || point.options;\n                    if (normalOptions && normalOptions.enabled === false) {\n                        normalOptions.radius = 0;\n                    }\n\n                    zoneColor = null;\n                    if (zones.length) {\n                        j = 0;\n                        threshold = zones[j];\n                        while (point[zoneAxis] >= threshold.value) {\n                            threshold = zones[++j];\n                        }\n\n                        point.color = point.fillColor = zoneColor = pick(threshold.color, series.color); // #3636, #4267, #4430 - inherit color from series, when color is undefined\n\n                    }\n\n                    hasPointSpecificOptions = seriesOptions.colorByPoint || point.color; // #868\n\n                    // check if the point has specific visual options\n                    if (point.options) {\n                        for (key in pointAttrToOptions) {\n                            if (defined(normalOptions[pointAttrToOptions[key]])) {\n                                hasPointSpecificOptions = true;\n                            }\n                        }\n                    }\n\n                    // a specific marker config object is defined for the individual point:\n                    // create it's own attribute collection\n                    if (hasPointSpecificOptions) {\n                        normalOptions = normalOptions || {};\n                        pointAttr = [];\n                        stateOptions = normalOptions.states || {}; // reassign for individual point\n                        pointStateOptionsHover = stateOptions[HOVER_STATE] = stateOptions[HOVER_STATE] || {};\n\n                        // Handle colors for column and pies\n                        if (!seriesOptions.marker || (point.negative && !pointStateOptionsHover.fillColor && !stateOptionsHover.fillColor)) { // column, bar, point or negative threshold for series with markers (#3636)\n                            // If no hover color is given, brighten the normal color. #1619, #2579\n                            pointStateOptionsHover[series.pointAttrToOptions.fill] = pointStateOptionsHover.color || (!point.options.color && stateOptionsHover[(point.negative && seriesNegativeColor ? 'negativeColor' : 'color')]) ||\n                                Color(point.color)\n                                    .brighten(pointStateOptionsHover.brightness || stateOptionsHover.brightness)\n                                    .get();\n                        }\n\n                        // normal point state inherits series wide normal state\n                        attr = { color: point.color }; // #868\n                        if (!defaultFillColor) { // Individual point color or negative color markers (#2219)\n                            attr.fillColor = point.color;\n                        }\n                        if (!defaultLineColor) {\n                            attr.lineColor = point.color; // Bubbles take point color, line markers use white\n                        }\n                        // Color is explicitly set to null or undefined (#1288, #4068)\n                        if (normalOptions.hasOwnProperty('color') && !normalOptions.color) {\n                            delete normalOptions.color;\n                        }\n\n                        // When zone is set, but series.states.hover.color is not set, apply zone color on hover, #4670: \n                        if (zoneColor && !stateOptionsHover.fillColor) {\n                            pointStateOptionsHover.fillColor = zoneColor;\n                        }\n\n                        pointAttr[NORMAL_STATE] = series.convertAttribs(extend(attr, normalOptions), seriesPointAttr[NORMAL_STATE]);\n\n                        // inherit from point normal and series hover\n                        pointAttr[HOVER_STATE] = series.convertAttribs(\n                            stateOptions[HOVER_STATE],\n                            seriesPointAttr[HOVER_STATE],\n                            pointAttr[NORMAL_STATE]\n                        );\n\n                        // inherit from point normal and series hover\n                        pointAttr[SELECT_STATE] = series.convertAttribs(\n                            stateOptions[SELECT_STATE],\n                            seriesPointAttr[SELECT_STATE],\n                            pointAttr[NORMAL_STATE]\n                        );\n\n\n                    // no marker config object is created: copy a reference to the series-wide\n                    // attribute collection\n                    } else {\n                        pointAttr = seriesPointAttr;\n                    }\n\n                    point.pointAttr = pointAttr;\n                }\n            }\n        },\n\n        /**\n         * Clear DOM objects and free up memory\n         */\n        destroy: function () {\n            var series = this,\n                chart = series.chart,\n                issue134 = /AppleWebKit\\/533/.test(userAgent),\n                destroy,\n                i,\n                data = series.data || [],\n                point,\n                prop,\n                axis;\n\n            // add event hook\n            fireEvent(series, 'destroy');\n\n            // remove all events\n            removeEvent(series);\n\n            // erase from axes\n            each(series.axisTypes || [], function (AXIS) {\n                axis = series[AXIS];\n                if (axis) {\n                    erase(axis.series, series);\n                    axis.isDirty = axis.forceRedraw = true;\n                }\n            });\n\n            // remove legend items\n            if (series.legendItem) {\n                series.chart.legend.destroyItem(series);\n            }\n\n            // destroy all points with their elements\n            i = data.length;\n            while (i--) {\n                point = data[i];\n                if (point && point.destroy) {\n                    point.destroy();\n                }\n            }\n            series.points = null;\n\n            // Clear the animation timeout if we are destroying the series during initial animation\n            clearTimeout(series.animationTimeout);\n\n            // Destroy all SVGElements associated to the series\n            for (prop in series) {\n                if (series[prop] instanceof SVGElement && !series[prop].survive) { // Survive provides a hook for not destroying\n\n                    // issue 134 workaround\n                    destroy = issue134 && prop === 'group' ?\n                        'hide' :\n                        'destroy';\n\n                    series[prop][destroy]();\n                }\n            }\n\n            // remove from hoverSeries\n            if (chart.hoverSeries === series) {\n                chart.hoverSeries = null;\n            }\n            erase(chart.series, series);\n\n            // clear all members\n            for (prop in series) {\n                delete series[prop];\n            }\n        },\n\n        /**\n         * Get the graph path\n         */\n        getGraphPath: function (points, nullsAsZeroes, connectCliffs) {\n            var series = this,\n                options = series.options,\n                step = options.step,\n                reversed,\n                graphPath = [],\n                xMap = [],\n                gap;\n\n            points = points || series.points;\n\n            // Bottom of a stack is reversed\n            reversed = points.reversed;\n            if (reversed) {\n                points.reverse();\n            }\n            // Reverse the steps (#5004)\n            step = { right: 1, center: 2 }[step] || (step && 3);\n            if (step && reversed) {\n                step = 4 - step;\n            }\n\n            // Remove invalid points, especially in spline (#5015)\n            if (options.connectNulls && !nullsAsZeroes && !connectCliffs) {\n                points = this.getValidPoints(points);\n            }\n\n            // Build the line\n            each(points, function (point, i) {\n\n                var plotX = point.plotX,\n                    plotY = point.plotY,\n                    lastPoint = points[i - 1],\n                    pathToPoint; // the path to this point from the previous\n\n                if ((point.leftCliff || (lastPoint && lastPoint.rightCliff)) && !connectCliffs) {\n                    gap = true; // ... and continue\n                }\n\n                // Line series, nullsAsZeroes is not handled\n                if (point.isNull && !defined(nullsAsZeroes) && i > 0) {\n                    gap = !options.connectNulls;\n\n                // Area series, nullsAsZeroes is set\n                } else if (point.isNull && !nullsAsZeroes) {\n                    gap = true;\n\n                } else {\n\n                    if (i === 0 || gap) {\n                        pathToPoint = [M, point.plotX, point.plotY];\n                \n                    } else if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object\n                    \n                        pathToPoint = series.getPointSpline(points, point, i);\n\n                    } else if (step) {\n\n                        if (step === 1) { // right\n                            pathToPoint = [\n                                L,\n                                lastPoint.plotX,\n                                plotY\n                            ];\n                        \n                        } else if (step === 2) { // center\n                            pathToPoint = [\n                                L,\n                                (lastPoint.plotX + plotX) / 2,\n                                lastPoint.plotY,\n                                L,\n                                (lastPoint.plotX + plotX) / 2,\n                                plotY\n                            ];\n                        \n                        } else {\n                            pathToPoint = [\n                                L,\n                                plotX,\n                                lastPoint.plotY\n                            ];\n                        }\n                        pathToPoint.push(L, plotX, plotY);\n\n                    } else {\n                        // normal line to next point\n                        pathToPoint = [\n                            L,\n                            plotX,\n                            plotY\n                        ];\n                    }\n\n                    // Prepare for animation. When step is enabled, there are two path nodes for each x value.\n                    xMap.push(point.x);\n                    if (step) {\n                        xMap.push(point.x);\n                    }\n\n                    graphPath.push.apply(graphPath, pathToPoint);\n                    gap = false;\n                }\n            });\n\n            graphPath.xMap = xMap;\n            series.graphPath = graphPath;\n\n            return graphPath;\n\n        },\n\n        /**\n         * Draw the actual graph\n         */\n        drawGraph: function () {\n            var series = this,\n                options = this.options,\n                props = [['graph', options.lineColor || this.color, options.dashStyle]],\n                lineWidth = options.lineWidth,\n                roundCap = options.linecap !== 'square',\n                graphPath = (this.gappedPath || this.getGraphPath).call(this),\n                zones = this.zones;\n\n            each(zones, function (threshold, i) {\n                props.push(['zoneGraph' + i, threshold.color || series.color, threshold.dashStyle || options.dashStyle]);\n            });\n\n            // Draw the graph\n            each(props, function (prop, i) {\n                var graphKey = prop[0],\n                    graph = series[graphKey],\n                    attribs;\n\n                if (graph) {\n                    graph.endX = graphPath.xMap;\n                    graph.animate({ d: graphPath });\n\n                } else if (lineWidth && graphPath.length) { // #1487\n                    attribs = {\n                        stroke: prop[1],\n                        'stroke-width': lineWidth,\n                        fill: 'none',\n                        zIndex: 1 // #1069\n                    };\n                    if (prop[2]) {\n                        attribs.dashstyle = prop[2];\n                    } else if (roundCap) {\n                        attribs['stroke-linecap'] = attribs['stroke-linejoin'] = 'round';\n                    }\n\n                    graph = series[graphKey] = series.chart.renderer.path(graphPath)\n                        .attr(attribs)\n                        .add(series.group)\n                        .shadow((i < 2) && options.shadow); // add shadow to normal series (0) or to first zone (1) #3932\n                }\n\n                // Helpers for animation\n                if (graph) {\n                    graph.startX = graphPath.xMap;\n                    //graph.shiftUnit = options.step ? 2 : 1;\n                    graph.isArea = graphPath.isArea; // For arearange animation\n                }\n            });\n        },\n\n        /**\n         * Clip the graphs into the positive and negative coloured graphs\n         */\n        applyZones: function () {\n            var series = this,\n                chart = this.chart,\n                renderer = chart.renderer,\n                zones = this.zones,\n                translatedFrom,\n                translatedTo,\n                clips = this.clips || [],\n                clipAttr,\n                graph = this.graph,\n                area = this.area,\n                chartSizeMax = mathMax(chart.chartWidth, chart.chartHeight),\n                axis = this[(this.zoneAxis || 'y') + 'Axis'],\n                extremes,\n                reversed,\n                inverted = chart.inverted,\n                horiz,\n                pxRange,\n                pxPosMin,\n                pxPosMax,\n                ignoreZones = false;\n\n            if (zones.length && (graph || area) && axis && axis.min !== UNDEFINED) {\n                reversed = axis.reversed;\n                horiz = axis.horiz;\n                // The use of the Color Threshold assumes there are no gaps\n                // so it is safe to hide the original graph and area\n                if (graph) {\n                    graph.hide();\n                }\n                if (area) {\n                    area.hide();\n                }\n\n                // Create the clips\n                extremes = axis.getExtremes();\n                each(zones, function (threshold, i) {\n\n                    translatedFrom = reversed ?\n                        (horiz ? chart.plotWidth : 0) :\n                        (horiz ? 0 : axis.toPixels(extremes.min));\n                    translatedFrom = mathMin(mathMax(pick(translatedTo, translatedFrom), 0), chartSizeMax);\n                    translatedTo = mathMin(mathMax(mathRound(axis.toPixels(pick(threshold.value, extremes.max), true)), 0), chartSizeMax);\n\n                    if (ignoreZones) {\n                        translatedFrom = translatedTo = axis.toPixels(extremes.max);\n                    }\n\n                    pxRange = Math.abs(translatedFrom - translatedTo);\n                    pxPosMin = mathMin(translatedFrom, translatedTo);\n                    pxPosMax = mathMax(translatedFrom, translatedTo);\n                    if (axis.isXAxis) {\n                        clipAttr = {\n                            x: inverted ? pxPosMax : pxPosMin,\n                            y: 0,\n                            width: pxRange,\n                            height: chartSizeMax\n                        };\n                        if (!horiz) {\n                            clipAttr.x = chart.plotHeight - clipAttr.x;\n                        }\n                    } else {\n                        clipAttr = {\n                            x: 0,\n                            y: inverted ? pxPosMax : pxPosMin,\n                            width: chartSizeMax,\n                            height: pxRange\n                        };\n                        if (horiz) {\n                            clipAttr.y = chart.plotWidth - clipAttr.y;\n                        }\n                    }\n\n                    /// VML SUPPPORT\n                    if (inverted && renderer.isVML) {\n                        if (axis.isXAxis) {\n                            clipAttr = {\n                                x: 0,\n                                y: reversed ? pxPosMin : pxPosMax,\n                                height: clipAttr.width,\n                                width: chart.chartWidth\n                            };\n                        } else {\n                            clipAttr = {\n                                x: clipAttr.y - chart.plotLeft - chart.spacingBox.x,\n                                y: 0,\n                                width: clipAttr.height,\n                                height: chart.chartHeight\n                            };\n                        }\n                    }\n                    /// END OF VML SUPPORT\n\n                    if (clips[i]) {\n                        clips[i].animate(clipAttr);\n                    } else {\n                        clips[i] = renderer.clipRect(clipAttr);\n\n                        if (graph) {\n                            series['zoneGraph' + i].clip(clips[i]);\n                        }\n\n                        if (area) {\n                            series['zoneArea' + i].clip(clips[i]);\n                        }\n                    }\n                    // if this zone extends out of the axis, ignore the others\n                    ignoreZones = threshold.value > extremes.max;\n                });\n                this.clips = clips;\n            }\n        },\n\n        /**\n         * Initialize and perform group inversion on series.group and series.markerGroup\n         */\n        invertGroups: function () {\n            var series = this,\n                chart = series.chart;\n\n            // Pie, go away (#1736)\n            if (!series.xAxis) {\n                return;\n            }\n\n            // A fixed size is needed for inversion to work\n            function setInvert() {\n                var size = {\n                    width: series.yAxis.len,\n                    height: series.xAxis.len\n                };\n\n                each(['group', 'markerGroup'], function (groupName) {\n                    if (series[groupName]) {\n                        series[groupName].attr(size).invert();\n                    }\n                });\n            }\n\n            addEvent(chart, 'resize', setInvert); // do it on resize\n            addEvent(series, 'destroy', function () {\n                removeEvent(chart, 'resize', setInvert);\n            });\n\n            // Do it now\n            setInvert(); // do it now\n\n            // On subsequent render and redraw, just do setInvert without setting up events again\n            series.invertGroups = setInvert;\n        },\n\n        /**\n         * General abstraction for creating plot groups like series.group, series.dataLabelsGroup and\n         * series.markerGroup. On subsequent calls, the group will only be adjusted to the updated plot size.\n         */\n        plotGroup: function (prop, name, visibility, zIndex, parent) {\n            var group = this[prop],\n                isNew = !group;\n\n            // Generate it on first call\n            if (isNew) {\n                this[prop] = group = this.chart.renderer.g(name)\n                    .attr({\n                        zIndex: zIndex || 0.1 // IE8 and pointer logic use this\n                    })\n                    .add(parent);\n\n                group.addClass('highcharts-series-' + this.index);\n            }\n\n            // Place it on first and subsequent (redraw) calls\n            group.attr({ visibility: visibility })[isNew ? 'attr' : 'animate'](this.getPlotBox());\n            return group;\n        },\n\n        /**\n         * Get the translation and scale for the plot area of this series\n         */\n        getPlotBox: function () {\n            var chart = this.chart,\n                xAxis = this.xAxis,\n                yAxis = this.yAxis;\n\n            // Swap axes for inverted (#2339)\n            if (chart.inverted) {\n                xAxis = yAxis;\n                yAxis = this.xAxis;\n            }\n            return {\n                translateX: xAxis ? xAxis.left : chart.plotLeft,\n                translateY: yAxis ? yAxis.top : chart.plotTop,\n                scaleX: 1, // #1623\n                scaleY: 1\n            };\n        },\n\n        /**\n         * Render the graph and markers\n         */\n        render: function () {\n            var series = this,\n                chart = series.chart,\n                group,\n                options = series.options,\n                // Animation doesn't work in IE8 quirks when the group div is hidden,\n                // and looks bad in other oldIE\n                animDuration = !!series.animate && chart.renderer.isSVG && animObject(options.animation).duration,\n                visibility = series.visible ? 'inherit' : 'hidden', // #2597\n                zIndex = options.zIndex,\n                hasRendered = series.hasRendered,\n                chartSeriesGroup = chart.seriesGroup;\n\n            // the group\n            group = series.plotGroup(\n                'group',\n                'series',\n                visibility,\n                zIndex,\n                chartSeriesGroup\n            );\n\n            series.markerGroup = series.plotGroup(\n                'markerGroup',\n                'markers',\n                visibility,\n                zIndex,\n                chartSeriesGroup\n            );\n\n            // initiate the animation\n            if (animDuration) {\n                series.animate(true);\n            }\n\n            // cache attributes for shapes\n            series.getAttribs();\n\n            // SVGRenderer needs to know this before drawing elements (#1089, #1795)\n            group.inverted = series.isCartesian ? chart.inverted : false;\n\n            // draw the graph if any\n            if (series.drawGraph) {\n                series.drawGraph();\n                series.applyZones();\n            }\n\n            each(series.points, function (point) {\n                if (point.redraw) {\n                    point.redraw();\n                }\n            });\n\n            // draw the data labels (inn pies they go before the points)\n            if (series.drawDataLabels) {\n                series.drawDataLabels();\n            }\n\n            // draw the points\n            if (series.visible) {\n                series.drawPoints();\n            }\n\n\n            // draw the mouse tracking area\n            if (series.drawTracker && series.options.enableMouseTracking !== false) {\n                series.drawTracker();\n            }\n\n            // Handle inverted series and tracker groups\n            if (chart.inverted) {\n                series.invertGroups();\n            }\n\n            // Initial clipping, must be defined after inverting groups for VML. Applies to columns etc. (#3839).\n            if (options.clip !== false && !series.sharedClipKey && !hasRendered) {\n                group.clip(chart.clipRect);\n            }\n\n            // Run the animation\n            if (animDuration) {\n                series.animate();\n            }\n\n            // Call the afterAnimate function on animation complete (but don't overwrite the animation.complete option\n            // which should be available to the user).\n            if (!hasRendered) {\n                series.animationTimeout = syncTimeout(function () {\n                    series.afterAnimate();\n                }, animDuration);\n            }\n\n            series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see\n            // (See #322) series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see\n            series.hasRendered = true;\n        },\n\n        /**\n         * Redraw the series after an update in the axes.\n         */\n        redraw: function () {\n            var series = this,\n                chart = series.chart,\n                wasDirty = series.isDirty || series.isDirtyData, // cache it here as it is set to false in render, but used after\n                group = series.group,\n                xAxis = series.xAxis,\n                yAxis = series.yAxis;\n\n            // reposition on resize\n            if (group) {\n                if (chart.inverted) {\n                    group.attr({\n                        width: chart.plotWidth,\n                        height: chart.plotHeight\n                    });\n                }\n\n                group.animate({\n                    translateX: pick(xAxis && xAxis.left, chart.plotLeft),\n                    translateY: pick(yAxis && yAxis.top, chart.plotTop)\n                });\n            }\n\n            series.translate();\n            series.render();\n            if (wasDirty) { // #3868, #3945\n                delete this.kdTree;\n            }\n        },\n\n        /**\n         * KD Tree && PointSearching Implementation\n         */\n\n        kdDimensions: 1,\n        kdAxisArray: ['clientX', 'plotY'],\n\n        searchPoint: function (e, compareX) {\n            var series = this,\n                xAxis = series.xAxis,\n                yAxis = series.yAxis,\n                inverted = series.chart.inverted;\n\n            return this.searchKDTree({\n                clientX: inverted ? xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos,\n                plotY: inverted ? yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos\n            }, compareX);\n        },\n\n        buildKDTree: function () {\n            var series = this,\n                dimensions = series.kdDimensions;\n\n            // Internal function\n            function _kdtree(points, depth, dimensions) {\n                var axis,\n                    median,\n                    length = points && points.length;\n\n                if (length) {\n\n                    // alternate between the axis\n                    axis = series.kdAxisArray[depth % dimensions];\n\n                    // sort point array\n                    points.sort(function (a, b) {\n                        return a[axis] - b[axis];\n                    });\n\n                    median = Math.floor(length / 2);\n\n                    // build and return nod\n                    return {\n                        point: points[median],\n                        left: _kdtree(points.slice(0, median), depth + 1, dimensions),\n                        right: _kdtree(points.slice(median + 1), depth + 1, dimensions)\n                    };\n\n                }\n            }\n\n            // Start the recursive build process with a clone of the points array and null points filtered out (#3873)\n            function startRecursive() {\n                series.kdTree = _kdtree(\n                    series.getValidPoints(\n                        null,\n                        !series.directTouch // For line-type series restrict to plot area, but column-type series not (#3916, #4511)\n                    ),\n                    dimensions,\n                    dimensions\n                );\n            }\n            delete series.kdTree;\n\n            // For testing tooltips, don't build async\n            syncTimeout(startRecursive, series.options.kdNow ? 0 : 1);\n        },\n\n        searchKDTree: function (point, compareX) {\n            var series = this,\n                kdX = this.kdAxisArray[0],\n                kdY = this.kdAxisArray[1],\n                kdComparer = compareX ? 'distX' : 'dist';\n\n            // Set the one and two dimensional distance on the point object\n            function setDistance(p1, p2) {\n                var x = (defined(p1[kdX]) && defined(p2[kdX])) ? Math.pow(p1[kdX] - p2[kdX], 2) : null,\n                    y = (defined(p1[kdY]) && defined(p2[kdY])) ? Math.pow(p1[kdY] - p2[kdY], 2) : null,\n                    r = (x || 0) + (y || 0);\n\n                p2.dist = defined(r) ? Math.sqrt(r) : Number.MAX_VALUE;\n                p2.distX = defined(x) ? Math.sqrt(x) : Number.MAX_VALUE;\n            }\n            function _search(search, tree, depth, dimensions) {\n                var point = tree.point,\n                    axis = series.kdAxisArray[depth % dimensions],\n                    tdist,\n                    sideA,\n                    sideB,\n                    ret = point,\n                    nPoint1,\n                    nPoint2;\n\n                setDistance(search, point);\n\n                // Pick side based on distance to splitting point\n                tdist = search[axis] - point[axis];\n                sideA = tdist < 0 ? 'left' : 'right';\n                sideB = tdist < 0 ? 'right' : 'left';\n\n                // End of tree\n                if (tree[sideA]) {\n                    nPoint1 = _search(search, tree[sideA], depth + 1, dimensions);\n\n                    ret = (nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point);\n                }\n                if (tree[sideB]) {\n                    // compare distance to current best to splitting point to decide wether to check side B or not\n                    if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {\n                        nPoint2 = _search(search, tree[sideB], depth + 1, dimensions);\n                        ret = (nPoint2[kdComparer] < ret[kdComparer] ? nPoint2 : ret);\n                    }\n                }\n\n                return ret;\n            }\n\n            if (!this.kdTree) {\n                this.buildKDTree();\n            }\n\n            if (this.kdTree) {\n                return _search(point,\n                    this.kdTree, this.kdDimensions, this.kdDimensions);\n            }\n        }\n\n    }; // end Series prototype\n\n    /**\n     * The class for stack items\n     */\n    function StackItem(axis, options, isNegative, x, stackOption) {\n\n        var inverted = axis.chart.inverted;\n\n        this.axis = axis;\n\n        // Tells if the stack is negative\n        this.isNegative = isNegative;\n\n        // Save the options to be able to style the label\n        this.options = options;\n\n        // Save the x value to be able to position the label later\n        this.x = x;\n\n        // Initialize total value\n        this.total = null;\n\n        // This will keep each points' extremes stored by series.index and point index\n        this.points = {};\n\n        // Save the stack option on the series configuration object, and whether to treat it as percent\n        this.stack = stackOption;\n        this.leftCliff = 0;\n        this.rightCliff = 0;\n\n        // The align options and text align varies on whether the stack is negative and\n        // if the chart is inverted or not.\n        // First test the user supplied value, then use the dynamic.\n        this.alignOptions = {\n            align: options.align || (inverted ? (isNegative ? 'left' : 'right') : 'center'),\n            verticalAlign: options.verticalAlign || (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),\n            y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),\n            x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)\n        };\n\n        this.textAlign = options.textAlign || (inverted ? (isNegative ? 'right' : 'left') : 'center');\n    }\n\n    StackItem.prototype = {\n        destroy: function () {\n            destroyObjectProperties(this, this.axis);\n        },\n\n        /**\n         * Renders the stack total label and adds it to the stack label group.\n         */\n        render: function (group) {\n            var options = this.options,\n                formatOption = options.format,\n                str = formatOption ?\n                    format(formatOption, this) :\n                    options.formatter.call(this);  // format the text in the label\n\n            // Change the text to reflect the new total and set visibility to hidden in case the serie is hidden\n            if (this.label) {\n                this.label.attr({ text: str, visibility: 'hidden' });\n            // Create new label\n            } else {\n                this.label =\n                    this.axis.chart.renderer.text(str, null, null, options.useHTML)        // dummy positions, actual position updated with setOffset method in columnseries\n                        .css(options.style)                // apply style\n                        .attr({\n                            align: this.textAlign,                // fix the text-anchor\n                            rotation: options.rotation,    // rotation\n                            visibility: HIDDEN                    // hidden until setOffset is called\n                        })\n                        .add(group);                            // add to the labels-group\n            }\n        },\n\n        /**\n         * Sets the offset that the stack has from the x value and repositions the label.\n         */\n        setOffset: function (xOffset, xWidth) {\n            var stackItem = this,\n                axis = stackItem.axis,\n                chart = axis.chart,\n                inverted = chart.inverted,\n                reversed = axis.reversed,\n                neg = (this.isNegative && !reversed) || (!this.isNegative && reversed), // #4056\n                y = axis.translate(axis.usePercentage ? 100 : this.total, 0, 0, 0, 1), // stack value translated mapped to chart coordinates\n                yZero = axis.translate(0),                        // stack origin\n                h = mathAbs(y - yZero),                            // stack height\n                x = chart.xAxis[0].translate(this.x) + xOffset,    // stack x position\n                plotHeight = chart.plotHeight,\n                stackBox = {    // this is the box for the complete stack\n                    x: inverted ? (neg ? y : y - h) : x,\n                    y: inverted ? plotHeight - x - xWidth : (neg ? (plotHeight - y - h) : plotHeight - y),\n                    width: inverted ? h : xWidth,\n                    height: inverted ? xWidth : h\n                },\n                label = this.label,\n                alignAttr;\n\n            if (label) {\n                label.align(this.alignOptions, null, stackBox);    // align the label to the box\n\n                // Set visibility (#678)\n                alignAttr = label.alignAttr;\n                label[this.options.crop === false || chart.isInsidePlot(alignAttr.x, alignAttr.y) ? 'show' : 'hide'](true);\n            }\n        }\n    };\n\n    /**\n     * Generate stacks for each series and calculate stacks total values\n     */\n    Chart.prototype.getStacks = function () {\n        var chart = this;\n\n        // reset stacks for each yAxis\n        each(chart.yAxis, function (axis) {\n            if (axis.stacks && axis.hasVisibleSeries) {\n                axis.oldStacks = axis.stacks;\n            }\n        });\n\n        each(chart.series, function (series) {\n            if (series.options.stacking && (series.visible === true || chart.options.chart.ignoreHiddenSeries === false)) {\n                series.stackKey = series.type + pick(series.options.stack, '');\n            }\n        });\n    };\n\n\n    // Stacking methods defined on the Axis prototype\n\n    /**\n     * Build the stacks from top down\n     */\n    Axis.prototype.buildStacks = function () {\n        var axisSeries = this.series,\n            series,\n            reversedStacks = pick(this.options.reversedStacks, true),\n            len = axisSeries.length,\n            i;\n        if (!this.isXAxis) {\n            this.usePercentage = false;\n            i = len;\n            while (i--) {\n                axisSeries[reversedStacks ? i : len - i - 1].setStackedPoints();\n            }\n\n            i = len;\n            while (i--) {\n                series = axisSeries[reversedStacks ? i : len - i - 1];\n                if (series.setStackCliffs) {\n                    series.setStackCliffs();\n                }\n            }\n            // Loop up again to compute percent stack\n            if (this.usePercentage) {\n                for (i = 0; i < len; i++) {\n                    axisSeries[i].setPercentStacks();\n                }\n            }\n        }\n    };\n\n    Axis.prototype.renderStackTotals = function () {\n        var axis = this,\n            chart = axis.chart,\n            renderer = chart.renderer,\n            stacks = axis.stacks,\n            stackKey,\n            oneStack,\n            stackCategory,\n            stackTotalGroup = axis.stackTotalGroup;\n\n        // Create a separate group for the stack total labels\n        if (!stackTotalGroup) {\n            axis.stackTotalGroup = stackTotalGroup =\n                renderer.g('stack-labels')\n                    .attr({\n                        visibility: VISIBLE,\n                        zIndex: 6\n                    })\n                    .add();\n        }\n\n        // plotLeft/Top will change when y axis gets wider so we need to translate the\n        // stackTotalGroup at every render call. See bug #506 and #516\n        stackTotalGroup.translate(chart.plotLeft, chart.plotTop);\n\n        // Render each stack total\n        for (stackKey in stacks) {\n            oneStack = stacks[stackKey];\n            for (stackCategory in oneStack) {\n                oneStack[stackCategory].render(stackTotalGroup);\n            }\n        }\n    };\n\n    /**\n     * Set all the stacks to initial states and destroy unused ones.\n     */\n    Axis.prototype.resetStacks = function () {\n        var stacks = this.stacks,\n            type,\n            i;\n        if (!this.isXAxis) {\n            for (type in stacks) {\n                for (i in stacks[type]) {\n\n                    // Clean up memory after point deletion (#1044, #4320)\n                    if (stacks[type][i].touched < this.stacksTouched) {\n                        stacks[type][i].destroy();\n                        delete stacks[type][i];\n\n                    // Reset stacks\n                    } else {\n                        stacks[type][i].total = null;\n                        stacks[type][i].cum = 0;\n                    }\n                }\n            }\n        }\n    };\n\n    Axis.prototype.cleanStacks = function () {\n        var stacks, type, i;\n\n        if (!this.isXAxis) {\n            if (this.oldStacks) {\n                stacks = this.stacks = this.oldStacks;\n            }\n\n            // reset stacks\n            for (type in stacks) {\n                for (i in stacks[type]) {\n                    stacks[type][i].cum = stacks[type][i].total;\n                }\n            }\n        }\n    };\n\n\n    // Stacking methods defnied for Series prototype\n\n    /**\n     * Adds series' points value to corresponding stack\n     */\n    Series.prototype.setStackedPoints = function () {\n        if (!this.options.stacking || (this.visible !== true && this.chart.options.chart.ignoreHiddenSeries !== false)) {\n            return;\n        }\n\n        var series = this,\n            xData = series.processedXData,\n            yData = series.processedYData,\n            stackedYData = [],\n            yDataLength = yData.length,\n            seriesOptions = series.options,\n            threshold = seriesOptions.threshold,\n            stackThreshold = seriesOptions.startFromThreshold ? threshold : 0,\n            stackOption = seriesOptions.stack,\n            stacking = seriesOptions.stacking,\n            stackKey = series.stackKey,\n            negKey = '-' + stackKey,\n            negStacks = series.negStacks,\n            yAxis = series.yAxis,\n            stacks = yAxis.stacks,\n            oldStacks = yAxis.oldStacks,\n            stackIndicator,\n            isNegative,\n            stack,\n            other,\n            key,\n            pointKey,\n            i,\n            x,\n            y;\n\n\n        yAxis.stacksTouched += 1;\n\n        // loop over the non-null y values and read them into a local array\n        for (i = 0; i < yDataLength; i++) {\n            x = xData[i];\n            y = yData[i];\n            stackIndicator = series.getStackIndicator(stackIndicator, x, series.index);\n            pointKey = stackIndicator.key;\n            // Read stacked values into a stack based on the x value,\n            // the sign of y and the stack key. Stacking is also handled for null values (#739)\n            isNegative = negStacks && y < (stackThreshold ? 0 : threshold);\n            key = isNegative ? negKey : stackKey;\n\n            // Create empty object for this stack if it doesn't exist yet\n            if (!stacks[key]) {\n                stacks[key] = {};\n            }\n\n            // Initialize StackItem for this x\n            if (!stacks[key][x]) {\n                if (oldStacks[key] && oldStacks[key][x]) {\n                    stacks[key][x] = oldStacks[key][x];\n                    stacks[key][x].total = null;\n                } else {\n                    stacks[key][x] = new StackItem(yAxis, yAxis.options.stackLabels, isNegative, x, stackOption);\n                }\n            }\n\n            // If the StackItem doesn't exist, create it first\n            stack = stacks[key][x];\n            if (y !== null) {\n                stack.points[pointKey] = stack.points[series.index] = [pick(stack.cum, stackThreshold)];\n\n                // Record the base of the stack\n                if (!defined(stack.cum)) {\n                    stack.base = pointKey;\n                }\n                stack.touched = yAxis.stacksTouched;\n        \n\n                // In area charts, if there are multiple points on the same X value, let the \n                // area fill the full span of those points\n                if (stackIndicator.index > 0 && series.singleStacks === false) {\n                    stack.points[pointKey][0] = stack.points[series.index + ',' + x + ',0'][0];\n                }\n            }\n\n            // Add value to the stack total\n            if (stacking === 'percent') {\n\n                // Percent stacked column, totals are the same for the positive and negative stacks\n                other = isNegative ? stackKey : negKey;\n                if (negStacks && stacks[other] && stacks[other][x]) {\n                    other = stacks[other][x];\n                    stack.total = other.total = mathMax(other.total, stack.total) + mathAbs(y) || 0;\n\n                // Percent stacked areas\n                } else {\n                    stack.total = correctFloat(stack.total + (mathAbs(y) || 0));\n                }\n            } else {\n                stack.total = correctFloat(stack.total + (y || 0));\n            }\n\n            stack.cum = pick(stack.cum, stackThreshold) + (y || 0);\n\n            if (y !== null) {\n                stack.points[pointKey].push(stack.cum);\n                stackedYData[i] = stack.cum;\n            }\n\n        }\n\n        if (stacking === 'percent') {\n            yAxis.usePercentage = true;\n        }\n\n        this.stackedYData = stackedYData; // To be used in getExtremes\n\n        // Reset old stacks\n        yAxis.oldStacks = {};\n    };\n\n    /**\n     * Iterate over all stacks and compute the absolute values to percent\n     */\n    Series.prototype.setPercentStacks = function () {\n        var series = this,\n            stackKey = series.stackKey,\n            stacks = series.yAxis.stacks,\n            processedXData = series.processedXData,\n            stackIndicator;\n\n        each([stackKey, '-' + stackKey], function (key) {\n            var i = processedXData.length,\n                x,\n                stack,\n                pointExtremes,\n                totalFactor;\n\n            while (i--) {\n                x = processedXData[i];\n                stackIndicator = series.getStackIndicator(stackIndicator, x, series.index);\n                stack = stacks[key] && stacks[key][x];\n                pointExtremes = stack && stack.points[stackIndicator.key];\n                if (pointExtremes) {\n                    totalFactor = stack.total ? 100 / stack.total : 0;\n                    pointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor); // Y bottom value\n                    pointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor); // Y value\n                    series.stackedYData[i] = pointExtremes[1];\n                }\n            }\n        });\n    };\n\n    /**\n    * Get stack indicator, according to it's x-value, to determine points with the same x-value\n    */\n    Series.prototype.getStackIndicator = function (stackIndicator, x, index) {\n        if (!defined(stackIndicator) || stackIndicator.x !== x) {\n            stackIndicator = {\n                x: x,\n                index: 0\n            };\n        } else {\n            stackIndicator.index++;\n        }\n\n        stackIndicator.key = [index, x, stackIndicator.index].join(',');\n\n        return stackIndicator;\n    };\n\n    // Extend the Chart prototype for dynamic methods\n    extend(Chart.prototype, {\n\n        /**\n         * Add a series dynamically after  time\n         *\n         * @param {Object} options The config options\n         * @param {Boolean} redraw Whether to redraw the chart after adding. Defaults to true.\n         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n         *    configuration\n         *\n         * @return {Object} series The newly created series object\n         */\n        addSeries: function (options, redraw, animation) {\n            var series,\n                chart = this;\n\n            if (options) {\n                redraw = pick(redraw, true); // defaults to true\n\n                fireEvent(chart, 'addSeries', { options: options }, function () {\n                    series = chart.initSeries(options);\n\n                    chart.isDirtyLegend = true; // the series array is out of sync with the display\n                    chart.linkSeries();\n                    if (redraw) {\n                        chart.redraw(animation);\n                    }\n                });\n            }\n\n            return series;\n        },\n\n        /**\n         * Add an axis to the chart\n         * @param {Object} options The axis option\n         * @param {Boolean} isX Whether it is an X axis or a value axis\n         */\n        addAxis: function (options, isX, redraw, animation) {\n            var key = isX ? 'xAxis' : 'yAxis',\n                chartOptions = this.options,\n                userOptions = merge(options, {\n                    index: this[key].length,\n                    isX: isX\n                });\n\n            new Axis(this, userOptions); // eslint-disable-line no-new\n\n            // Push the new axis options to the chart options\n            chartOptions[key] = splat(chartOptions[key] || {});\n            chartOptions[key].push(userOptions);\n\n            if (pick(redraw, true)) {\n                this.redraw(animation);\n            }\n        },\n\n        /**\n         * Dim the chart and show a loading text or symbol\n         * @param {String} str An optional text to show in the loading label instead of the default one\n         */\n        showLoading: function (str) {\n            var chart = this,\n                options = chart.options,\n                loadingDiv = chart.loadingDiv,\n                loadingOptions = options.loading,\n                setLoadingSize = function () {\n                    if (loadingDiv) {\n                        css(loadingDiv, {\n                            left: chart.plotLeft + PX,\n                            top: chart.plotTop + PX,\n                            width: chart.plotWidth + PX,\n                            height: chart.plotHeight + PX\n                        });\n                    }\n                };\n\n            // create the layer at the first call\n            if (!loadingDiv) {\n                chart.loadingDiv = loadingDiv = createElement(DIV, {\n                    className: PREFIX + 'loading'\n                }, extend(loadingOptions.style, {\n                    zIndex: 10,\n                    display: NONE\n                }), chart.container);\n\n                chart.loadingSpan = createElement(\n                    'span',\n                    null,\n                    loadingOptions.labelStyle,\n                    loadingDiv\n                );\n                addEvent(chart, 'redraw', setLoadingSize); // #1080\n            }\n\n            // update text\n            chart.loadingSpan.innerHTML = str || options.lang.loading;\n\n            // show it\n            if (!chart.loadingShown) {\n                css(loadingDiv, {\n                    opacity: 0,\n                    display: ''\n                });\n                animate(loadingDiv, {\n                    opacity: loadingOptions.style.opacity\n                }, {\n                    duration: loadingOptions.showDuration || 0\n                });\n                chart.loadingShown = true;\n            }\n            setLoadingSize();\n        },\n\n        /**\n         * Hide the loading layer\n         */\n        hideLoading: function () {\n            var options = this.options,\n                loadingDiv = this.loadingDiv;\n\n            if (loadingDiv) {\n                animate(loadingDiv, {\n                    opacity: 0\n                }, {\n                    duration: options.loading.hideDuration || 100,\n                    complete: function () {\n                        css(loadingDiv, { display: NONE });\n                    }\n                });\n            }\n            this.loadingShown = false;\n        }\n    });\n\n    // extend the Point prototype for dynamic methods\n    extend(Point.prototype, {\n        /**\n         * Update the point with new options (typically x/y data) and optionally redraw the series.\n         *\n         * @param {Object} options Point options as defined in the series.data array\n         * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n         *    configuration\n         *\n         */\n        update: function (options, redraw, animation, runEvent) {\n            var point = this,\n                series = point.series,\n                graphic = point.graphic,\n                i,\n                chart = series.chart,\n                seriesOptions = series.options;\n\n            redraw = pick(redraw, true);\n\n            function update() {\n\n                point.applyOptions(options);\n\n                // Update visuals\n                if (point.y === null && graphic) { // #4146\n                    point.graphic = graphic.destroy();\n                }\n                if (isObject(options, true)) {\n                    // Defer the actual redraw until getAttribs has been called (#3260)\n                    point.redraw = function () {\n                        if (graphic && graphic.element) {\n                            if (options && options.marker && options.marker.symbol) {\n                                point.graphic = graphic.destroy();\n                            }\n                        }\n                        if (options && options.dataLabels && point.dataLabel) { // #2468\n                            point.dataLabel = point.dataLabel.destroy();\n                        }\n                        point.redraw = null;\n                    };\n                }\n\n                // record changes in the parallel arrays\n                i = point.index;\n                series.updateParallelArrays(point, i);\n            \n                // Record the options to options.data. If there is an object from before,\n                // use point options, otherwise use raw options. (#4701)\n                seriesOptions.data[i] = isObject(seriesOptions.data[i], true) ? point.options : options;\n\n                // redraw\n                series.isDirty = series.isDirtyData = true;\n                if (!series.fixedBox && series.hasCartesianSeries) { // #1906, #2320\n                    chart.isDirtyBox = true;\n                }\n\n                if (seriesOptions.legendType === 'point') { // #1831, #1885\n                    chart.isDirtyLegend = true;\n                }\n                if (redraw) {\n                    chart.redraw(animation);\n                }\n            }\n\n            // Fire the event with a default handler of doing the update\n            if (runEvent === false) { // When called from setData\n                update();\n            } else {\n                point.firePointEvent('update', { options: options }, update);\n            }\n        },\n\n        /**\n         * Remove a point and optionally redraw the series and if necessary the axes\n         * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n         *    configuration\n         */\n        remove: function (redraw, animation) {\n            this.series.removePoint(inArray(this, this.series.data), redraw, animation);\n        }\n    });\n\n    // Extend the series prototype for dynamic methods\n    extend(Series.prototype, {\n        /**\n         * Add a point dynamically after chart load time\n         * @param {Object} options Point options as given in series.data\n         * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n         * @param {Boolean} shift If shift is true, a point is shifted off the start\n         *    of the series as one is appended to the end.\n         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n         *    configuration\n         */\n        addPoint: function (options, redraw, shift, animation) {\n            var series = this,\n                seriesOptions = series.options,\n                data = series.data,\n                chart = series.chart,\n                names = series.xAxis && series.xAxis.names,\n                dataOptions = seriesOptions.data,\n                point,\n                isInTheMiddle,\n                xData = series.xData,\n                i,\n                x;\n\n            // Optional redraw, defaults to true\n            redraw = pick(redraw, true);\n\n            // Get options and push the point to xData, yData and series.options. In series.generatePoints\n            // the Point instance will be created on demand and pushed to the series.data array.\n            point = { series: series };\n            series.pointClass.prototype.applyOptions.apply(point, [options]);\n            x = point.x;\n\n            // Get the insertion point\n            i = xData.length;\n            if (series.requireSorting && x < xData[i - 1]) {\n                isInTheMiddle = true;\n                while (i && xData[i - 1] > x) {\n                    i--;\n                }\n            }\n\n            series.updateParallelArrays(point, 'splice', i, 0, 0); // insert undefined item\n            series.updateParallelArrays(point, i); // update it\n\n            if (names && point.name) {\n                names[x] = point.name;\n            }\n            dataOptions.splice(i, 0, options);\n\n            if (isInTheMiddle) {\n                series.data.splice(i, 0, null);\n                series.processData();\n            }\n\n            // Generate points to be added to the legend (#1329)\n            if (seriesOptions.legendType === 'point') {\n                series.generatePoints();\n            }\n\n            // Shift the first point off the parallel arrays\n            if (shift) {\n                if (data[0] && data[0].remove) {\n                    data[0].remove(false);\n                } else {\n                    data.shift();\n                    series.updateParallelArrays(point, 'shift');\n\n                    dataOptions.shift();\n                }\n            }\n\n            // redraw\n            series.isDirty = true;\n            series.isDirtyData = true;\n\n            if (redraw) {\n                series.getAttribs(); // #1937\n                chart.redraw(animation); // Animation is set anyway on redraw, #5665\n            }\n        },\n\n        /**\n         * Remove a point (rendered or not), by index\n         */\n        removePoint: function (i, redraw, animation) {\n\n            var series = this,\n                data = series.data,\n                point = data[i],\n                points = series.points,\n                chart = series.chart,\n                remove = function () {\n\n                    if (points && points.length === data.length) { // #4935\n                        points.splice(i, 1);\n                    }\n                    data.splice(i, 1);\n                    series.options.data.splice(i, 1);\n                    series.updateParallelArrays(point || { series: series }, 'splice', i, 1);\n\n                    if (point) {\n                        point.destroy();\n                    }\n\n                    // redraw\n                    series.isDirty = true;\n                    series.isDirtyData = true;\n                    if (redraw) {\n                        chart.redraw();\n                    }\n                };\n\n            setAnimation(animation, chart);\n            redraw = pick(redraw, true);\n\n            // Fire the event with a default handler of removing the point\n            if (point) {\n                point.firePointEvent('remove', null, remove);\n            } else {\n                remove();\n            }\n        },\n\n        /**\n         * Remove a series and optionally redraw the chart\n         *\n         * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n         *    configuration\n         */\n        remove: function (redraw, animation, withEvent) {\n            var series = this,\n                chart = series.chart;\n\n            function remove() {\n\n                // Destroy elements\n                series.destroy();\n\n                // Redraw\n                chart.isDirtyLegend = chart.isDirtyBox = true;\n                chart.linkSeries();\n\n                if (pick(redraw, true)) {\n                    chart.redraw(animation);\n                }\n            }\n\n            // Fire the event with a default handler of removing the point\n            if (withEvent !== false) {\n                fireEvent(series, 'remove', null, remove);\n            } else {\n                remove();\n            }\n        },\n\n        /**\n         * Update the series with a new set of options\n         */\n        update: function (newOptions, redraw) {\n            var series = this,\n                chart = this.chart,\n                // must use user options when changing type because this.options is merged\n                // in with type specific plotOptions\n                oldOptions = this.userOptions,\n                oldType = this.type,\n                proto = seriesTypes[oldType].prototype,\n                preserve = ['group', 'markerGroup', 'dataLabelsGroup'],\n                n;\n\n            // If we're changing type or zIndex, create new groups (#3380, #3404)\n            if ((newOptions.type && newOptions.type !== oldType) || newOptions.zIndex !== undefined) {\n                preserve.length = 0;\n            }\n\n            // Make sure groups are not destroyed (#3094)\n            each(preserve, function (prop) {\n                preserve[prop] = series[prop];\n                delete series[prop];\n            });\n\n            // Do the merge, with some forced options\n            newOptions = merge(oldOptions, {\n                animation: false,\n                index: this.index,\n                pointStart: this.xData[0] // when updating after addPoint\n            }, { data: this.options.data }, newOptions);\n\n            // Destroy the series and delete all properties. Reinsert all methods\n            // and properties from the new type prototype (#2270, #3719)\n            this.remove(false, null, false);\n            for (n in proto) {\n                this[n] = UNDEFINED;\n            }\n            extend(this, seriesTypes[newOptions.type || oldType].prototype);\n\n            // Re-register groups (#3094)\n            each(preserve, function (prop) {\n                series[prop] = preserve[prop];\n            });\n\n            this.init(chart, newOptions);\n            chart.linkSeries(); // Links are lost in this.remove (#3028)\n            if (pick(redraw, true)) {\n                chart.redraw(false);\n            }\n        }\n    });\n\n    // Extend the Axis.prototype for dynamic methods\n    extend(Axis.prototype, {\n\n        /**\n         * Update the axis with a new options structure\n         */\n        update: function (newOptions, redraw) {\n            var chart = this.chart;\n\n            newOptions = chart.options[this.coll][this.options.index] = merge(this.userOptions, newOptions);\n\n            this.destroy(true);\n\n            this.init(chart, extend(newOptions, { events: UNDEFINED }));\n\n            chart.isDirtyBox = true;\n            if (pick(redraw, true)) {\n                chart.redraw();\n            }\n        },\n\n        /**\n         * Remove the axis from the chart\n         */\n        remove: function (redraw) {\n            var chart = this.chart,\n                key = this.coll, // xAxis or yAxis\n                axisSeries = this.series,\n                i = axisSeries.length;\n\n            // Remove associated series (#2687)\n            while (i--) {\n                if (axisSeries[i]) {\n                    axisSeries[i].remove(false);\n                }\n            }\n\n            // Remove the axis\n            erase(chart.axes, this);\n            erase(chart[key], this);\n            chart.options[key].splice(this.options.index, 1);\n            each(chart[key], function (axis, i) { // Re-index, #1706\n                axis.options.index = i;\n            });\n            this.destroy();\n            chart.isDirtyBox = true;\n\n            if (pick(redraw, true)) {\n                chart.redraw();\n            }\n        },\n\n        /**\n         * Update the axis title by options\n         */\n        setTitle: function (newTitleOptions, redraw) {\n            this.update({ title: newTitleOptions }, redraw);\n        },\n\n        /**\n         * Set new axis categories and optionally redraw\n         * @param {Array} categories\n         * @param {Boolean} redraw\n         */\n        setCategories: function (categories, redraw) {\n            this.update({ categories: categories }, redraw);\n        }\n\n    });\n\n\n    /**\n     * LineSeries object\n     */\n    var LineSeries = extendClass(Series);\n    seriesTypes.line = LineSeries;\n\n    /**\n     * Set the default options for area\n     */\n    defaultPlotOptions.area = merge(defaultSeriesOptions, {\n        softThreshold: false,\n        threshold: 0\n        // trackByArea: false,\n        // lineColor: null, // overrides color, but lets fillColor be unaltered\n        // fillOpacity: 0.75,\n        // fillColor: null\n    });\n\n    /**\n     * AreaSeries object\n     */\n    var AreaSeries = extendClass(Series, {\n        type: 'area',\n        singleStacks: false,\n        /** \n         * Return an array of stacked points, where null and missing points are replaced by \n         * dummy points in order for gaps to be drawn correctly in stacks.\n         */\n        getStackPoints: function () {\n            var series = this,\n                segment = [],\n                keys = [],\n                xAxis = this.xAxis,\n                yAxis = this.yAxis,\n                stack = yAxis.stacks[this.stackKey],\n                pointMap = {},\n                points = this.points,\n                seriesIndex = series.index,\n                yAxisSeries = yAxis.series,\n                seriesLength = yAxisSeries.length,\n                visibleSeries,\n                upOrDown = pick(yAxis.options.reversedStacks, true) ? 1 : -1,\n                i,\n                x;\n\n            if (this.options.stacking) {\n                // Create a map where we can quickly look up the points by their X value.\n                for (i = 0; i < points.length; i++) {\n                    pointMap[points[i].x] = points[i];\n                }\n\n                // Sort the keys (#1651)\n                for (x in stack) {\n                    if (stack[x].total !== null) { // nulled after switching between grouping and not (#1651, #2336)\n                        keys.push(x);\n                    }\n                }\n                keys.sort(function (a, b) {\n                    return a - b;\n                });\n\n                visibleSeries = map(yAxisSeries, function () {\n                    return this.visible;\n                });\n\n                each(keys, function (x, idx) {\n                    var y = 0,\n                        stackPoint,\n                        stackedValues;\n\n                    if (pointMap[x] && !pointMap[x].isNull) {\n                        segment.push(pointMap[x]);\n\n                        // Find left and right cliff. -1 goes left, 1 goes right.\n                        each([-1, 1], function (direction) {\n                            var nullName = direction === 1 ? 'rightNull' : 'leftNull',\n                                cliffName = direction === 1 ? 'rightCliff' : 'leftCliff',\n                                cliff = 0,\n                                otherStack = stack[keys[idx + direction]];\n\n                            // If there is a stack next to this one, to the left or to the right...\n                            if (otherStack) {\n                                i = seriesIndex;\n                                while (i >= 0 && i < seriesLength) { // Can go either up or down, depending on reversedStacks\n                                    stackPoint = otherStack.points[i];\n                                    if (!stackPoint) {\n                                        // If the next point in this series is missing, mark the point\n                                        // with point.leftNull or point.rightNull = true.\n                                        if (i === seriesIndex) {\n                                            pointMap[x][nullName] = true;\n\n                                        // If there are missing points in the next stack in any of the \n                                        // series below this one, we need to substract the missing values\n                                        // and add a hiatus to the left or right.\n                                        } else if (visibleSeries[i]) {\n                                            stackedValues = stack[x].points[i];\n                                            if (stackedValues) {\n                                                cliff -= stackedValues[1] - stackedValues[0];\n                                            }\n                                        }\n                                    }\n                                    // When reversedStacks is true, loop up, else loop down\n                                    i += upOrDown; \n                                }                \n                            }\n                            pointMap[x][cliffName] = cliff;\n                        });\n\n\n                    // There is no point for this X value in this series, so we \n                    // insert a dummy point in order for the areas to be drawn\n                    // correctly.\n                    } else {\n\n                        // Loop down the stack to find the series below this one that has\n                        // a value (#1991)\n                        i = seriesIndex;\n                        while (i >= 0 && i < seriesLength) {\n                            stackPoint = stack[x].points[i];\n                            if (stackPoint) {\n                                y = stackPoint[1];\n                                break;\n                            }\n                            // When reversedStacks is true, loop up, else loop down\n                            i += upOrDown;\n                        }\n\n                        y = yAxis.toPixels(y, true);\n                        segment.push({ \n                            isNull: true,\n                            plotX: xAxis.toPixels(x, true),\n                            plotY: y,\n                            yBottom: y\n                        });\n                    }\n                });\n\n            } \n\n            return segment;\n        },\n\n        getGraphPath: function (points) {\n            var getGraphPath = Series.prototype.getGraphPath,\n                graphPath,\n                options = this.options,\n                stacking = options.stacking,\n                yAxis = this.yAxis,\n                topPath,\n                //topPoints = [],\n                bottomPath,\n                bottomPoints = [],\n                graphPoints = [],\n                seriesIndex = this.index,\n                i,\n                areaPath,\n                plotX,\n                stacks = yAxis.stacks[this.stackKey],\n                threshold = options.threshold,\n                translatedThreshold = yAxis.getThreshold(options.threshold),\n                isNull,\n                yBottom,\n                connectNulls = options.connectNulls || stacking === 'percent',\n                /**\n                 * To display null points in underlying stacked series, this series graph must be \n                 * broken, and the area also fall down to fill the gap left by the null point. #2069\n                 */\n                addDummyPoints = function (i, otherI, side) {\n                    var point = points[i],\n                        stackedValues = stacking && stacks[point.x].points[seriesIndex],\n                        nullVal = point[side + 'Null'] || 0,\n                        cliffVal = point[side + 'Cliff'] || 0,\n                        top,\n                        bottom,\n                        isNull = true;\n\n                    if (cliffVal || nullVal) {\n\n                        top = (nullVal ? stackedValues[0] : stackedValues[1]) + cliffVal;\n                        bottom = stackedValues[0] + cliffVal;\n                        isNull = !!nullVal;\n                \n                    } else if (!stacking && points[otherI] && points[otherI].isNull) {\n                        top = bottom = threshold;\n                    }\n\n                    // Add to the top and bottom line of the area\n                    if (top !== undefined) {\n                        graphPoints.push({\n                            plotX: plotX,\n                            plotY: top === null ? translatedThreshold : yAxis.getThreshold(top),\n                            isNull: isNull\n                        });\n                        bottomPoints.push({\n                            plotX: plotX,\n                            plotY: bottom === null ? translatedThreshold : yAxis.getThreshold(bottom),\n                            doCurve: false // #1041, gaps in areaspline areas\n                        });\n                    }\n                };\n\n            // Find what points to use\n            points = points || this.points;\n        \n            // Fill in missing points\n            if (stacking) {\n                points = this.getStackPoints();\n            }\n\n            for (i = 0; i < points.length; i++) {\n                isNull = points[i].isNull;\n                plotX = pick(points[i].rectPlotX, points[i].plotX);\n                yBottom = pick(points[i].yBottom, translatedThreshold);\n\n                if (!isNull || connectNulls) {\n\n                    if (!connectNulls) {\n                        addDummyPoints(i, i - 1, 'left');\n                    }\n\n                    if (!(isNull && !stacking && connectNulls)) { // Skip null point when stacking is false and connectNulls true\n                        graphPoints.push(points[i]);\n                        bottomPoints.push({\n                            x: i,\n                            plotX: plotX,\n                            plotY: yBottom\n                        });\n                    }\n\n                    if (!connectNulls) {\n                        addDummyPoints(i, i + 1, 'right');\n                    }\n                }\n            }\n\n            topPath = getGraphPath.call(this, graphPoints, true, true);\n        \n            bottomPoints.reversed = true;\n            bottomPath = getGraphPath.call(this, bottomPoints, true, true);\n            if (bottomPath.length) {\n                bottomPath[0] = L;\n            }\n\n            areaPath = topPath.concat(bottomPath);\n            graphPath = getGraphPath.call(this, graphPoints, false, connectNulls); // TODO: don't set leftCliff and rightCliff when connectNulls?\n\n            areaPath.xMap = topPath.xMap;\n            this.areaPath = areaPath;\n            return graphPath;\n        },\n\n        /**\n         * Draw the graph and the underlying area. This method calls the Series base\n         * function and adds the area. The areaPath is calculated in the getSegmentPath\n         * method called from Series.prototype.drawGraph.\n         */\n        drawGraph: function () {\n\n            // Define or reset areaPath\n            this.areaPath = [];\n\n            // Call the base method\n            Series.prototype.drawGraph.apply(this);\n\n            // Define local variables\n            var series = this,\n                areaPath = this.areaPath,\n                options = this.options,\n                zones = this.zones,\n                props = [['area', this.color, options.fillColor]]; // area name, main color, fill color\n\n            each(zones, function (threshold, i) {\n                props.push(['zoneArea' + i, threshold.color || series.color, threshold.fillColor || options.fillColor]);\n            });\n            each(props, function (prop) {\n                var areaKey = prop[0],\n                    area = series[areaKey],\n                    attr;\n\n                // Create or update the area\n                if (area) { // update\n                    area.endX = areaPath.xMap;\n                    area.animate({ d: areaPath });\n\n                } else { // create\n                    attr = {\n                        fill: prop[2] || prop[1],\n                        zIndex: 0 // #1069\n                    };\n                    if (!prop[2]) {\n                        attr['fill-opacity'] = pick(options.fillOpacity, 0.75);\n                    }\n                    area = series[areaKey] = series.chart.renderer.path(areaPath)\n                        .attr(attr)\n                        .add(series.group);\n                    area.isArea = true;\n                }\n                area.startX = areaPath.xMap;\n                area.shiftUnit = options.step ? 2 : 1;\n            });\n        },\n\n        drawLegendSymbol: LegendSymbolMixin.drawRectangle\n    });\n\n    seriesTypes.area = AreaSeries;\n    /**\n     * Set the default options for spline\n     */\n    defaultPlotOptions.spline = merge(defaultSeriesOptions);\n\n    /**\n     * SplineSeries object\n     */\n    var SplineSeries = extendClass(Series, {\n        type: 'spline',\n\n        /**\n         * Get the spline segment from a given point's previous neighbour to the given point\n         */\n        getPointSpline: function (points, point, i) {\n            var smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc\n                denom = smoothing + 1,\n                plotX = point.plotX,\n                plotY = point.plotY,\n                lastPoint = points[i - 1],\n                nextPoint = points[i + 1],\n                leftContX,\n                leftContY,\n                rightContX,\n                rightContY,\n                ret;\n\n            function doCurve(otherPoint) {\n                return otherPoint && !otherPoint.isNull && otherPoint.doCurve !== false;\n            }\n\n            // Find control points\n            if (doCurve(lastPoint) && doCurve(nextPoint)) {\n                var lastX = lastPoint.plotX,\n                    lastY = lastPoint.plotY,\n                    nextX = nextPoint.plotX,\n                    nextY = nextPoint.plotY,\n                    correction = 0;\n\n                leftContX = (smoothing * plotX + lastX) / denom;\n                leftContY = (smoothing * plotY + lastY) / denom;\n                rightContX = (smoothing * plotX + nextX) / denom;\n                rightContY = (smoothing * plotY + nextY) / denom;\n\n                // Have the two control points make a straight line through main point\n                if (rightContX !== leftContX) { // #5016, division by zero\n                    correction = ((rightContY - leftContY) * (rightContX - plotX)) /\n                        (rightContX - leftContX) + plotY - rightContY;\n                }\n\n                leftContY += correction;\n                rightContY += correction;\n\n                // to prevent false extremes, check that control points are between\n                // neighbouring points' y values\n                if (leftContY > lastY && leftContY > plotY) {\n                    leftContY = mathMax(lastY, plotY);\n                    rightContY = 2 * plotY - leftContY; // mirror of left control point\n                } else if (leftContY < lastY && leftContY < plotY) {\n                    leftContY = mathMin(lastY, plotY);\n                    rightContY = 2 * plotY - leftContY;\n                }\n                if (rightContY > nextY && rightContY > plotY) {\n                    rightContY = mathMax(nextY, plotY);\n                    leftContY = 2 * plotY - rightContY;\n                } else if (rightContY < nextY && rightContY < plotY) {\n                    rightContY = mathMin(nextY, plotY);\n                    leftContY = 2 * plotY - rightContY;\n                }\n\n                // record for drawing in next point\n                point.rightContX = rightContX;\n                point.rightContY = rightContY;\n\n            \n            }\n\n            // Visualize control points for debugging\n            /*\n            if (leftContX) {\n                this.chart.renderer.circle(leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop, 2)\n                    .attr({\n                        stroke: 'red',\n                        'stroke-width': 2,\n                        fill: 'none',\n                        zIndex: 9\n                    })\n                    .add();\n                this.chart.renderer.path(['M', leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop,\n                    'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])\n                    .attr({\n                        stroke: 'red',\n                        'stroke-width': 2,\n                        zIndex: 9\n                    })\n                    .add();\n            }\n            if (rightContX) {\n                this.chart.renderer.circle(rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop, 2)\n                    .attr({\n                        stroke: 'green',\n                        'stroke-width': 2,\n                        fill: 'none',\n                        zIndex: 9\n                    })\n                    .add();\n                this.chart.renderer.path(['M', rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop,\n                    'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])\n                    .attr({\n                        stroke: 'green',\n                        'stroke-width': 2,\n                        zIndex: 9\n                    })\n                    .add();\n            }\n            // */\n            ret = [\n                'C',\n                pick(lastPoint.rightContX, lastPoint.plotX),\n                pick(lastPoint.rightContY, lastPoint.plotY),\n                pick(leftContX, plotX),\n                pick(leftContY, plotY),\n                plotX,\n                plotY\n            ];\n            lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later\n            return ret;\n        }\n    });\n    seriesTypes.spline = SplineSeries;\n\n    /**\n     * Set the default options for areaspline\n     */\n    defaultPlotOptions.areaspline = merge(defaultPlotOptions.area);\n\n    /**\n     * AreaSplineSeries object\n     */\n    var areaProto = AreaSeries.prototype,\n        AreaSplineSeries = extendClass(SplineSeries, {\n            type: 'areaspline',\n            getStackPoints: areaProto.getStackPoints,\n            getGraphPath: areaProto.getGraphPath,\n            setStackCliffs: areaProto.setStackCliffs,\n            drawGraph: areaProto.drawGraph,\n            drawLegendSymbol: LegendSymbolMixin.drawRectangle\n        });\n\n    seriesTypes.areaspline = AreaSplineSeries;\n\n    /**\n     * Set the default options for column\n     */\n    defaultPlotOptions.column = merge(defaultSeriesOptions, {\n        borderColor: '#FFFFFF',\n        //borderWidth: 1,\n        borderRadius: 0,\n        //colorByPoint: undefined,\n        groupPadding: 0.2,\n        //grouping: true,\n        marker: null, // point options are specified in the base options\n        pointPadding: 0.1,\n        //pointWidth: null,\n        minPointLength: 0,\n        cropThreshold: 50, // when there are more points, they will not animate out of the chart on xAxis.setExtremes\n        pointRange: null, // null means auto, meaning 1 in a categorized axis and least distance between points if not categories\n        states: {\n            hover: {\n                brightness: 0.1,\n                shadow: false,\n                halo: false\n            },\n            select: {\n                color: '#C0C0C0',\n                borderColor: '#000000',\n                shadow: false\n            }\n        },\n        dataLabels: {\n            align: null, // auto\n            verticalAlign: null, // auto\n            y: null\n        },\n        softThreshold: false,\n        startFromThreshold: true, // false doesn't work well: http://jsfiddle.net/highcharts/hz8fopan/14/\n        stickyTracking: false,\n        tooltip: {\n            distance: 6\n        },\n        threshold: 0\n    });\n\n    /**\n     * ColumnSeries object\n     */\n    var ColumnSeries = extendClass(Series, {\n        type: 'column',\n        pointAttrToOptions: { // mapping between SVG attributes and the corresponding options\n            stroke: 'borderColor',\n            fill: 'color',\n            r: 'borderRadius'\n        },\n        cropShoulder: 0,\n        directTouch: true, // When tooltip is not shared, this series (and derivatives) requires direct touch/hover. KD-tree does not apply.\n        trackerGroups: ['group', 'dataLabelsGroup'],\n        negStacks: true, // use separate negative stacks, unlike area stacks where a negative\n            // point is substracted from previous (#1910)\n\n        /**\n         * Initialize the series\n         */\n        init: function () {\n            Series.prototype.init.apply(this, arguments);\n\n            var series = this,\n                chart = series.chart;\n\n            // if the series is added dynamically, force redraw of other\n            // series affected by a new column\n            if (chart.hasRendered) {\n                each(chart.series, function (otherSeries) {\n                    if (otherSeries.type === series.type) {\n                        otherSeries.isDirty = true;\n                    }\n                });\n            }\n        },\n\n        /**\n         * Return the width and x offset of the columns adjusted for grouping, groupPadding, pointPadding,\n         * pointWidth etc.\n         */\n        getColumnMetrics: function () {\n\n            var series = this,\n                options = series.options,\n                xAxis = series.xAxis,\n                yAxis = series.yAxis,\n                reversedXAxis = xAxis.reversed,\n                stackKey,\n                stackGroups = {},\n                columnCount = 0;\n\n            // Get the total number of column type series.\n            // This is called on every series. Consider moving this logic to a\n            // chart.orderStacks() function and call it on init, addSeries and removeSeries\n            if (options.grouping === false) {\n                columnCount = 1;\n            } else {\n                each(series.chart.series, function (otherSeries) {\n                    var otherOptions = otherSeries.options,\n                        otherYAxis = otherSeries.yAxis,\n                        columnIndex;\n                    if (otherSeries.type === series.type && otherSeries.visible &&\n                            yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {  // #642, #2086\n                        if (otherOptions.stacking) {\n                            stackKey = otherSeries.stackKey;\n                            if (stackGroups[stackKey] === UNDEFINED) {\n                                stackGroups[stackKey] = columnCount++;\n                            }\n                            columnIndex = stackGroups[stackKey];\n                        } else if (otherOptions.grouping !== false) { // #1162\n                            columnIndex = columnCount++;\n                        }\n                        otherSeries.columnIndex = columnIndex;\n                    }\n                });\n            }\n\n            var categoryWidth = mathMin(\n                    mathAbs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1), // #2610\n                    xAxis.len // #1535\n                ),\n                groupPadding = categoryWidth * options.groupPadding,\n                groupWidth = categoryWidth - 2 * groupPadding,\n                pointOffsetWidth = groupWidth / columnCount,\n                pointWidth = mathMin(\n                    options.maxPointWidth || xAxis.len,\n                    pick(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding))\n                ),\n                pointPadding = (pointOffsetWidth - pointWidth) / 2,\n                colIndex = (series.columnIndex || 0) + (reversedXAxis ? 1 : 0), // #1251, #3737\n                pointXOffset = pointPadding + (groupPadding + colIndex *\n                    pointOffsetWidth - (categoryWidth / 2)) *\n                    (reversedXAxis ? -1 : 1);\n\n            // Save it for reading in linked series (Error bars particularly)\n            series.columnMetrics = {\n                width: pointWidth,\n                offset: pointXOffset\n            };\n            return series.columnMetrics;\n\n        },\n\n        /**\n         * Make the columns crisp. The edges are rounded to the nearest full pixel.\n         */\n        crispCol: function (x, y, w, h) {\n            var chart = this.chart,\n                borderWidth = this.borderWidth,\n                xCrisp = -(borderWidth % 2 ? 0.5 : 0),\n                yCrisp = borderWidth % 2 ? 0.5 : 1,\n                right,\n                bottom,\n                fromTop;\n\n            if (chart.inverted && chart.renderer.isVML) {\n                yCrisp += 1;\n            }\n\n            // Horizontal. We need to first compute the exact right edge, then round it\n            // and compute the width from there.\n            right = Math.round(x + w) + xCrisp;\n            x = Math.round(x) + xCrisp;\n            w = right - x;\n\n            // Vertical\n            bottom = Math.round(y + h) + yCrisp;\n            fromTop = mathAbs(y) <= 0.5 && bottom > 0.5; // #4504, #4656\n            y = Math.round(y) + yCrisp;\n            h = bottom - y;\n\n            // Top edges are exceptions\n            if (fromTop && h) { // #5146\n                y -= 1;\n                h += 1;\n            }\n\n            return {\n                x: x,\n                y: y,\n                width: w,\n                height: h\n            };\n        },\n\n        /**\n         * Translate each point to the plot area coordinate system and find shape positions\n         */\n        translate: function () {\n            var series = this,\n                chart = series.chart,\n                options = series.options,\n                borderWidth = series.borderWidth = pick(\n                    options.borderWidth,\n                    series.closestPointRange * series.xAxis.transA < 2 ? 0 : 1 // #3635\n                ),\n                yAxis = series.yAxis,\n                threshold = options.threshold,\n                translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),\n                minPointLength = pick(options.minPointLength, 5),\n                metrics = series.getColumnMetrics(),\n                pointWidth = metrics.width,\n                seriesBarW = series.barW = mathMax(pointWidth, 1 + 2 * borderWidth), // postprocessed for border width\n                pointXOffset = series.pointXOffset = metrics.offset;\n\n            if (chart.inverted) {\n                translatedThreshold -= 0.5; // #3355\n            }\n\n            // When the pointPadding is 0, we want the columns to be packed tightly, so we allow individual\n            // columns to have individual sizes. When pointPadding is greater, we strive for equal-width\n            // columns (#2694).\n            if (options.pointPadding) {\n                seriesBarW = mathCeil(seriesBarW);\n            }\n\n            Series.prototype.translate.apply(series);\n\n            // Record the new values\n            each(series.points, function (point) {\n                var yBottom = mathMin(pick(point.yBottom, translatedThreshold), 9e4), // #3575\n                    safeDistance = 999 + mathAbs(yBottom),\n                    plotY = mathMin(mathMax(-safeDistance, point.plotY), yAxis.len + safeDistance), // Don't draw too far outside plot area (#1303, #2241, #4264)\n                    barX = point.plotX + pointXOffset,\n                    barW = seriesBarW,\n                    barY = mathMin(plotY, yBottom),\n                    up,\n                    barH = mathMax(plotY, yBottom) - barY;\n\n                // Handle options.minPointLength\n                if (mathAbs(barH) < minPointLength) {\n                    if (minPointLength) {\n                        barH = minPointLength;\n                        up = (!yAxis.reversed && !point.negative) || (yAxis.reversed && point.negative);\n                        barY = mathAbs(barY - translatedThreshold) > minPointLength ? // stacked\n                                yBottom - minPointLength : // keep position\n                                translatedThreshold - (up ? minPointLength : 0); // #1485, #4051\n                    }\n                }\n\n                // Cache for access in polar\n                point.barX = barX;\n                point.pointWidth = pointWidth;\n\n                // Fix the tooltip on center of grouped columns (#1216, #424, #3648)\n                point.tooltipPos = chart.inverted ?\n                    [yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - barX - barW / 2, barH] :\n                    [barX + barW / 2, plotY + yAxis.pos - chart.plotTop, barH];\n\n                // Register shape type and arguments to be used in drawPoints\n                point.shapeType = 'rect';\n                point.shapeArgs = series.crispCol.apply(\n                    series,\n                    point.isNull ? \n                        [point.plotX, yAxis.len / 2, 0, 0] : // #3169, drilldown from null must have a position to work from\n                        [barX, barY, barW, barH]\n                );\n            });\n\n        },\n\n        getSymbol: noop,\n\n        /**\n         * Use a solid rectangle like the area series types\n         */\n        drawLegendSymbol: LegendSymbolMixin.drawRectangle,\n\n\n        /**\n         * Columns have no graph\n         */\n        drawGraph: noop,\n\n        /**\n         * Draw the columns. For bars, the series.group is rotated, so the same coordinates\n         * apply for columns and bars. This method is inherited by scatter series.\n         *\n         */\n        drawPoints: function () {\n            var series = this,\n                chart = this.chart,\n                options = series.options,\n                renderer = chart.renderer,\n                animationLimit = options.animationLimit || 250,\n                shapeArgs,\n                pointAttr;\n\n            // draw the columns\n            each(series.points, function (point) {\n                var plotY = point.plotY,\n                    graphic = point.graphic,\n                    borderAttr;\n\n                if (isNumber(plotY) && point.y !== null) {\n                    shapeArgs = point.shapeArgs;\n\n                    borderAttr = defined(series.borderWidth) ? {\n                        'stroke-width': series.borderWidth\n                    } : {};\n\n                    pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || series.pointAttr[NORMAL_STATE];\n\n                    if (graphic) { // update\n                        stop(graphic);\n                        graphic.attr(borderAttr).attr(pointAttr)[chart.pointCount < animationLimit ? 'animate' : 'attr'](merge(shapeArgs)); // #4267\n\n                    } else {\n                        point.graphic = graphic = renderer[point.shapeType](shapeArgs)\n                            .attr(borderAttr)\n                            .attr(pointAttr)\n                            .add(point.group || series.group)\n                            .shadow(options.shadow, null, options.stacking && !options.borderRadius);\n                    }\n\n                } else if (graphic) {\n                    point.graphic = graphic.destroy(); // #1269\n                }\n            });\n        },\n\n        /**\n         * Animate the column heights one by one from zero\n         * @param {Boolean} init Whether to initialize the animation or run it\n         */\n        animate: function (init) {\n            var series = this,\n                yAxis = this.yAxis,\n                options = series.options,\n                inverted = this.chart.inverted,\n                attr = {},\n                translatedThreshold;\n\n            if (hasSVG) { // VML is too slow anyway\n                if (init) {\n                    attr.scaleY = 0.001;\n                    translatedThreshold = mathMin(yAxis.pos + yAxis.len, mathMax(yAxis.pos, yAxis.toPixels(options.threshold)));\n                    if (inverted) {\n                        attr.translateX = translatedThreshold - yAxis.len;\n                    } else {\n                        attr.translateY = translatedThreshold;\n                    }\n                    series.group.attr(attr);\n\n                } else { // run the animation\n\n                    attr[inverted ? 'translateX' : 'translateY'] = yAxis.pos;\n                    series.group.animate(attr, extend(animObject(series.options.animation), {\n                        // Do the scale synchronously to ensure smooth updating (#5030)\n                        step: function (val, fx) {\n                            series.group.attr({\n                                scaleY: mathMax(0.001, fx.pos) // #5250\n                            });\n                        }\n                    }));\n\n                    // delete this function to allow it only once\n                    series.animate = null;\n                }\n            }\n        },\n\n        /**\n         * Remove this series from the chart\n         */\n        remove: function () {\n            var series = this,\n                chart = series.chart;\n\n            // column and bar series affects other series of the same type\n            // as they are either stacked or grouped\n            if (chart.hasRendered) {\n                each(chart.series, function (otherSeries) {\n                    if (otherSeries.type === series.type) {\n                        otherSeries.isDirty = true;\n                    }\n                });\n            }\n\n            Series.prototype.remove.apply(series, arguments);\n        }\n    });\n    seriesTypes.column = ColumnSeries;\n    /**\n     * Set the default options for bar\n     */\n    defaultPlotOptions.bar = merge(defaultPlotOptions.column);\n    /**\n     * The Bar series class\n     */\n    var BarSeries = extendClass(ColumnSeries, {\n        type: 'bar',\n        inverted: true\n    });\n    seriesTypes.bar = BarSeries;\n\n    /**\n     * Set the default options for scatter\n     */\n    defaultPlotOptions.scatter = merge(defaultSeriesOptions, {\n        lineWidth: 0,\n        marker: {\n            enabled: true // Overrides auto-enabling in line series (#3647)\n        },\n        tooltip: {\n            headerFormat: '<span style=\"color:{point.color}\">\\u25CF</span> <span style=\"font-size: 10px;\"> {series.name}</span><br/>',\n            pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'\n        }\n    });\n\n    /**\n     * The scatter series class\n     */\n    var ScatterSeries = extendClass(Series, {\n        type: 'scatter',\n        sorted: false,\n        requireSorting: false,\n        noSharedTooltip: true,\n        trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],\n        takeOrdinalPosition: false, // #2342\n        kdDimensions: 2,\n        drawGraph: function () {\n            if (this.options.lineWidth) {\n                Series.prototype.drawGraph.call(this);\n            }\n        }\n    });\n\n    seriesTypes.scatter = ScatterSeries;\n\n    /**\n     * Set the default options for pie\n     */\n    defaultPlotOptions.pie = merge(defaultSeriesOptions, {\n        borderColor: '#FFFFFF',\n        borderWidth: 1,\n        center: [null, null],\n        clip: false,\n        colorByPoint: true, // always true for pies\n        dataLabels: {\n            // align: null,\n            // connectorWidth: 1,\n            // connectorColor: point.color,\n            // connectorPadding: 5,\n            distance: 30,\n            enabled: true,\n            formatter: function () { // #2945\n                return this.y === null ? undefined : this.point.name;\n            },\n            // softConnector: true,\n            x: 0\n            // y: 0\n        },\n        ignoreHiddenPoint: true,\n        //innerSize: 0,\n        legendType: 'point',\n        marker: null, // point options are specified in the base options\n        size: null,\n        showInLegend: false,\n        slicedOffset: 10,\n        states: {\n            hover: {\n                brightness: 0.1,\n                shadow: false\n            }\n        },\n        stickyTracking: false,\n        tooltip: {\n            followPointer: true\n        }\n    });\n\n    /**\n     * Extended point object for pies\n     */\n    var PiePoint = extendClass(Point, {\n        /**\n         * Initiate the pie slice\n         */\n        init: function () {\n\n            Point.prototype.init.apply(this, arguments);\n\n            var point = this,\n                toggleSlice;\n\n            point.name = pick(point.name, 'Slice');\n\n            // add event listener for select\n            toggleSlice = function (e) {\n                point.slice(e.type === 'select');\n            };\n            addEvent(point, 'select', toggleSlice);\n            addEvent(point, 'unselect', toggleSlice);\n\n            return point;\n        },\n\n        /**\n         * Toggle the visibility of the pie slice\n         * @param {Boolean} vis Whether to show the slice or not. If undefined, the\n         *    visibility is toggled\n         */\n        setVisible: function (vis, redraw) {\n            var point = this,\n                series = point.series,\n                chart = series.chart,\n                ignoreHiddenPoint = series.options.ignoreHiddenPoint;\n\n            redraw = pick(redraw, ignoreHiddenPoint);\n\n            if (vis !== point.visible) {\n\n                // If called without an argument, toggle visibility\n                point.visible = point.options.visible = vis = vis === UNDEFINED ? !point.visible : vis;\n                series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data\n\n                // Show and hide associated elements. This is performed regardless of redraw or not,\n                // because chart.redraw only handles full series.\n                each(['graphic', 'dataLabel', 'connector', 'shadowGroup'], function (key) {\n                    if (point[key]) {\n                        point[key][vis ? 'show' : 'hide'](true);\n                    }\n                });\n\n                if (point.legendItem) {\n                    chart.legend.colorizeItem(point, vis);\n                }\n\n                // #4170, hide halo after hiding point\n                if (!vis && point.state === 'hover') {\n                    point.setState('');\n                }\n\n                // Handle ignore hidden slices\n                if (ignoreHiddenPoint) {\n                    series.isDirty = true;\n                }\n\n                if (redraw) {\n                    chart.redraw();\n                }\n            }\n        },\n\n        /**\n         * Set or toggle whether the slice is cut out from the pie\n         * @param {Boolean} sliced When undefined, the slice state is toggled\n         * @param {Boolean} redraw Whether to redraw the chart. True by default.\n         */\n        slice: function (sliced, redraw, animation) {\n            var point = this,\n                series = point.series,\n                chart = series.chart,\n                translation;\n\n            setAnimation(animation, chart);\n\n            // redraw is true by default\n            redraw = pick(redraw, true);\n\n            // if called without an argument, toggle\n            point.sliced = point.options.sliced = sliced = defined(sliced) ? sliced : !point.sliced;\n            series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data\n\n            translation = sliced ? point.slicedTranslation : {\n                translateX: 0,\n                translateY: 0\n            };\n\n            point.graphic.animate(translation);\n\n            if (point.shadowGroup) {\n                point.shadowGroup.animate(translation);\n            }\n\n        },\n\n        haloPath: function (size) {\n            var shapeArgs = this.shapeArgs,\n                chart = this.series.chart;\n\n            return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(chart.plotLeft + shapeArgs.x, chart.plotTop + shapeArgs.y, shapeArgs.r + size, shapeArgs.r + size, {\n                innerR: this.shapeArgs.r,\n                start: shapeArgs.start,\n                end: shapeArgs.end\n            });\n        }\n    });\n\n    /**\n     * The Pie series class\n     */\n    var PieSeries = {\n        type: 'pie',\n        isCartesian: false,\n        pointClass: PiePoint,\n        requireSorting: false,\n        directTouch: true,\n        noSharedTooltip: true,\n        trackerGroups: ['group', 'dataLabelsGroup'],\n        axisTypes: [],\n        pointAttrToOptions: { // mapping between SVG attributes and the corresponding options\n            stroke: 'borderColor',\n            'stroke-width': 'borderWidth',\n            fill: 'color'\n        },\n\n        /**\n         * Animate the pies in\n         */\n        animate: function (init) {\n            var series = this,\n                points = series.points,\n                startAngleRad = series.startAngleRad;\n\n            if (!init) {\n                each(points, function (point) {\n                    var graphic = point.graphic,\n                        args = point.shapeArgs;\n\n                    if (graphic) {\n                        // start values\n                        graphic.attr({\n                            r: point.startR || (series.center[3] / 2), // animate from inner radius (#779)\n                            start: startAngleRad,\n                            end: startAngleRad\n                        });\n\n                        // animate\n                        graphic.animate({\n                            r: args.r,\n                            start: args.start,\n                            end: args.end\n                        }, series.options.animation);\n                    }\n                });\n\n                // delete this function to allow it only once\n                series.animate = null;\n            }\n        },\n\n        /**\n         * Recompute total chart sum and update percentages of points.\n         */\n        updateTotals: function () {\n            var i,\n                total = 0,\n                points = this.points,\n                len = points.length,\n                point,\n                ignoreHiddenPoint = this.options.ignoreHiddenPoint;\n\n            // Get the total sum\n            for (i = 0; i < len; i++) {\n                point = points[i];\n                // Disallow negative values (#1530, #3623, #5322)\n                if (point.y < 0) {\n                    point.y = null;\n                }\n                total += (ignoreHiddenPoint && !point.visible) ? 0 : point.y;\n            }\n            this.total = total;\n\n            // Set each point's properties\n            for (i = 0; i < len; i++) {\n                point = points[i];\n                point.percentage = (total > 0 && (point.visible || !ignoreHiddenPoint)) ? point.y / total * 100 : 0;\n                point.total = total;\n            }\n        },\n\n        /**\n         * Extend the generatePoints method by adding total and percentage properties to each point\n         */\n        generatePoints: function () {\n            Series.prototype.generatePoints.call(this);\n            this.updateTotals();\n        },\n\n        /**\n         * Do translation for pie slices\n         */\n        translate: function (positions) {\n            this.generatePoints();\n\n            var series = this,\n                cumulative = 0,\n                precision = 1000, // issue #172\n                options = series.options,\n                slicedOffset = options.slicedOffset,\n                connectorOffset = slicedOffset + options.borderWidth,\n                start,\n                end,\n                angle,\n                startAngle = options.startAngle || 0,\n                startAngleRad = series.startAngleRad = mathPI / 180 * (startAngle - 90),\n                endAngleRad = series.endAngleRad = mathPI / 180 * ((pick(options.endAngle, startAngle + 360)) - 90),\n                circ = endAngleRad - startAngleRad, //2 * mathPI,\n                points = series.points,\n                radiusX, // the x component of the radius vector for a given point\n                radiusY,\n                labelDistance = options.dataLabels.distance,\n                ignoreHiddenPoint = options.ignoreHiddenPoint,\n                i,\n                len = points.length,\n                point;\n\n            // Get positions - either an integer or a percentage string must be given.\n            // If positions are passed as a parameter, we're in a recursive loop for adjusting\n            // space for data labels.\n            if (!positions) {\n                series.center = positions = series.getCenter();\n            }\n\n            // utility for getting the x value from a given y, used for anticollision logic in data labels\n            series.getX = function (y, left) {\n\n                angle = math.asin(mathMin((y - positions[1]) / (positions[2] / 2 + labelDistance), 1));\n\n                return positions[0] +\n                    (left ? -1 : 1) *\n                    (mathCos(angle) * (positions[2] / 2 + labelDistance));\n            };\n\n            // Calculate the geometry for each point\n            for (i = 0; i < len; i++) {\n\n                point = points[i];\n\n                // set start and end angle\n                start = startAngleRad + (cumulative * circ);\n                if (!ignoreHiddenPoint || point.visible) {\n                    cumulative += point.percentage / 100;\n                }\n                end = startAngleRad + (cumulative * circ);\n\n                // set the shape\n                point.shapeType = 'arc';\n                point.shapeArgs = {\n                    x: positions[0],\n                    y: positions[1],\n                    r: positions[2] / 2,\n                    innerR: positions[3] / 2,\n                    start: mathRound(start * precision) / precision,\n                    end: mathRound(end * precision) / precision\n                };\n\n                // The angle must stay within -90 and 270 (#2645)\n                angle = (end + start) / 2;\n                if (angle > 1.5 * mathPI) {\n                    angle -= 2 * mathPI;\n                } else if (angle < -mathPI / 2) {\n                    angle += 2 * mathPI;\n                }\n\n                // Center for the sliced out slice\n                point.slicedTranslation = {\n                    translateX: mathRound(mathCos(angle) * slicedOffset),\n                    translateY: mathRound(mathSin(angle) * slicedOffset)\n                };\n\n                // set the anchor point for tooltips\n                radiusX = mathCos(angle) * positions[2] / 2;\n                radiusY = mathSin(angle) * positions[2] / 2;\n                point.tooltipPos = [\n                    positions[0] + radiusX * 0.7,\n                    positions[1] + radiusY * 0.7\n                ];\n\n                point.half = angle < -mathPI / 2 || angle > mathPI / 2 ? 1 : 0;\n                point.angle = angle;\n\n                // set the anchor point for data labels\n                connectorOffset = mathMin(connectorOffset, labelDistance / 2); // #1678\n                point.labelPos = [\n                    positions[0] + radiusX + mathCos(angle) * labelDistance, // first break of connector\n                    positions[1] + radiusY + mathSin(angle) * labelDistance, // a/a\n                    positions[0] + radiusX + mathCos(angle) * connectorOffset, // second break, right outside pie\n                    positions[1] + radiusY + mathSin(angle) * connectorOffset, // a/a\n                    positions[0] + radiusX, // landing point for connector\n                    positions[1] + radiusY, // a/a\n                    labelDistance < 0 ? // alignment\n                        'center' :\n                        point.half ? 'right' : 'left', // alignment\n                    angle // center angle\n                ];\n\n            }\n        },\n\n        drawGraph: null,\n\n        /**\n         * Draw the data points\n         */\n        drawPoints: function () {\n            var series = this,\n                chart = series.chart,\n                renderer = chart.renderer,\n                groupTranslation,\n                //center,\n                graphic,\n                //group,\n                shadow = series.options.shadow,\n                shadowGroup,\n                pointAttr,\n                shapeArgs,\n                attr;\n\n            if (shadow && !series.shadowGroup) {\n                series.shadowGroup = renderer.g('shadow')\n                    .add(series.group);\n            }\n\n            // draw the slices\n            each(series.points, function (point) {\n                if (point.y !== null) {\n                    graphic = point.graphic;\n                    shapeArgs = point.shapeArgs;\n                    shadowGroup = point.shadowGroup;\n                    pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE];\n                    if (!pointAttr.stroke) {\n                        pointAttr.stroke = pointAttr.fill;\n                    }\n\n                    // put the shadow behind all points\n                    if (shadow && !shadowGroup) {\n                        shadowGroup = point.shadowGroup = renderer.g('shadow')\n                            .add(series.shadowGroup);\n                    }\n\n                    // if the point is sliced, use special translation, else use plot area traslation\n                    groupTranslation = point.sliced ? point.slicedTranslation : {\n                        translateX: 0,\n                        translateY: 0\n                    };\n\n                    //group.translate(groupTranslation[0], groupTranslation[1]);\n                    if (shadowGroup) {\n                        shadowGroup.attr(groupTranslation);\n                    }\n\n                    // draw the slice\n                    if (graphic) {\n                        graphic\n                            .setRadialReference(series.center)\n                            .attr(pointAttr)\n                            .animate(extend(shapeArgs, groupTranslation));\n                    } else {\n                        attr = { 'stroke-linejoin': 'round' };\n                        if (!point.visible) {\n                            attr.visibility = 'hidden';\n                        }\n\n                        point.graphic = graphic = renderer[point.shapeType](shapeArgs)\n                            .setRadialReference(series.center)\n                            .attr(pointAttr)\n                            .attr(attr)\n                            .attr(groupTranslation)\n                            .add(series.group)\n                            .shadow(shadow, shadowGroup);\n                    }\n                }\n            });\n\n        },\n\n\n        searchPoint: noop,\n\n        /**\n         * Utility for sorting data labels\n         */\n        sortByAngle: function (points, sign) {\n            points.sort(function (a, b) {\n                return a.angle !== undefined && (b.angle - a.angle) * sign;\n            });\n        },\n\n        /**\n         * Use a simple symbol from LegendSymbolMixin\n         */\n        drawLegendSymbol: LegendSymbolMixin.drawRectangle,\n\n        /**\n         * Use the getCenter method from drawLegendSymbol\n         */\n        getCenter: CenteredSeriesMixin.getCenter,\n\n        /**\n         * Pies don't have point marker symbols\n         */\n        getSymbol: noop\n\n    };\n    PieSeries = extendClass(Series, PieSeries);\n    seriesTypes.pie = PieSeries;\n\n    /**\n     * Draw the data labels\n     */\n    Series.prototype.drawDataLabels = function () {\n\n        var series = this,\n            seriesOptions = series.options,\n            cursor = seriesOptions.cursor,\n            options = seriesOptions.dataLabels,\n            points = series.points,\n            pointOptions,\n            generalOptions,\n            hasRendered = series.hasRendered || 0,\n            str,\n            dataLabelsGroup,\n            defer = pick(options.defer, true),\n            renderer = series.chart.renderer;\n\n        if (options.enabled || series._hasPointLabels) {\n\n            // Process default alignment of data labels for columns\n            if (series.dlProcessOptions) {\n                series.dlProcessOptions(options);\n            }\n\n            // Create a separate group for the data labels to avoid rotation\n            dataLabelsGroup = series.plotGroup(\n                'dataLabelsGroup',\n                'data-labels',\n                defer && !hasRendered ? 'hidden' : 'visible', // #5133\n                options.zIndex || 6\n            );\n\n            if (defer) {\n                dataLabelsGroup.attr({ opacity: +hasRendered }); // #3300\n                if (!hasRendered) {\n                    addEvent(series, 'afterAnimate', function () {\n                        if (series.visible) { // #2597, #3023, #3024\n                            dataLabelsGroup.show(true);\n                        }\n                        dataLabelsGroup[seriesOptions.animation ? 'animate' : 'attr']({ opacity: 1 }, { duration: 200 });\n                    });\n                }\n            }\n\n            // Make the labels for each point\n            generalOptions = options;\n            each(points, function (point) {\n\n                var enabled,\n                    dataLabel = point.dataLabel,\n                    labelConfig,\n                    attr,\n                    name,\n                    rotation,\n                    connector = point.connector,\n                    isNew = true,\n                    style,\n                    moreStyle = {};\n\n                // Determine if each data label is enabled\n                pointOptions = point.dlOptions || (point.options && point.options.dataLabels); // dlOptions is used in treemaps\n                enabled = pick(pointOptions && pointOptions.enabled, generalOptions.enabled) && point.y !== null; // #2282, #4641\n\n\n                // If the point is outside the plot area, destroy it. #678, #820\n                if (dataLabel && !enabled) {\n                    point.dataLabel = dataLabel.destroy();\n\n                // Individual labels are disabled if the are explicitly disabled\n                // in the point options, or if they fall outside the plot area.\n                } else if (enabled) {\n\n                    // Create individual options structure that can be extended without\n                    // affecting others\n                    options = merge(generalOptions, pointOptions);\n                    style = options.style;\n\n                    rotation = options.rotation;\n\n                    // Get the string\n                    labelConfig = point.getLabelConfig();\n                    str = options.format ?\n                        format(options.format, labelConfig) :\n                        options.formatter.call(labelConfig, options);\n\n                    // Determine the color\n                    style.color = pick(options.color, style.color, series.color, 'black');\n\n\n                    // update existing label\n                    if (dataLabel) {\n\n                        if (defined(str)) {\n                            dataLabel\n                                .attr({\n                                    text: str\n                                });\n                            isNew = false;\n\n                        } else { // #1437 - the label is shown conditionally\n                            point.dataLabel = dataLabel = dataLabel.destroy();\n                            if (connector) {\n                                point.connector = connector.destroy();\n                            }\n                        }\n\n                    // create new label\n                    } else if (defined(str)) {\n                        attr = {\n                            //align: align,\n                            fill: options.backgroundColor,\n                            stroke: options.borderColor,\n                            'stroke-width': options.borderWidth,\n                            r: options.borderRadius || 0,\n                            rotation: rotation,\n                            padding: options.padding,\n                            zIndex: 1\n                        };\n\n                        // Get automated contrast color\n                        if (style.color === 'contrast') {\n                            moreStyle.color = options.inside || options.distance < 0 || !!seriesOptions.stacking ?\n                                renderer.getContrast(point.color || series.color) :\n                                '#000000';\n                        }\n                        if (cursor) {\n                            moreStyle.cursor = cursor;\n                        }\n\n\n                        // Remove unused attributes (#947)\n                        for (name in attr) {\n                            if (attr[name] === UNDEFINED) {\n                                delete attr[name];\n                            }\n                        }\n\n                        dataLabel = point.dataLabel = renderer[rotation ? 'text' : 'label']( // labels don't support rotation\n                            str,\n                            0,\n                            -9999,\n                            options.shape,\n                            null,\n                            null,\n                            options.useHTML\n                        )\n                        .attr(attr)\n                        .css(extend(style, moreStyle))\n                        .add(dataLabelsGroup)\n                        .shadow(options.shadow);\n\n                    }\n\n                    if (dataLabel) {\n                        // Now the data label is created and placed at 0,0, so we need to align it\n                        series.alignDataLabel(point, dataLabel, options, null, isNew);\n                    }\n                }\n            });\n        }\n    };\n\n    /**\n     * Align each individual data label\n     */\n    Series.prototype.alignDataLabel = function (point, dataLabel, options, alignTo, isNew) {\n        var chart = this.chart,\n            inverted = chart.inverted,\n            plotX = pick(point.plotX, -9999),\n            plotY = pick(point.plotY, -9999),\n            bBox = dataLabel.getBBox(),\n            baseline = chart.renderer.fontMetrics(options.style.fontSize).b,\n            rotation = options.rotation,\n            normRotation,\n            negRotation,\n            align = options.align,\n            rotCorr, // rotation correction\n            // Math.round for rounding errors (#2683), alignTo to allow column labels (#2700)\n            visible = this.visible && (point.series.forceDL || chart.isInsidePlot(plotX, mathRound(plotY), inverted) ||\n                (alignTo && chart.isInsidePlot(plotX, inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1, inverted))),\n            alignAttr, // the final position;\n            justify = pick(options.overflow, 'justify') === 'justify';\n\n        if (visible) {\n\n            // The alignment box is a singular point\n            alignTo = extend({\n                x: inverted ? chart.plotWidth - plotY : plotX,\n                y: mathRound(inverted ? chart.plotHeight - plotX : plotY),\n                width: 0,\n                height: 0\n            }, alignTo);\n\n            // Add the text size for alignment calculation\n            extend(options, {\n                width: bBox.width,\n                height: bBox.height\n            });\n\n            // Allow a hook for changing alignment in the last moment, then do the alignment\n            if (rotation) {\n                justify = false; // Not supported for rotated text\n                rotCorr = chart.renderer.rotCorr(baseline, rotation); // #3723\n                alignAttr = {\n                    x: alignTo.x + options.x + alignTo.width / 2 + rotCorr.x,\n                    y: alignTo.y + options.y + { top: 0, middle: 0.5, bottom: 1 }[options.verticalAlign] * alignTo.height\n                };\n                dataLabel[isNew ? 'attr' : 'animate'](alignAttr)\n                    .attr({ // #3003\n                        align: align\n                    });\n\n                // Compensate for the rotated label sticking out on the sides\n                normRotation = (rotation + 720) % 360;\n                negRotation = normRotation > 180 && normRotation < 360;\n\n                if (align === 'left') {\n                    alignAttr.y -= negRotation ? bBox.height : 0;\n                } else if (align === 'center') {\n                    alignAttr.x -= bBox.width / 2;\n                    alignAttr.y -= bBox.height / 2;\n                } else if (align === 'right') {\n                    alignAttr.x -= bBox.width;\n                    alignAttr.y -= negRotation ? 0 : bBox.height;\n                }\n            \n\n            } else {\n                dataLabel.align(options, null, alignTo);\n                alignAttr = dataLabel.alignAttr;\n            }\n\n            // Handle justify or crop\n            if (justify) {\n                this.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew);\n            \n            // Now check that the data label is within the plot area\n            } else if (pick(options.crop, true)) {\n                visible = chart.isInsidePlot(alignAttr.x, alignAttr.y) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height);\n            }\n\n            // When we're using a shape, make it possible with a connector or an arrow pointing to thie point\n            if (options.shape && !rotation) {\n                dataLabel.attr({\n                    anchorX: point.plotX,\n                    anchorY: point.plotY\n                });\n            }\n        }\n\n        // Show or hide based on the final aligned position\n        if (!visible) {\n            stop(dataLabel);\n            dataLabel.attr({ y: -9999 });\n            dataLabel.placed = false; // don't animate back in\n        }\n\n    };\n\n    /**\n     * If data labels fall partly outside the plot area, align them back in, in a way that\n     * doesn't hide the point.\n     */\n    Series.prototype.justifyDataLabel = function (dataLabel, options, alignAttr, bBox, alignTo, isNew) {\n        var chart = this.chart,\n            align = options.align,\n            verticalAlign = options.verticalAlign,\n            off,\n            justified,\n            padding = dataLabel.box ? 0 : (dataLabel.padding || 0);\n\n        // Off left\n        off = alignAttr.x + padding;\n        if (off < 0) {\n            if (align === 'right') {\n                options.align = 'left';\n            } else {\n                options.x = -off;\n            }\n            justified = true;\n        }\n\n        // Off right\n        off = alignAttr.x + bBox.width - padding;\n        if (off > chart.plotWidth) {\n            if (align === 'left') {\n                options.align = 'right';\n            } else {\n                options.x = chart.plotWidth - off;\n            }\n            justified = true;\n        }\n\n        // Off top\n        off = alignAttr.y + padding;\n        if (off < 0) {\n            if (verticalAlign === 'bottom') {\n                options.verticalAlign = 'top';\n            } else {\n                options.y = -off;\n            }\n            justified = true;\n        }\n\n        // Off bottom\n        off = alignAttr.y + bBox.height - padding;\n        if (off > chart.plotHeight) {\n            if (verticalAlign === 'top') {\n                options.verticalAlign = 'bottom';\n            } else {\n                options.y = chart.plotHeight - off;\n            }\n            justified = true;\n        }\n\n        if (justified) {\n            dataLabel.placed = !isNew;\n            dataLabel.align(options, null, alignTo);\n        }\n    };\n\n    /**\n     * Override the base drawDataLabels method by pie specific functionality\n     */\n    if (seriesTypes.pie) {\n        seriesTypes.pie.prototype.drawDataLabels = function () {\n            var series = this,\n                data = series.data,\n                point,\n                chart = series.chart,\n                options = series.options.dataLabels,\n                connectorPadding = pick(options.connectorPadding, 10),\n                connectorWidth = pick(options.connectorWidth, 1),\n                plotWidth = chart.plotWidth,\n                plotHeight = chart.plotHeight,\n                connector,\n                connectorPath,\n                softConnector = pick(options.softConnector, true),\n                distanceOption = options.distance,\n                seriesCenter = series.center,\n                radius = seriesCenter[2] / 2,\n                centerY = seriesCenter[1],\n                outside = distanceOption > 0,\n                dataLabel,\n                dataLabelWidth,\n                labelPos,\n                labelHeight,\n                halves = [// divide the points into right and left halves for anti collision\n                    [], // right\n                    []  // left\n                ],\n                x,\n                y,\n                visibility,\n                rankArr,\n                i,\n                j,\n                overflow = [0, 0, 0, 0], // top, right, bottom, left\n                sort = function (a, b) {\n                    return b.y - a.y;\n                };\n\n            // get out if not enabled\n            if (!series.visible || (!options.enabled && !series._hasPointLabels)) {\n                return;\n            }\n\n            // run parent method\n            Series.prototype.drawDataLabels.apply(series);\n\n            each(data, function (point) {\n                if (point.dataLabel && point.visible) { // #407, #2510\n\n                    // Arrange points for detection collision\n                    halves[point.half].push(point);\n\n                    // Reset positions (#4905)\n                    point.dataLabel._pos = null;\n                }\n            });\n\n            /* Loop over the points in each half, starting from the top and bottom\n             * of the pie to detect overlapping labels.\n             */\n            i = 2;\n            while (i--) {\n\n                var slots = [],\n                    slotsLength,\n                    usedSlots = [],\n                    points = halves[i],\n                    pos,\n                    bottom,\n                    length = points.length,\n                    slotIndex;\n\n                if (!length) {\n                    continue;\n                }\n\n                // Sort by angle\n                series.sortByAngle(points, i - 0.5);\n\n                // Assume equal label heights on either hemisphere (#2630)\n                j = labelHeight = 0;\n                while (!labelHeight && points[j]) { // #1569\n                    labelHeight = points[j] && points[j].dataLabel && (points[j].dataLabel.getBBox().height || 21); // 21 is for #968\n                    j++;\n                }\n\n                // Only do anti-collision when we are outside the pie and have connectors (#856)\n                if (distanceOption > 0) {\n\n                    // Build the slots\n                    bottom = mathMin(centerY + radius + distanceOption, chart.plotHeight);\n                    for (pos = mathMax(0, centerY - radius - distanceOption); pos <= bottom; pos += labelHeight) {\n                        slots.push(pos);\n                    }\n                    slotsLength = slots.length;\n\n\n                    /* Visualize the slots\n                    if (!series.slotElements) {\n                        series.slotElements = [];\n                    }\n                    if (i === 1) {\n                        series.slotElements.forEach(function (elem) {\n                            elem.destroy();\n                        });\n                        series.slotElements.length = 0;\n                    }\n\n                    slots.forEach(function (pos, no) {\n                        var slotX = series.getX(pos, i) + chart.plotLeft - (i ? 100 : 0),\n                            slotY = pos + chart.plotTop;\n\n                        if (isNumber(slotX)) {\n                            series.slotElements.push(chart.renderer.rect(slotX, slotY - 7, 100, labelHeight, 1)\n                                .attr({\n                                    'stroke-width': 1,\n                                    stroke: 'silver',\n                                    fill: 'rgba(0,0,255,0.1)'\n                                })\n                                .add());\n                            series.slotElements.push(chart.renderer.text('Slot '+ no, slotX, slotY + 4)\n                                .attr({\n                                    fill: 'silver'\n                                }).add());\n                        }\n                    });\n                    // */\n\n                    // if there are more values than available slots, remove lowest values\n                    if (length > slotsLength) {\n                        // create an array for sorting and ranking the points within each quarter\n                        rankArr = [].concat(points);\n                        rankArr.sort(sort);\n                        j = length;\n                        while (j--) {\n                            rankArr[j].rank = j;\n                        }\n                        j = length;\n                        while (j--) {\n                            if (points[j].rank >= slotsLength) {\n                                points.splice(j, 1);\n                            }\n                        }\n                        length = points.length;\n                    }\n\n                    // The label goes to the nearest open slot, but not closer to the edge than\n                    // the label's index.\n                    for (j = 0; j < length; j++) {\n\n                        point = points[j];\n                        labelPos = point.labelPos;\n\n                        var closest = 9999,\n                            distance,\n                            slotI;\n\n                        // find the closest slot index\n                        for (slotI = 0; slotI < slotsLength; slotI++) {\n                            distance = mathAbs(slots[slotI] - labelPos[1]);\n                            if (distance < closest) {\n                                closest = distance;\n                                slotIndex = slotI;\n                            }\n                        }\n\n                        // if that slot index is closer to the edges of the slots, move it\n                        // to the closest appropriate slot\n                        if (slotIndex < j && slots[j] !== null) { // cluster at the top\n                            slotIndex = j;\n                        } else if (slotsLength  < length - j + slotIndex && slots[j] !== null) { // cluster at the bottom\n                            slotIndex = slotsLength - length + j;\n                            while (slots[slotIndex] === null) { // make sure it is not taken\n                                slotIndex++;\n                            }\n                        } else {\n                            // Slot is taken, find next free slot below. In the next run, the next slice will find the\n                            // slot above these, because it is the closest one\n                            while (slots[slotIndex] === null) { // make sure it is not taken\n                                slotIndex++;\n                            }\n                        }\n\n                        usedSlots.push({ i: slotIndex, y: slots[slotIndex] });\n                        slots[slotIndex] = null; // mark as taken\n                    }\n                    // sort them in order to fill in from the top\n                    usedSlots.sort(sort);\n                }\n\n                // now the used slots are sorted, fill them up sequentially\n                for (j = 0; j < length; j++) {\n\n                    var slot, naturalY;\n\n                    point = points[j];\n                    labelPos = point.labelPos;\n                    dataLabel = point.dataLabel;\n                    visibility = point.visible === false ? HIDDEN : 'inherit';\n                    naturalY = labelPos[1];\n\n                    if (distanceOption > 0) {\n                        slot = usedSlots.pop();\n                        slotIndex = slot.i;\n\n                        // if the slot next to currrent slot is free, the y value is allowed\n                        // to fall back to the natural position\n                        y = slot.y;\n                        if ((naturalY > y && slots[slotIndex + 1] !== null) ||\n                                (naturalY < y &&  slots[slotIndex - 1] !== null)) {\n                            y = mathMin(mathMax(0, naturalY), chart.plotHeight);\n                        }\n\n                    } else {\n                        y = naturalY;\n                    }\n\n                    // get the x - use the natural x position for first and last slot, to prevent the top\n                    // and botton slice connectors from touching each other on either side\n                    x = options.justify ?\n                        seriesCenter[0] + (i ? -1 : 1) * (radius + distanceOption) :\n                        series.getX(y === centerY - radius - distanceOption || y === centerY + radius + distanceOption ? naturalY : y, i);\n\n\n                    // Record the placement and visibility\n                    dataLabel._attr = {\n                        visibility: visibility,\n                        align: labelPos[6]\n                    };\n                    dataLabel._pos = {\n                        x: x + options.x +\n                            ({ left: connectorPadding, right: -connectorPadding }[labelPos[6]] || 0),\n                        y: y + options.y - 10 // 10 is for the baseline (label vs text)\n                    };\n                    dataLabel.connX = x;\n                    dataLabel.connY = y;\n\n\n                    // Detect overflowing data labels\n                    if (this.options.size === null) {\n                        dataLabelWidth = dataLabel.width;\n                        // Overflow left\n                        if (x - dataLabelWidth < connectorPadding) {\n                            overflow[3] = mathMax(mathRound(dataLabelWidth - x + connectorPadding), overflow[3]);\n\n                        // Overflow right\n                        } else if (x + dataLabelWidth > plotWidth - connectorPadding) {\n                            overflow[1] = mathMax(mathRound(x + dataLabelWidth - plotWidth + connectorPadding), overflow[1]);\n                        }\n\n                        // Overflow top\n                        if (y - labelHeight / 2 < 0) {\n                            overflow[0] = mathMax(mathRound(-y + labelHeight / 2), overflow[0]);\n\n                        // Overflow left\n                        } else if (y + labelHeight / 2 > plotHeight) {\n                            overflow[2] = mathMax(mathRound(y + labelHeight / 2 - plotHeight), overflow[2]);\n                        }\n                    }\n                } // for each point\n            } // for each half\n\n            // Do not apply the final placement and draw the connectors until we have verified\n            // that labels are not spilling over.\n            if (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {\n\n                // Place the labels in the final position\n                this.placeDataLabels();\n\n                // Draw the connectors\n                if (outside && connectorWidth) {\n                    each(this.points, function (point) {\n                        connector = point.connector;\n                        labelPos = point.labelPos;\n                        dataLabel = point.dataLabel;\n\n                        if (dataLabel && dataLabel._pos && point.visible) {\n                            visibility = dataLabel._attr.visibility;\n                            x = dataLabel.connX;\n                            y = dataLabel.connY;\n                            connectorPath = softConnector ? [\n                                M,\n                                x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label\n                                'C',\n                                x, y, // first break, next to the label\n                                2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],\n                                labelPos[2], labelPos[3], // second break\n                                L,\n                                labelPos[4], labelPos[5] // base\n                            ] : [\n                                M,\n                                x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label\n                                L,\n                                labelPos[2], labelPos[3], // second break\n                                L,\n                                labelPos[4], labelPos[5] // base\n                            ];\n\n                            if (connector) {\n                                connector.animate({ d: connectorPath });\n                                connector.attr('visibility', visibility);\n\n                            } else {\n                                point.connector = connector = series.chart.renderer.path(connectorPath).attr({\n                                    'stroke-width': connectorWidth,\n                                    stroke: options.connectorColor || point.color || '#606060',\n                                    visibility: visibility\n                                    //zIndex: 0 // #2722 (reversed)\n                                })\n                                .add(series.dataLabelsGroup);\n                            }\n                        } else if (connector) {\n                            point.connector = connector.destroy();\n                        }\n                    });\n                }\n            }\n        };\n        /**\n         * Perform the final placement of the data labels after we have verified that they\n         * fall within the plot area.\n         */\n        seriesTypes.pie.prototype.placeDataLabels = function () {\n            each(this.points, function (point) {\n                var dataLabel = point.dataLabel,\n                    _pos;\n\n                if (dataLabel && point.visible) {\n                    _pos = dataLabel._pos;\n                    if (_pos) {\n                        dataLabel.attr(dataLabel._attr);\n                        dataLabel[dataLabel.moved ? 'animate' : 'attr'](_pos);\n                        dataLabel.moved = true;\n                    } else if (dataLabel) {\n                        dataLabel.attr({ y: -9999 });\n                    }\n                }\n            });\n        };\n\n        seriesTypes.pie.prototype.alignDataLabel =  noop;\n\n        /**\n         * Verify whether the data labels are allowed to draw, or we should run more translation and data\n         * label positioning to keep them inside the plot area. Returns true when data labels are ready\n         * to draw.\n         */\n        seriesTypes.pie.prototype.verifyDataLabelOverflow = function (overflow) {\n\n            var center = this.center,\n                options = this.options,\n                centerOption = options.center,\n                minSize = options.minSize || 80,\n                newSize = minSize,\n                ret;\n\n            // Handle horizontal size and center\n            if (centerOption[0] !== null) { // Fixed center\n                newSize = mathMax(center[2] - mathMax(overflow[1], overflow[3]), minSize);\n\n            } else { // Auto center\n                newSize = mathMax(\n                    center[2] - overflow[1] - overflow[3], // horizontal overflow\n                    minSize\n                );\n                center[0] += (overflow[3] - overflow[1]) / 2; // horizontal center\n            }\n\n            // Handle vertical size and center\n            if (centerOption[1] !== null) { // Fixed center\n                newSize = mathMax(mathMin(newSize, center[2] - mathMax(overflow[0], overflow[2])), minSize);\n\n            } else { // Auto center\n                newSize = mathMax(\n                    mathMin(\n                        newSize,\n                        center[2] - overflow[0] - overflow[2] // vertical overflow\n                    ),\n                    minSize\n                );\n                center[1] += (overflow[0] - overflow[2]) / 2; // vertical center\n            }\n\n            // If the size must be decreased, we need to run translate and drawDataLabels again\n            if (newSize < center[2]) {\n                center[2] = newSize;\n                center[3] = Math.min(relativeLength(options.innerSize || 0, newSize), newSize); // #3632\n                this.translate(center);\n            \n                if (this.drawDataLabels) {\n                    this.drawDataLabels();\n                }\n            // Else, return true to indicate that the pie and its labels is within the plot area\n            } else {\n                ret = true;\n            }\n            return ret;\n        };\n    }\n\n    if (seriesTypes.column) {\n\n        /**\n         * Override the basic data label alignment by adjusting for the position of the column\n         */\n        seriesTypes.column.prototype.alignDataLabel = function (point, dataLabel, options,  alignTo, isNew) {\n            var inverted = this.chart.inverted,\n                series = point.series,\n                dlBox = point.dlBox || point.shapeArgs, // data label box for alignment\n                below = pick(point.below, point.plotY > pick(this.translatedThreshold, series.yAxis.len)), // point.below is used in range series\n                inside = pick(options.inside, !!this.options.stacking), // draw it inside the box?\n                overshoot;\n\n            // Align to the column itself, or the top of it\n            if (dlBox) { // Area range uses this method but not alignTo\n                alignTo = merge(dlBox);\n\n                if (alignTo.y < 0) {\n                    alignTo.height += alignTo.y;\n                    alignTo.y = 0;\n                }\n                overshoot = alignTo.y + alignTo.height - series.yAxis.len;\n                if (overshoot > 0) {\n                    alignTo.height -= overshoot;\n                }\n\n                if (inverted) {\n                    alignTo = {\n                        x: series.yAxis.len - alignTo.y - alignTo.height,\n                        y: series.xAxis.len - alignTo.x - alignTo.width,\n                        width: alignTo.height,\n                        height: alignTo.width\n                    };\n                }\n\n                // Compute the alignment box\n                if (!inside) {\n                    if (inverted) {\n                        alignTo.x += below ? 0 : alignTo.width;\n                        alignTo.width = 0;\n                    } else {\n                        alignTo.y += below ? alignTo.height : 0;\n                        alignTo.height = 0;\n                    }\n                }\n            }\n\n\n            // When alignment is undefined (typically columns and bars), display the individual\n            // point below or above the point depending on the threshold\n            options.align = pick(\n                options.align,\n                !inverted || inside ? 'center' : below ? 'right' : 'left'\n            );\n            options.verticalAlign = pick(\n                options.verticalAlign,\n                inverted || inside ? 'middle' : below ? 'top' : 'bottom'\n            );\n\n            // Call the parent method\n            Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);\n        };\n    }\n\n\n\n    /**\n     * Highcharts module to hide overlapping data labels. This module is included in Highcharts.\n     */\n    (function (H) {\n        var Chart = H.Chart,\n            each = H.each,\n            pick = H.pick,\n            addEvent = H.addEvent;\n\n        // Collect potensial overlapping data labels. Stack labels probably don't need to be \n        // considered because they are usually accompanied by data labels that lie inside the columns.\n        Chart.prototype.callbacks.push(function (chart) {\n            function collectAndHide() {\n                var labels = [];\n\n                each(chart.series, function (series) {\n                    var dlOptions = series.options.dataLabels,\n                        collections = series.dataLabelCollections || ['dataLabel']; // Range series have two collections\n                    if ((dlOptions.enabled || series._hasPointLabels) && !dlOptions.allowOverlap && series.visible) { // #3866\n                        each(collections, function (coll) {\n                            each(series.points, function (point) {\n                                if (point[coll]) {\n                                    point[coll].labelrank = pick(point.labelrank, point.shapeArgs && point.shapeArgs.height); // #4118\n                                    labels.push(point[coll]);\n                                }\n                            });\n                        });\n                    }\n                });\n                chart.hideOverlappingLabels(labels);\n            }\n\n            // Do it now ...\n            collectAndHide();\n\n            // ... and after each chart redraw\n            addEvent(chart, 'redraw', collectAndHide);\n\n        });\n\n        /**\n         * Hide overlapping labels. Labels are moved and faded in and out on zoom to provide a smooth \n         * visual imression.\n         */    \n        Chart.prototype.hideOverlappingLabels = function (labels) {\n\n            var len = labels.length,\n                label,\n                i,\n                j,\n                label1,\n                label2,\n                isIntersecting,\n                pos1,\n                pos2,\n                parent1,\n                parent2,\n                padding,\n                intersectRect = function (x1, y1, w1, h1, x2, y2, w2, h2) {\n                    return !(\n                        x2 > x1 + w1 ||\n                        x2 + w2 < x1 ||\n                        y2 > y1 + h1 ||\n                        y2 + h2 < y1\n                    );\n                };\n    \n            // Mark with initial opacity\n            for (i = 0; i < len; i++) {\n                label = labels[i];\n                if (label) {\n                    label.oldOpacity = label.opacity;\n                    label.newOpacity = 1;\n                }\n            }\n\n            // Prevent a situation in a gradually rising slope, that each label\n            // will hide the previous one because the previous one always has\n            // lower rank.\n            labels.sort(function (a, b) {\n                return (b.labelrank || 0) - (a.labelrank || 0);\n            });\n\n            // Detect overlapping labels\n            for (i = 0; i < len; i++) {\n                label1 = labels[i];\n\n                for (j = i + 1; j < len; ++j) {\n                    label2 = labels[j];\n                    if (label1 && label2 && label1.placed && label2.placed && label1.newOpacity !== 0 && label2.newOpacity !== 0) {\n                        pos1 = label1.alignAttr;\n                        pos2 = label2.alignAttr;\n                        parent1 = label1.parentGroup; // Different panes have different positions\n                        parent2 = label2.parentGroup;\n                        padding = 2 * (label1.box ? 0 : label1.padding); // Substract the padding if no background or border (#4333)\n                        isIntersecting = intersectRect(\n                            pos1.x + parent1.translateX,\n                            pos1.y + parent1.translateY,\n                            label1.width - padding,\n                            label1.height - padding,\n                            pos2.x + parent2.translateX,\n                            pos2.y + parent2.translateY,\n                            label2.width - padding,\n                            label2.height - padding\n                        );\n\n                        if (isIntersecting) {\n                            (label1.labelrank < label2.labelrank ? label1 : label2).newOpacity = 0;\n                        }\n                    }\n                }\n            }\n\n            // Hide or show\n            each(labels, function (label) {\n                var complete,\n                    newOpacity;\n\n                if (label) {\n                    newOpacity = label.newOpacity;\n\n                    if (label.oldOpacity !== newOpacity && label.placed) {\n\n                        // Make sure the label is completely hidden to avoid catching clicks (#4362)\n                        if (newOpacity) {\n                            label.show(true);\n                        } else {\n                            complete = function () {\n                                label.hide();\n                            };\n                        }\n\n                        // Animate or set the opacity                \n                        label.alignAttr.opacity = newOpacity;\n                        label[label.isOld ? 'animate' : 'attr'](label.alignAttr, null, complete);\n                    \n                    }\n                    label.isOld = true;\n                }\n            });\n        };\n    }(Highcharts));\n    /**\n     * TrackerMixin for points and graphs\n     */\n\n    var TrackerMixin = Highcharts.TrackerMixin = {\n\n        drawTrackerPoint: function () {\n            var series = this,\n                chart = series.chart,\n                pointer = chart.pointer,\n                cursor = series.options.cursor,\n                css = cursor && { cursor: cursor },\n                onMouseOver = function (e) {\n                    var target = e.target,\n                        point;\n\n                    while (target && !point) {\n                        point = target.point;\n                        target = target.parentNode;\n                    }\n\n                    if (point !== UNDEFINED && point !== chart.hoverPoint) { // undefined on graph in scatterchart\n                        point.onMouseOver(e);\n                    }\n                };\n\n            // Add reference to the point\n            each(series.points, function (point) {\n                if (point.graphic) {\n                    point.graphic.element.point = point;\n                }\n                if (point.dataLabel) {\n                    point.dataLabel.element.point = point;\n                }\n            });\n\n            // Add the event listeners, we need to do this only once\n            if (!series._hasTracking) {\n                each(series.trackerGroups, function (key) {\n                    if (series[key]) { // we don't always have dataLabelsGroup\n                        series[key]\n                            .addClass(PREFIX + 'tracker')\n                            .on('mouseover', onMouseOver)\n                            .on('mouseout', function (e) {\n                                pointer.onTrackerMouseOut(e);\n                            })\n                            .css(css);\n                        if (hasTouch) {\n                            series[key].on('touchstart', onMouseOver);\n                        }\n                    }\n                });\n                series._hasTracking = true;\n            }\n        },\n\n        /**\n         * Draw the tracker object that sits above all data labels and markers to\n         * track mouse events on the graph or points. For the line type charts\n         * the tracker uses the same graphPath, but with a greater stroke width\n         * for better control.\n         */\n        drawTrackerGraph: function () {\n            var series = this,\n                options = series.options,\n                trackByArea = options.trackByArea,\n                trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),\n                trackerPathLength = trackerPath.length,\n                chart = series.chart,\n                pointer = chart.pointer,\n                renderer = chart.renderer,\n                snap = chart.options.tooltip.snap,\n                tracker = series.tracker,\n                cursor = options.cursor,\n                css = cursor && { cursor: cursor },\n                i,\n                onMouseOver = function () {\n                    if (chart.hoverSeries !== series) {\n                        series.onMouseOver();\n                    }\n                },\n                /*\n                 * Empirical lowest possible opacities for TRACKER_FILL for an element to stay invisible but clickable\n                 * IE6: 0.002\n                 * IE7: 0.002\n                 * IE8: 0.002\n                 * IE9: 0.00000000001 (unlimited)\n                 * IE10: 0.0001 (exporting only)\n                 * FF: 0.00000000001 (unlimited)\n                 * Chrome: 0.000001\n                 * Safari: 0.000001\n                 * Opera: 0.00000000001 (unlimited)\n                 */\n                TRACKER_FILL = 'rgba(192,192,192,' + (hasSVG ? 0.0001 : 0.002) + ')';\n\n            // Extend end points. A better way would be to use round linecaps,\n            // but those are not clickable in VML.\n            if (trackerPathLength && !trackByArea) {\n                i = trackerPathLength + 1;\n                while (i--) {\n                    if (trackerPath[i] === M) { // extend left side\n                        trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);\n                    }\n                    if ((i && trackerPath[i] === M) || i === trackerPathLength) { // extend right side\n                        trackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);\n                    }\n                }\n            }\n\n            // handle single points\n            /*for (i = 0; i < singlePoints.length; i++) {\n                singlePoint = singlePoints[i];\n                trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,\n                L, singlePoint.plotX + snap, singlePoint.plotY);\n            }*/\n\n            // draw the tracker\n            if (tracker) {\n                tracker.attr({ d: trackerPath });\n            } else { // create\n\n                series.tracker = renderer.path(trackerPath)\n                .attr({\n                    'stroke-linejoin': 'round', // #1225\n                    visibility: series.visible ? VISIBLE : HIDDEN,\n                    stroke: TRACKER_FILL,\n                    fill: trackByArea ? TRACKER_FILL : NONE,\n                    'stroke-width': options.lineWidth + (trackByArea ? 0 : 2 * snap),\n                    zIndex: 2\n                })\n                .add(series.group);\n\n                // The tracker is added to the series group, which is clipped, but is covered\n                // by the marker group. So the marker group also needs to capture events.\n                each([series.tracker, series.markerGroup], function (tracker) {\n                    tracker.addClass(PREFIX + 'tracker')\n                        .on('mouseover', onMouseOver)\n                        .on('mouseout', function (e) {\n                            pointer.onTrackerMouseOut(e);\n                        })\n                        .css(css);\n\n                    if (hasTouch) {\n                        tracker.on('touchstart', onMouseOver);\n                    }\n                });\n            }\n        }\n    };\n    /* End TrackerMixin */\n\n\n    /**\n     * Add tracking event listener to the series group, so the point graphics\n     * themselves act as trackers\n     */\n\n    if (seriesTypes.column) {\n        ColumnSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n    }\n\n    if (seriesTypes.pie) {\n        seriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n    }\n\n    if (seriesTypes.scatter) {\n        ScatterSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n    }\n\n    /*\n     * Extend Legend for item events\n     */\n    extend(Legend.prototype, {\n\n        setItemEvents: function (item, legendItem, useHTML, itemStyle, itemHiddenStyle) {\n            var legend = this;\n            // Set the events on the item group, or in case of useHTML, the item itself (#1249)\n            (useHTML ? legendItem : item.legendGroup).on('mouseover', function () {\n                item.setState(HOVER_STATE);\n                legendItem.css(legend.options.itemHoverStyle);\n            })\n            .on('mouseout', function () {\n                legendItem.css(item.visible ? itemStyle : itemHiddenStyle);\n                item.setState();\n            })\n            .on('click', function (event) {\n                var strLegendItemClick = 'legendItemClick',\n                    fnLegendItemClick = function () {\n                        if (item.setVisible) {\n                            item.setVisible();\n                        }\n                    };\n\n                // Pass over the click/touch event. #4.\n                event = {\n                    browserEvent: event\n                };\n\n                // click the name or symbol\n                if (item.firePointEvent) { // point\n                    item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);\n                } else {\n                    fireEvent(item, strLegendItemClick, event, fnLegendItemClick);\n                }\n            });\n        },\n\n        createCheckboxForItem: function (item) {\n            var legend = this;\n\n            item.checkbox = createElement('input', {\n                type: 'checkbox',\n                checked: item.selected,\n                defaultChecked: item.selected // required by IE7\n            }, legend.options.itemCheckboxStyle, legend.chart.container);\n\n            addEvent(item.checkbox, 'click', function (event) {\n                var target = event.target;\n                fireEvent(\n                    item.series || item, \n                    'checkboxClick', \n                    { // #3712\n                        checked: target.checked,\n                        item: item\n                    },\n                    function () {\n                        item.select();\n                    }\n                );\n            });\n        }\n    });\n\n    /*\n     * Add pointer cursor to legend itemstyle in defaultOptions\n     */\n    defaultOptions.legend.itemStyle.cursor = 'pointer';\n\n\n    /*\n     * Extend the Chart object with interaction\n     */\n\n    extend(Chart.prototype, {\n        /**\n         * Display the zoom button\n         */\n        showResetZoom: function () {\n            var chart = this,\n                lang = defaultOptions.lang,\n                btnOptions = chart.options.chart.resetZoomButton,\n                theme = btnOptions.theme,\n                states = theme.states,\n                alignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';\n\n            function zoomOut() {\n                chart.zoomOut();\n            }\n\n            this.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, zoomOut, theme, states && states.hover)\n                .attr({\n                    align: btnOptions.position.align,\n                    title: lang.resetZoomTitle\n                })\n                .add()\n                .align(btnOptions.position, false, alignTo);\n\n        },\n\n        /**\n         * Zoom out to 1:1\n         */\n        zoomOut: function () {\n            var chart = this;\n            fireEvent(chart, 'selection', { resetSelection: true }, function () {\n                chart.zoom();\n            });\n        },\n\n        /**\n         * Zoom into a given portion of the chart given by axis coordinates\n         * @param {Object} event\n         */\n        zoom: function (event) {\n            var chart = this,\n                hasZoomed,\n                pointer = chart.pointer,\n                displayButton = false,\n                resetZoomButton;\n\n            // If zoom is called with no arguments, reset the axes\n            if (!event || event.resetSelection) {\n                each(chart.axes, function (axis) {\n                    hasZoomed = axis.zoom();\n                });\n            } else { // else, zoom in on all axes\n                each(event.xAxis.concat(event.yAxis), function (axisData) {\n                    var axis = axisData.axis,\n                        isXAxis = axis.isXAxis;\n\n                    // don't zoom more than minRange\n                    if (pointer[isXAxis ? 'zoomX' : 'zoomY'] || pointer[isXAxis ? 'pinchX' : 'pinchY']) {\n                        hasZoomed = axis.zoom(axisData.min, axisData.max);\n                        if (axis.displayBtn) {\n                            displayButton = true;\n                        }\n                    }\n                });\n            }\n\n            // Show or hide the Reset zoom button\n            resetZoomButton = chart.resetZoomButton;\n            if (displayButton && !resetZoomButton) {\n                chart.showResetZoom();\n            } else if (!displayButton && isObject(resetZoomButton)) {\n                chart.resetZoomButton = resetZoomButton.destroy();\n            }\n\n\n            // Redraw\n            if (hasZoomed) {\n                chart.redraw(\n                    pick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100) // animation\n                );\n            }\n        },\n\n        /**\n         * Pan the chart by dragging the mouse across the pane. This function is called\n         * on mouse move, and the distance to pan is computed from chartX compared to\n         * the first chartX position in the dragging operation.\n         */\n        pan: function (e, panning) {\n\n            var chart = this,\n                hoverPoints = chart.hoverPoints,\n                doRedraw;\n\n            // remove active points for shared tooltip\n            if (hoverPoints) {\n                each(hoverPoints, function (point) {\n                    point.setState();\n                });\n            }\n\n            each(panning === 'xy' ? [1, 0] : [1], function (isX) { // xy is used in maps\n                var axis = chart[isX ? 'xAxis' : 'yAxis'][0],\n                    horiz = axis.horiz,\n                    mousePos = e[horiz ? 'chartX' : 'chartY'],\n                    mouseDown = horiz ? 'mouseDownX' : 'mouseDownY',\n                    startPos = chart[mouseDown],\n                    halfPointRange = (axis.pointRange || 0) / 2,\n                    extremes = axis.getExtremes(),\n                    newMin = axis.toValue(startPos - mousePos, true) + halfPointRange,\n                    newMax = axis.toValue(startPos + axis.len - mousePos, true) - halfPointRange,\n                    goingLeft = startPos > mousePos; // #3613\n            \n                if (axis.series.length &&\n                        (goingLeft || newMin > mathMin(extremes.dataMin, extremes.min)) &&    \n                        (!goingLeft || newMax < mathMax(extremes.dataMax, extremes.max))) {\n                    axis.setExtremes(newMin, newMax, false, false, { trigger: 'pan' });\n                    doRedraw = true;\n                }\n\n                chart[mouseDown] = mousePos; // set new reference for next run\n            });\n\n            if (doRedraw) {\n                chart.redraw(false);\n            }\n            css(chart.container, { cursor: 'move' });\n        }\n    });\n\n    /*\n     * Extend the Point object with interaction\n     */\n    extend(Point.prototype, {\n        /**\n         * Toggle the selection status of a point\n         * @param {Boolean} selected Whether to select or unselect the point.\n         * @param {Boolean} accumulate Whether to add to the previous selection. By default,\n         *         this happens if the control key (Cmd on Mac) was pressed during clicking.\n         */\n        select: function (selected, accumulate) {\n            var point = this,\n                series = point.series,\n                chart = series.chart;\n\n            selected = pick(selected, !point.selected);\n\n            // fire the event with the default handler\n            point.firePointEvent(selected ? 'select' : 'unselect', { accumulate: accumulate }, function () {\n                point.selected = point.options.selected = selected;\n                series.options.data[inArray(point, series.data)] = point.options;\n\n                point.setState(selected && SELECT_STATE);\n\n                // unselect all other points unless Ctrl or Cmd + click\n                if (!accumulate) {\n                    each(chart.getSelectedPoints(), function (loopPoint) {\n                        if (loopPoint.selected && loopPoint !== point) {\n                            loopPoint.selected = loopPoint.options.selected = false;\n                            series.options.data[inArray(loopPoint, series.data)] = loopPoint.options;\n                            loopPoint.setState(NORMAL_STATE);\n                            loopPoint.firePointEvent('unselect');\n                        }\n                    });\n                }\n            });\n        },\n\n        /**\n         * Runs on mouse over the point\n         *\n         * @param {Object} e The event arguments\n         * @param {Boolean} byProximity Falsy for kd points that are closest to the mouse, or to\n         *        actually hovered points. True for other points in shared tooltip.\n         */\n        onMouseOver: function (e, byProximity) {\n            var point = this,\n                series = point.series,\n                chart = series.chart,\n                tooltip = chart.tooltip,\n                hoverPoint = chart.hoverPoint;\n\n            if (chart.hoverSeries !== series) {\n                series.onMouseOver();\n            }\n\n            // set normal state to previous series\n            if (hoverPoint && hoverPoint !== point) {\n                hoverPoint.onMouseOut();\n            }\n\n            if (point.series) { // It may have been destroyed, #4130\n\n                // trigger the event\n                point.firePointEvent('mouseOver');\n\n                // update the tooltip\n                if (tooltip && (!tooltip.shared || series.noSharedTooltip)) {\n                    tooltip.refresh(point, e);\n                }\n\n                // hover this\n                point.setState(HOVER_STATE);\n                if (!byProximity) {\n                    chart.hoverPoint = point;\n                }\n            }\n        },\n\n        /**\n         * Runs on mouse out from the point\n         */\n        onMouseOut: function () {\n            var chart = this.series.chart,\n                hoverPoints = chart.hoverPoints;\n\n            this.firePointEvent('mouseOut');\n\n            if (!hoverPoints || inArray(this, hoverPoints) === -1) { // #887, #2240\n                this.setState();\n                chart.hoverPoint = null;\n            }\n        },\n\n        /**\n         * Import events from the series' and point's options. Only do it on\n         * demand, to save processing time on hovering.\n         */\n        importEvents: function () {\n            if (!this.hasImportedEvents) {\n                var point = this,\n                    options = merge(point.series.options.point, point.options),\n                    events = options.events,\n                    eventType;\n\n                point.events = events;\n\n                for (eventType in events) {\n                    addEvent(point, eventType, events[eventType]);\n                }\n                this.hasImportedEvents = true;\n\n            }\n        },\n\n        /**\n         * Set the point's state\n         * @param {String} state\n         */\n        setState: function (state, move) {\n            var point = this,\n                plotX = mathFloor(point.plotX), // #4586\n                plotY = point.plotY,\n                series = point.series,\n                stateOptions = series.options.states,\n                markerOptions = defaultPlotOptions[series.type].marker && series.options.marker,\n                normalDisabled = markerOptions && !markerOptions.enabled,\n                markerStateOptions = markerOptions && markerOptions.states[state],\n                stateDisabled = markerStateOptions && markerStateOptions.enabled === false,\n                stateMarkerGraphic = series.stateMarkerGraphic,\n                pointMarker = point.marker || {},\n                chart = series.chart,\n                radius,\n                halo = series.halo,\n                haloOptions,\n                newSymbol,\n                pointAttr;\n\n            state = state || NORMAL_STATE; // empty string\n            pointAttr = point.pointAttr[state] || series.pointAttr[state];\n\n            if (\n                    // already has this state\n                    (state === point.state && !move) ||\n                    // selected points don't respond to hover\n                    (point.selected && state !== SELECT_STATE) ||\n                    // series' state options is disabled\n                    (stateOptions[state] && stateOptions[state].enabled === false) ||\n                    // general point marker's state options is disabled\n                    (state && (stateDisabled || (normalDisabled && markerStateOptions.enabled === false))) ||\n                    // individual point marker's state options is disabled\n                    (state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false) // #1610\n\n                ) {\n                return;\n            }\n\n            // apply hover styles to the existing point\n            if (point.graphic) {\n                radius = markerOptions && point.graphic.symbolName && pointAttr.r;\n                point.graphic.attr(merge(\n                    pointAttr,\n                    radius ? { // new symbol attributes (#507, #612)\n                        x: plotX - radius,\n                        y: plotY - radius,\n                        width: 2 * radius,\n                        height: 2 * radius\n                    } : {}\n                ));\n\n                // Zooming in from a range with no markers to a range with markers\n                if (stateMarkerGraphic) {\n                    stateMarkerGraphic.hide();\n                }\n            } else {\n                // if a graphic is not applied to each point in the normal state, create a shared\n                // graphic for the hover state\n                if (state && markerStateOptions) {\n                    radius = markerStateOptions.radius;\n                    newSymbol = pointMarker.symbol || series.symbol;\n\n                    // If the point has another symbol than the previous one, throw away the\n                    // state marker graphic and force a new one (#1459)\n                    if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {\n                        stateMarkerGraphic = stateMarkerGraphic.destroy();\n                    }\n\n                    // Add a new state marker graphic\n                    if (!stateMarkerGraphic) {\n                        if (newSymbol) {\n                            series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(\n                                newSymbol,\n                                plotX - radius,\n                                plotY - radius,\n                                2 * radius,\n                                2 * radius\n                            )\n                            .attr(pointAttr)\n                            .add(series.markerGroup);\n                            stateMarkerGraphic.currentSymbol = newSymbol;\n                        }\n\n                    // Move the existing graphic\n                    } else {\n                        stateMarkerGraphic[move ? 'animate' : 'attr']({ // #1054\n                            x: plotX - radius,\n                            y: plotY - radius\n                        });\n                    }\n                }\n\n                if (stateMarkerGraphic) {\n                    stateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY, chart.inverted) ? 'show' : 'hide'](); // #2450\n                    stateMarkerGraphic.element.point = point; // #4310\n                }\n            }\n\n            // Show me your halo\n            haloOptions = stateOptions[state] && stateOptions[state].halo;\n            if (haloOptions && haloOptions.size) {\n                if (!halo) {\n                    series.halo = halo = chart.renderer.path()\n                        .add(chart.seriesGroup);\n                }\n                halo.attr(extend({\n                    'fill': point.color || series.color,\n                    'fill-opacity': haloOptions.opacity,\n                    'zIndex': -1 // #4929, IE8 added halo above everything\n                },\n                haloOptions.attributes))[move ? 'animate' : 'attr']({\n                    d: point.haloPath(haloOptions.size)\n                });\n            } else if (halo) {\n                halo.attr({ d: [] });\n            }\n\n            point.state = state;\n        },\n\n        /**\n         * Get the circular path definition for the halo\n         * @param  {Number} size The radius of the circular halo\n         * @returns {Array} The path definition\n         */\n        haloPath: function (size) {\n            var series = this.series,\n                chart = series.chart,\n                plotBox = series.getPlotBox(),\n                inverted = chart.inverted,\n                plotX = Math.floor(this.plotX);\n\n            return chart.renderer.symbols.circle(\n                plotBox.translateX + (inverted ? series.yAxis.len - this.plotY : plotX) - size, \n                plotBox.translateY + (inverted ? series.xAxis.len - plotX : this.plotY) - size, \n                size * 2, \n                size * 2\n            );\n        }\n    });\n\n    /*\n     * Extend the Series object with interaction\n     */\n\n    extend(Series.prototype, {\n        /**\n         * Series mouse over handler\n         */\n        onMouseOver: function () {\n            var series = this,\n                chart = series.chart,\n                hoverSeries = chart.hoverSeries;\n\n            // set normal state to previous series\n            if (hoverSeries && hoverSeries !== series) {\n                hoverSeries.onMouseOut();\n            }\n\n            // trigger the event, but to save processing time,\n            // only if defined\n            if (series.options.events.mouseOver) {\n                fireEvent(series, 'mouseOver');\n            }\n\n            // hover this\n            series.setState(HOVER_STATE);\n            chart.hoverSeries = series;\n        },\n\n        /**\n         * Series mouse out handler\n         */\n        onMouseOut: function () {\n            // trigger the event only if listeners exist\n            var series = this,\n                options = series.options,\n                chart = series.chart,\n                tooltip = chart.tooltip,\n                hoverPoint = chart.hoverPoint;\n\n            chart.hoverSeries = null; // #182, set to null before the mouseOut event fires\n\n            // trigger mouse out on the point, which must be in this series\n            if (hoverPoint) {\n                hoverPoint.onMouseOut();\n            }\n\n            // fire the mouse out event\n            if (series && options.events.mouseOut) {\n                fireEvent(series, 'mouseOut');\n            }\n\n\n            // hide the tooltip\n            if (tooltip && !options.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {\n                tooltip.hide();\n            }\n\n            // set normal state\n            series.setState();\n        },\n\n        /**\n         * Set the state of the graph\n         */\n        setState: function (state) {\n            var series = this,\n                options = series.options,\n                graph = series.graph,\n                stateOptions = options.states,\n                lineWidth = options.lineWidth,\n                attribs,\n                i = 0;\n\n            state = state || NORMAL_STATE;\n\n            if (series.state !== state) {\n                series.state = state;\n\n                if (stateOptions[state] && stateOptions[state].enabled === false) {\n                    return;\n                }\n\n                if (state) {\n                    lineWidth = stateOptions[state].lineWidth || lineWidth + (stateOptions[state].lineWidthPlus || 0); // #4035\n                }\n\n                if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML\n                    attribs = {\n                        'stroke-width': lineWidth\n                    };\n                    // use attr because animate will cause any other animation on the graph to stop\n                    graph.attr(attribs);\n                    while (series['zoneGraph' + i]) {\n                        series['zoneGraph' + i].attr(attribs);\n                        i = i + 1;\n                    }\n                }\n            }\n        },\n\n        /**\n         * Set the visibility of the graph\n         *\n         * @param vis {Boolean} True to show the series, false to hide. If UNDEFINED,\n         *                the visibility is toggled.\n         */\n        setVisible: function (vis, redraw) {\n            var series = this,\n                chart = series.chart,\n                legendItem = series.legendItem,\n                showOrHide,\n                ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,\n                oldVisibility = series.visible;\n\n            // if called without an argument, toggle visibility\n            series.visible = vis = series.options.visible = series.userOptions.visible = vis === undefined ? !oldVisibility : vis; // #5618\n            showOrHide = vis ? 'show' : 'hide';\n\n            // show or hide elements\n            each(['group', 'dataLabelsGroup', 'markerGroup', 'tracker'], function (key) {\n                if (series[key]) {\n                    series[key][showOrHide]();\n                }\n            });\n\n\n            // hide tooltip (#1361)\n            if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {\n                series.onMouseOut();\n            }\n\n\n            if (legendItem) {\n                chart.legend.colorizeItem(series, vis);\n            }\n\n\n            // rescale or adapt to resized chart\n            series.isDirty = true;\n            // in a stack, all other series are affected\n            if (series.options.stacking) {\n                each(chart.series, function (otherSeries) {\n                    if (otherSeries.options.stacking && otherSeries.visible) {\n                        otherSeries.isDirty = true;\n                    }\n                });\n            }\n\n            // show or hide linked series\n            each(series.linkedSeries, function (otherSeries) {\n                otherSeries.setVisible(vis, false);\n            });\n\n            if (ignoreHiddenSeries) {\n                chart.isDirtyBox = true;\n            }\n            if (redraw !== false) {\n                chart.redraw();\n            }\n\n            fireEvent(series, showOrHide);\n        },\n\n        /**\n         * Show the graph\n         */\n        show: function () {\n            this.setVisible(true);\n        },\n\n        /**\n         * Hide the graph\n         */\n        hide: function () {\n            this.setVisible(false);\n        },\n\n\n        /**\n         * Set the selected state of the graph\n         *\n         * @param selected {Boolean} True to select the series, false to unselect. If\n         *                UNDEFINED, the selection state is toggled.\n         */\n        select: function (selected) {\n            var series = this;\n            // if called without an argument, toggle\n            series.selected = selected = (selected === UNDEFINED) ? !series.selected : selected;\n\n            if (series.checkbox) {\n                series.checkbox.checked = selected;\n            }\n\n            fireEvent(series, selected ? 'select' : 'unselect');\n        },\n\n        drawTracker: TrackerMixin.drawTrackerGraph\n    });\n    /* ****************************************************************************\n     * Start ordinal axis logic                                                   *\n     *****************************************************************************/\n\n\n    wrap(Series.prototype, 'init', function (proceed) {\n        var series = this,\n            xAxis;\n\n        // call the original function\n        proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n\n        xAxis = series.xAxis;\n\n        // Destroy the extended ordinal index on updated data\n        if (xAxis && xAxis.options.ordinal) {\n            addEvent(series, 'updatedData', function () {\n                delete xAxis.ordinalIndex;\n            });\n        }\n    });\n\n    /**\n     * In an ordinal axis, there might be areas with dense consentrations of points, then large\n     * gaps between some. Creating equally distributed ticks over this entire range\n     * may lead to a huge number of ticks that will later be removed. So instead, break the\n     * positions up in segments, find the tick positions for each segment then concatenize them.\n     * This method is used from both data grouping logic and X axis tick position logic.\n     */\n    wrap(Axis.prototype, 'getTimeTicks', function (proceed, normalizedInterval, min, max, startOfWeek, positions, closestDistance, findHigherRanks) {\n\n        var start = 0,\n            end,\n            segmentPositions,\n            higherRanks = {},\n            hasCrossedHigherRank,\n            info,\n            posLength,\n            outsideMax,\n            groupPositions = [],\n            lastGroupPosition = -Number.MAX_VALUE,\n            tickPixelIntervalOption = this.options.tickPixelInterval;\n\n        // The positions are not always defined, for example for ordinal positions when data\n        // has regular interval (#1557, #2090)\n        if ((!this.options.ordinal && !this.options.breaks) || !positions || positions.length < 3 || min === UNDEFINED) {\n            return proceed.call(this, normalizedInterval, min, max, startOfWeek);\n        }\n\n        // Analyze the positions array to split it into segments on gaps larger than 5 times\n        // the closest distance. The closest distance is already found at this point, so\n        // we reuse that instead of computing it again.\n        posLength = positions.length;\n\n        for (end = 0; end < posLength; end++) {\n\n            outsideMax = end && positions[end - 1] > max;\n\n            if (positions[end] < min) { // Set the last position before min\n                start = end;\n            }\n\n            if (end === posLength - 1 || positions[end + 1] - positions[end] > closestDistance * 5 || outsideMax) {\n\n                // For each segment, calculate the tick positions from the getTimeTicks utility\n                // function. The interval will be the same regardless of how long the segment is.\n                if (positions[end] > lastGroupPosition) { // #1475\n\n                    segmentPositions = proceed.call(this, normalizedInterval, positions[start], positions[end], startOfWeek);\n\n                    // Prevent duplicate groups, for example for multiple segments within one larger time frame (#1475)\n                    while (segmentPositions.length && segmentPositions[0] <= lastGroupPosition) {\n                        segmentPositions.shift();\n                    }\n                    if (segmentPositions.length) {\n                        lastGroupPosition = segmentPositions[segmentPositions.length - 1];\n                    }\n\n                    groupPositions = groupPositions.concat(segmentPositions);\n                }\n                // Set start of next segment\n                start = end + 1;\n            }\n\n            if (outsideMax) {\n                break;\n            }\n        }\n\n        // Get the grouping info from the last of the segments. The info is the same for\n        // all segments.\n        info = segmentPositions.info;\n\n        // Optionally identify ticks with higher rank, for example when the ticks\n        // have crossed midnight.\n        if (findHigherRanks && info.unitRange <= timeUnits.hour) {\n            end = groupPositions.length - 1;\n\n            // Compare points two by two\n            for (start = 1; start < end; start++) {\n                if (dateFormat('%d', groupPositions[start]) !== dateFormat('%d', groupPositions[start - 1])) {\n                    higherRanks[groupPositions[start]] = 'day';\n                    hasCrossedHigherRank = true;\n                }\n            }\n\n            // If the complete array has crossed midnight, we want to mark the first\n            // positions also as higher rank\n            if (hasCrossedHigherRank) {\n                higherRanks[groupPositions[0]] = 'day';\n            }\n            info.higherRanks = higherRanks;\n        }\n\n        // Save the info\n        groupPositions.info = info;\n\n\n\n        // Don't show ticks within a gap in the ordinal axis, where the space between\n        // two points is greater than a portion of the tick pixel interval\n        if (findHigherRanks && defined(tickPixelIntervalOption)) { // check for squashed ticks\n\n            var length = groupPositions.length,\n                i = length,\n                itemToRemove,\n                translated,\n                translatedArr = [],\n                lastTranslated,\n                medianDistance,\n                distance,\n                distances = [];\n\n            // Find median pixel distance in order to keep a reasonably even distance between\n            // ticks (#748)\n            while (i--) {\n                translated = this.translate(groupPositions[i]);\n                if (lastTranslated) {\n                    distances[i] = lastTranslated - translated;\n                }\n                translatedArr[i] = lastTranslated = translated;\n            }\n            distances.sort();\n            medianDistance = distances[mathFloor(distances.length / 2)];\n            if (medianDistance < tickPixelIntervalOption * 0.6) {\n                medianDistance = null;\n            }\n\n            // Now loop over again and remove ticks where needed\n            i = groupPositions[length - 1] > max ? length - 1 : length; // #817\n            lastTranslated = undefined;\n            while (i--) {\n                translated = translatedArr[i];\n                distance = lastTranslated - translated;\n\n                // Remove ticks that are closer than 0.6 times the pixel interval from the one to the right,\n                // but not if it is close to the median distance (#748).\n                if (lastTranslated && distance < tickPixelIntervalOption * 0.8 &&\n                        (medianDistance === null || distance < medianDistance * 0.8)) {\n\n                    // Is this a higher ranked position with a normal position to the right?\n                    if (higherRanks[groupPositions[i]] && !higherRanks[groupPositions[i + 1]]) {\n\n                        // Yes: remove the lower ranked neighbour to the right\n                        itemToRemove = i + 1;\n                        lastTranslated = translated; // #709\n\n                    } else {\n\n                        // No: remove this one\n                        itemToRemove = i;\n                    }\n\n                    groupPositions.splice(itemToRemove, 1);\n\n                } else {\n                    lastTranslated = translated;\n                }\n            }\n        }\n        return groupPositions;\n    });\n\n    // Extend the Axis prototype\n    extend(Axis.prototype, {\n\n        /**\n         * Calculate the ordinal positions before tick positions are calculated.\n         */\n        beforeSetTickPositions: function () {\n            var axis = this,\n                len,\n                ordinalPositions = [],\n                useOrdinal = false,\n                dist,\n                extremes = axis.getExtremes(),\n                min = extremes.min,\n                max = extremes.max,\n                minIndex,\n                maxIndex,\n                slope,\n                hasBreaks = axis.isXAxis && !!axis.options.breaks,\n                isOrdinal = axis.options.ordinal,\n                ignoreHiddenSeries = axis.chart.options.chart.ignoreHiddenSeries,\n                i;\n\n            // apply the ordinal logic\n            if (isOrdinal || hasBreaks) { // #4167 YAxis is never ordinal ?\n\n                each(axis.series, function (series, i) {\n\n                    if ((!ignoreHiddenSeries || series.visible !== false) && (series.takeOrdinalPosition !== false || hasBreaks)) {\n\n                        // concatenate the processed X data into the existing positions, or the empty array\n                        ordinalPositions = ordinalPositions.concat(series.processedXData);\n                        len = ordinalPositions.length;\n\n                        // remove duplicates (#1588)\n                        ordinalPositions.sort(function (a, b) {\n                            return a - b; // without a custom function it is sorted as strings\n                        });\n\n                        if (len) {\n                            i = len - 1;\n                            while (i--) {\n                                if (ordinalPositions[i] === ordinalPositions[i + 1]) {\n                                    ordinalPositions.splice(i, 1);\n                                }\n                            }\n                        }\n                    }\n\n                });\n\n                // cache the length\n                len = ordinalPositions.length;\n\n                // Check if we really need the overhead of mapping axis data against the ordinal positions.\n                // If the series consist of evenly spaced data any way, we don't need any ordinal logic.\n                if (len > 2) { // two points have equal distance by default\n                    dist = ordinalPositions[1] - ordinalPositions[0];\n                    i = len - 1;\n                    while (i-- && !useOrdinal) {\n                        if (ordinalPositions[i + 1] - ordinalPositions[i] !== dist) {\n                            useOrdinal = true;\n                        }\n                    }\n\n                    // When zooming in on a week, prevent axis padding for weekends even though the data within\n                    // the week is evenly spaced.\n                    if (!axis.options.keepOrdinalPadding && (ordinalPositions[0] - min > dist || max - ordinalPositions[ordinalPositions.length - 1] > dist)) {\n                        useOrdinal = true;\n                    }\n                }\n\n                // Record the slope and offset to compute the linear values from the array index.\n                // Since the ordinal positions may exceed the current range, get the start and\n                // end positions within it (#719, #665b)\n                if (useOrdinal) {\n\n                    // Register\n                    axis.ordinalPositions = ordinalPositions;\n\n                    // This relies on the ordinalPositions being set. Use mathMax and mathMin to prevent\n                    // padding on either sides of the data.\n                    minIndex = axis.val2lin(mathMax(min, ordinalPositions[0]), true);\n                    maxIndex = mathMax(axis.val2lin(mathMin(max, ordinalPositions[ordinalPositions.length - 1]), true), 1); // #3339\n\n                    // Set the slope and offset of the values compared to the indices in the ordinal positions\n                    axis.ordinalSlope = slope = (max - min) / (maxIndex - minIndex);\n                    axis.ordinalOffset = min - (minIndex * slope);\n\n                } else {\n                    axis.ordinalPositions = axis.ordinalSlope = axis.ordinalOffset = UNDEFINED;\n                }\n            }\n            axis.isOrdinal = isOrdinal && useOrdinal; // #3818, #4196, #4926\n            axis.groupIntervalFactor = null; // reset for next run\n        },\n        /**\n         * Translate from a linear axis value to the corresponding ordinal axis position. If there\n         * are no gaps in the ordinal axis this will be the same. The translated value is the value\n         * that the point would have if the axis were linear, using the same min and max.\n         *\n         * @param Number val The axis value\n         * @param Boolean toIndex Whether to return the index in the ordinalPositions or the new value\n         */\n        val2lin: function (val, toIndex) {\n            var axis = this,\n                ordinalPositions = axis.ordinalPositions,\n                ret;\n\n            if (!ordinalPositions) {\n                ret = val;\n\n            } else {\n\n                var ordinalLength = ordinalPositions.length,\n                    i,\n                    distance,\n                    ordinalIndex;\n\n                // first look for an exact match in the ordinalpositions array\n                i = ordinalLength;\n                while (i--) {\n                    if (ordinalPositions[i] === val) {\n                        ordinalIndex = i;\n                        break;\n                    }\n                }\n\n                // if that failed, find the intermediate position between the two nearest values\n                i = ordinalLength - 1;\n                while (i--) {\n                    if (val > ordinalPositions[i] || i === 0) { // interpolate\n                        distance = (val - ordinalPositions[i]) / (ordinalPositions[i + 1] - ordinalPositions[i]); // something between 0 and 1\n                        ordinalIndex = i + distance;\n                        break;\n                    }\n                }\n                ret = toIndex ?\n                    ordinalIndex :\n                    axis.ordinalSlope * (ordinalIndex || 0) + axis.ordinalOffset;\n            }\n            return ret;\n        },\n        /**\n         * Translate from linear (internal) to axis value\n         *\n         * @param Number val The linear abstracted value\n         * @param Boolean fromIndex Translate from an index in the ordinal positions rather than a value\n         */\n        lin2val: function (val, fromIndex) {\n            var axis = this,\n                ordinalPositions = axis.ordinalPositions,\n                ret;\n\n            if (!ordinalPositions) { // the visible range contains only equally spaced values\n                ret = val;\n\n            } else {\n\n                var ordinalSlope = axis.ordinalSlope,\n                    ordinalOffset = axis.ordinalOffset,\n                    i = ordinalPositions.length - 1,\n                    linearEquivalentLeft,\n                    linearEquivalentRight,\n                    distance;\n\n\n                // Handle the case where we translate from the index directly, used only\n                // when panning an ordinal axis\n                if (fromIndex) {\n\n                    if (val < 0) { // out of range, in effect panning to the left\n                        val = ordinalPositions[0];\n                    } else if (val > i) { // out of range, panning to the right\n                        val = ordinalPositions[i];\n                    } else { // split it up\n                        i = mathFloor(val);\n                        distance = val - i; // the decimal\n                    }\n\n                // Loop down along the ordinal positions. When the linear equivalent of i matches\n                // an ordinal position, interpolate between the left and right values.\n                } else {\n                    while (i--) {\n                        linearEquivalentLeft = (ordinalSlope * i) + ordinalOffset;\n                        if (val >= linearEquivalentLeft) {\n                            linearEquivalentRight = (ordinalSlope * (i + 1)) + ordinalOffset;\n                            distance = (val - linearEquivalentLeft) / (linearEquivalentRight - linearEquivalentLeft); // something between 0 and 1\n                            break;\n                        }\n                    }\n                }\n\n                // If the index is within the range of the ordinal positions, return the associated\n                // or interpolated value. If not, just return the value\n                ret = distance !== UNDEFINED && ordinalPositions[i] !== UNDEFINED ?\n                    ordinalPositions[i] + (distance ? distance * (ordinalPositions[i + 1] - ordinalPositions[i]) : 0) :\n                    val;\n            }\n            return ret;\n        },\n        /**\n         * Get the ordinal positions for the entire data set. This is necessary in chart panning\n         * because we need to find out what points or data groups are available outside the\n         * visible range. When a panning operation starts, if an index for the given grouping\n         * does not exists, it is created and cached. This index is deleted on updated data, so\n         * it will be regenerated the next time a panning operation starts.\n         */\n        getExtendedPositions: function () {\n            var axis = this,\n                chart = axis.chart,\n                grouping = axis.series[0].currentDataGrouping,\n                ordinalIndex = axis.ordinalIndex,\n                key = grouping ? grouping.count + grouping.unitName : 'raw',\n                extremes = axis.getExtremes(),\n                fakeAxis,\n                fakeSeries;\n\n            // If this is the first time, or the ordinal index is deleted by updatedData,\n            // create it.\n            if (!ordinalIndex) {\n                ordinalIndex = axis.ordinalIndex = {};\n            }\n\n\n            if (!ordinalIndex[key]) {\n\n                // Create a fake axis object where the extended ordinal positions are emulated\n                fakeAxis = {\n                    series: [],\n                    chart: chart,\n                    getExtremes: function () {\n                        return {\n                            min: extremes.dataMin,\n                            max: extremes.dataMax\n                        };\n                    },\n                    options: {\n                        ordinal: true\n                    },\n                    val2lin: Axis.prototype.val2lin // #2590\n                };\n\n                // Add the fake series to hold the full data, then apply processData to it\n                each(axis.series, function (series) {\n                    fakeSeries = {\n                        xAxis: fakeAxis,\n                        xData: series.xData,\n                        chart: chart,\n                        destroyGroupedData: noop\n                    };\n                    fakeSeries.options = {\n                        dataGrouping: grouping ? {\n                            enabled: true,\n                            forced: true,\n                            approximation: 'open', // doesn't matter which, use the fastest\n                            units: [[grouping.unitName, [grouping.count]]]\n                        } : {\n                            enabled: false\n                        }\n                    };\n                    series.processData.apply(fakeSeries);\n\n                    fakeAxis.series.push(fakeSeries);\n                });\n\n                // Run beforeSetTickPositions to compute the ordinalPositions\n                axis.beforeSetTickPositions.apply(fakeAxis);\n\n                // Cache it\n                ordinalIndex[key] = fakeAxis.ordinalPositions;\n            }\n            return ordinalIndex[key];\n        },\n\n        /**\n         * Find the factor to estimate how wide the plot area would have been if ordinal\n         * gaps were included. This value is used to compute an imagined plot width in order\n         * to establish the data grouping interval.\n         *\n         * A real world case is the intraday-candlestick\n         * example. Without this logic, it would show the correct data grouping when viewing\n         * a range within each day, but once moving the range to include the gap between two\n         * days, the interval would include the cut-away night hours and the data grouping\n         * would be wrong. So the below method tries to compensate by identifying the most\n         * common point interval, in this case days.\n         *\n         * An opposite case is presented in issue #718. We have a long array of daily data,\n         * then one point is appended one hour after the last point. We expect the data grouping\n         * not to change.\n         *\n         * In the future, if we find cases where this estimation doesn't work optimally, we\n         * might need to add a second pass to the data grouping logic, where we do another run\n         * with a greater interval if the number of data groups is more than a certain fraction\n         * of the desired group count.\n         */\n        getGroupIntervalFactor: function (xMin, xMax, series) {\n            var i,\n                processedXData = series.processedXData,\n                len = processedXData.length,\n                distances = [],\n                median,\n                groupIntervalFactor = this.groupIntervalFactor;\n\n            // Only do this computation for the first series, let the other inherit it (#2416)\n            if (!groupIntervalFactor) {\n\n                // Register all the distances in an array\n                for (i = 0; i < len - 1; i++) {\n                    distances[i] = processedXData[i + 1] - processedXData[i];\n                }\n\n                // Sort them and find the median\n                distances.sort(function (a, b) {\n                    return a - b;\n                });\n                median = distances[mathFloor(len / 2)];\n\n                // Compensate for series that don't extend through the entire axis extent. #1675.\n                xMin = mathMax(xMin, processedXData[0]);\n                xMax = mathMin(xMax, processedXData[len - 1]);\n\n                this.groupIntervalFactor = groupIntervalFactor = (len * median) / (xMax - xMin);\n            }\n\n            // Return the factor needed for data grouping\n            return groupIntervalFactor;\n        },\n\n        /**\n         * Make the tick intervals closer because the ordinal gaps make the ticks spread out or cluster\n         */\n        postProcessTickInterval: function (tickInterval) {\n            // Problem: http://jsfiddle.net/highcharts/FQm4E/1/\n            // This is a case where this algorithm doesn't work optimally. In this case, the\n            // tick labels are spread out per week, but all the gaps reside within weeks. So\n            // we have a situation where the labels are courser than the ordinal gaps, and\n            // thus the tick interval should not be altered\n            var ordinalSlope = this.ordinalSlope,\n                ret;\n\n\n            if (ordinalSlope) {\n                if (!this.options.breaks) {\n                    ret = tickInterval / (ordinalSlope / this.closestPointRange);\n                } else {\n                    ret = this.closestPointRange;\n                }\n            } else {\n                ret = tickInterval;\n            }\n            return ret;\n        }\n    });\n\n    // Extending the Chart.pan method for ordinal axes\n    wrap(Chart.prototype, 'pan', function (proceed, e) {\n        var chart = this,\n            xAxis = chart.xAxis[0],\n            chartX = e.chartX,\n            runBase = false;\n\n        if (xAxis.options.ordinal && xAxis.series.length) {\n\n            var mouseDownX = chart.mouseDownX,\n                extremes = xAxis.getExtremes(),\n                dataMax = extremes.dataMax,\n                min = extremes.min,\n                max = extremes.max,\n                trimmedRange,\n                hoverPoints = chart.hoverPoints,\n                closestPointRange = xAxis.closestPointRange,\n                pointPixelWidth = xAxis.translationSlope * (xAxis.ordinalSlope || closestPointRange),\n                movedUnits = (mouseDownX - chartX) / pointPixelWidth, // how many ordinal units did we move?\n                extendedAxis = { ordinalPositions: xAxis.getExtendedPositions() }, // get index of all the chart's points\n                ordinalPositions,\n                searchAxisLeft,\n                lin2val = xAxis.lin2val,\n                val2lin = xAxis.val2lin,\n                searchAxisRight;\n\n            if (!extendedAxis.ordinalPositions) { // we have an ordinal axis, but the data is equally spaced\n                runBase = true;\n\n            } else if (mathAbs(movedUnits) > 1) {\n\n                // Remove active points for shared tooltip\n                if (hoverPoints) {\n                    each(hoverPoints, function (point) {\n                        point.setState();\n                    });\n                }\n\n                if (movedUnits < 0) {\n                    searchAxisLeft = extendedAxis;\n                    searchAxisRight = xAxis.ordinalPositions ? xAxis : extendedAxis;\n                } else {\n                    searchAxisLeft = xAxis.ordinalPositions ? xAxis : extendedAxis;\n                    searchAxisRight = extendedAxis;\n                }\n\n                // In grouped data series, the last ordinal position represents the grouped data, which is\n                // to the left of the real data max. If we don't compensate for this, we will be allowed\n                // to pan grouped data series passed the right of the plot area.\n                ordinalPositions = searchAxisRight.ordinalPositions;\n                if (dataMax > ordinalPositions[ordinalPositions.length - 1]) {\n                    ordinalPositions.push(dataMax);\n                }\n\n                // Get the new min and max values by getting the ordinal index for the current extreme,\n                // then add the moved units and translate back to values. This happens on the\n                // extended ordinal positions if the new position is out of range, else it happens\n                // on the current x axis which is smaller and faster.\n                chart.fixedRange = max - min;\n                trimmedRange = xAxis.toFixedRange(null, null,\n                    lin2val.apply(searchAxisLeft, [\n                        val2lin.apply(searchAxisLeft, [min, true]) + movedUnits, // the new index\n                        true // translate from index\n                    ]),\n                    lin2val.apply(searchAxisRight, [\n                        val2lin.apply(searchAxisRight, [max, true]) + movedUnits, // the new index\n                        true // translate from index\n                    ])\n                );\n\n                // Apply it if it is within the available data range\n                if (trimmedRange.min >= mathMin(extremes.dataMin, min) && trimmedRange.max <= mathMax(dataMax, max)) {\n                    xAxis.setExtremes(trimmedRange.min, trimmedRange.max, true, false, { trigger: 'pan' });\n                }\n\n                chart.mouseDownX = chartX; // set new reference for next run\n                css(chart.container, { cursor: 'move' });\n            }\n\n        } else {\n            runBase = true;\n        }\n\n        // revert to the linear chart.pan version\n        if (runBase) {\n            // call the original function\n            proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n        }\n    });\n\n\n\n    /**\n     * Extend getGraphPath by identifying gaps in the ordinal data so that we can draw a gap in the\n     * line or area\n     */\n    Series.prototype.gappedPath = function () {\n        var gapSize = this.options.gapSize,\n            points = this.points.slice(),\n            i = points.length - 1;\n\n        if (gapSize && i > 0) { // #5008\n\n            // extension for ordinal breaks\n            while (i--) {\n                if (points[i + 1].x - points[i].x > this.closestPointRange * gapSize) {\n                    points.splice( // insert after this one\n                        i + 1,\n                        0,\n                        { isNull: true }\n                    );\n                }\n            }\n        }\n\n        // Call base method\n        //return proceed.call(this, points, a, b);\n        return this.getGraphPath(points);\n    };\n\n    /* ****************************************************************************\n     * End ordinal axis logic                                                   *\n     *****************************************************************************/\n    /**\n     * Highstock JS v4.2.7 (2016-09-21)\n     * Highcharts Broken Axis module\n     * \n     * License: www.highcharts.com/license\n     */\n\n    (function (factory) {\n        \n        factory(Highcharts);\n    \n    }(function (H) {\n\n        'use strict';\n\n        var pick = H.pick,\n            wrap = H.wrap,\n            each = H.each,\n            extend = H.extend,\n            fireEvent = H.fireEvent,\n            Axis = H.Axis,\n            Series = H.Series;\n\n        function stripArguments() {\n            return Array.prototype.slice.call(arguments, 1);\n        }\n\n        extend(Axis.prototype, {\n            isInBreak: function (brk, val) {\n                var ret,\n                    repeat = brk.repeat || Infinity,\n                    from = brk.from,\n                    length = brk.to - brk.from,\n                    test = (val >= from ? (val - from) % repeat :  repeat - ((from - val) % repeat));\n\n                if (!brk.inclusive) {\n                    ret = test < length && test !== 0;\n                } else {\n                    ret = test <= length;\n                }\n                return ret;\n            },\n\n            isInAnyBreak: function (val, testKeep) {\n\n                var breaks = this.options.breaks,\n                    i = breaks && breaks.length,\n                    inbrk,\n                    keep,\n                    ret;\n\n            \n                if (i) { \n\n                    while (i--) {\n                        if (this.isInBreak(breaks[i], val)) {\n                            inbrk = true;\n                            if (!keep) {\n                                keep = pick(breaks[i].showPoints, this.isXAxis ? false : true);\n                            }\n                        }\n                    }\n\n                    if (inbrk && testKeep) {\n                        ret = inbrk && !keep;\n                    } else {\n                        ret = inbrk;\n                    }\n                }\n                return ret;\n            }\n        });\n\n        wrap(Axis.prototype, 'setTickPositions', function (proceed) {\n            proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n        \n            if (this.options.breaks) {\n                var axis = this,\n                    tickPositions = this.tickPositions,\n                    info = this.tickPositions.info,\n                    newPositions = [],\n                    i;\n\n                for (i = 0; i < tickPositions.length; i++) {\n                    if (!axis.isInAnyBreak(tickPositions[i])) {\n                        newPositions.push(tickPositions[i]);\n                    }\n                }\n\n                this.tickPositions = newPositions;\n                this.tickPositions.info = info;\n            }\n        });\n    \n        wrap(Axis.prototype, 'init', function (proceed, chart, userOptions) {\n            // Force Axis to be not-ordinal when breaks are defined\n            if (userOptions.breaks && userOptions.breaks.length) {\n                userOptions.ordinal = false;\n            }\n\n            proceed.call(this, chart, userOptions);\n\n            if (this.options.breaks) {\n\n                var axis = this;\n            \n                axis.isBroken = true;\n\n                this.val2lin = function (val) {\n                    var nval = val,\n                        brk,\n                        i;\n\n                    for (i = 0; i < axis.breakArray.length; i++) {\n                        brk = axis.breakArray[i];\n                        if (brk.to <= val) {\n                            nval -= brk.len;\n                        } else if (brk.from >= val) {\n                            break;\n                        } else if (axis.isInBreak(brk, val)) {\n                            nval -= (val - brk.from);\n                            break;\n                        }\n                    }\n\n                    return nval;\n                };\n            \n                this.lin2val = function (val) {\n                    var nval = val,\n                        brk,\n                        i;\n\n                    for (i = 0; i < axis.breakArray.length; i++) {\n                        brk = axis.breakArray[i];\n                        if (brk.from >= nval) {\n                            break;\n                        } else if (brk.to < nval) {\n                            nval += brk.len;\n                        } else if (axis.isInBreak(brk, nval)) {\n                            nval += brk.len;\n                        }\n                    }\n                    return nval;\n                };\n\n                this.setExtremes = function (newMin, newMax, redraw, animation, eventArguments) {\n                    // If trying to set extremes inside a break, extend it to before and after the break ( #3857 )\n                    while (this.isInAnyBreak(newMin)) {\n                        newMin -= this.closestPointRange;\n                    }            \n                    while (this.isInAnyBreak(newMax)) {\n                        newMax -= this.closestPointRange;\n                    }\n                    Axis.prototype.setExtremes.call(this, newMin, newMax, redraw, animation, eventArguments);\n                };\n\n                this.setAxisTranslation = function (saveOld) {\n                    Axis.prototype.setAxisTranslation.call(this, saveOld);\n\n                    var breaks = axis.options.breaks,\n                        breakArrayT = [],    // Temporary one\n                        breakArray = [],\n                        length = 0, \n                        inBrk,\n                        repeat,\n                        brk,\n                        min = axis.userMin || axis.min,\n                        max = axis.userMax || axis.max,\n                        start,\n                        i,\n                        j;\n\n                    // Min & max check (#4247)\n                    for (i in breaks) {\n                        brk = breaks[i];\n                        repeat = brk.repeat || Infinity;\n                        if (axis.isInBreak(brk, min)) {\n                            min += (brk.to % repeat) - (min % repeat);\n                        }\n                        if (axis.isInBreak(brk, max)) {\n                            max -= (max % repeat) - (brk.from % repeat);\n                        }\n                    }\n\n                    // Construct an array holding all breaks in the axis\n                    for (i in breaks) {\n                        brk = breaks[i];\n                        start = brk.from;\n                        repeat = brk.repeat || Infinity;\n\n                        while (start - repeat > min) {\n                            start -= repeat;\n                        }\n                        while (start < min) {\n                            start += repeat;\n                        }\n\n                        for (j = start; j < max; j += repeat) {\n                            breakArrayT.push({\n                                value: j,\n                                move: 'in'\n                            });\n                            breakArrayT.push({\n                                value: j + (brk.to - brk.from),\n                                move: 'out',\n                                size: brk.breakSize\n                            });\n                        }\n                    }\n\n                    breakArrayT.sort(function (a, b) {\n                        var ret;\n                        if (a.value === b.value) {\n                            ret = (a.move === 'in' ? 0 : 1) - (b.move === 'in' ? 0 : 1);\n                        } else {\n                            ret = a.value - b.value;\n                        }\n                        return ret;\n                    });\n                \n                    // Simplify the breaks\n                    inBrk = 0;\n                    start = min;\n\n                    for (i in breakArrayT) {\n                        brk = breakArrayT[i];\n                        inBrk += (brk.move === 'in' ? 1 : -1);\n\n                        if (inBrk === 1 && brk.move === 'in') {\n                            start = brk.value;\n                        }\n                        if (inBrk === 0) {\n                            breakArray.push({\n                                from: start,\n                                to: brk.value,\n                                len: brk.value - start - (brk.size || 0)\n                            });\n                            length += brk.value - start - (brk.size || 0);\n                        }\n                    }\n\n                    axis.breakArray = breakArray;\n\n                    fireEvent(axis, 'afterBreaks');\n                \n                    axis.transA *= ((max - axis.min) / (max - min - length));\n\n                    axis.min = min;\n                    axis.max = max;\n                };\n            }\n        });\n\n        wrap(Series.prototype, 'generatePoints', function (proceed) {\n\n            proceed.apply(this, stripArguments(arguments));\n\n            var series = this,\n                xAxis = series.xAxis,\n                yAxis = series.yAxis,\n                points = series.points,\n                point,\n                i = points.length,\n                connectNulls = series.options.connectNulls,\n                nullGap;\n\n\n            if (xAxis && yAxis && (xAxis.options.breaks || yAxis.options.breaks)) {\n                while (i--) {\n                    point = points[i];\n\n                    nullGap = point.y === null && connectNulls === false; // respect nulls inside the break (#4275)\n                    if (!nullGap && (xAxis.isInAnyBreak(point.x, true) || yAxis.isInAnyBreak(point.y, true))) {\n                        points.splice(i, 1);\n                        if (this.data[i]) {\n                            this.data[i].destroyElements(); // removes the graphics for this point if they exist\n                        }\n                    }\n                }\n            }\n\n        });\n\n        function drawPointsWrapped(proceed) {\n            proceed.apply(this);\n            this.drawBreaks(this.xAxis, ['x']);\n            this.drawBreaks(this.yAxis, pick(this.pointArrayMap, ['y']));\n        }\n\n        H.Series.prototype.drawBreaks = function (axis, keys) {\n            var series = this,\n                points = series.points,\n                breaks,\n                threshold,\n                eventName,\n                y;\n\n            each(keys, function (key) {\n                breaks = axis.breakArray || [];\n                threshold = axis.isXAxis ? axis.min : pick(series.options.threshold, axis.min);\n                each(points, function (point) {\n                    y = pick(point['stack' + key.toUpperCase()], point[key]);\n                    each(breaks, function (brk) {\n                        eventName = false;\n\n                        if ((threshold < brk.from && y > brk.to) || (threshold > brk.from && y < brk.from)) { \n                            eventName = 'pointBreak';\n                        } else if ((threshold < brk.from && y > brk.from && y < brk.to) || (threshold > brk.from && y > brk.to && y < brk.from)) { // point falls inside the break\n                            eventName = 'pointInBreak';\n                        } \n                        if (eventName) {\n                            fireEvent(axis, eventName, { point: point, brk: brk });\n                        }\n                    });\n                });\n            });\n        };\n\n        wrap(H.seriesTypes.column.prototype, 'drawPoints', drawPointsWrapped);\n        wrap(H.Series.prototype, 'drawPoints', drawPointsWrapped);\n\n    }));\n    /* ****************************************************************************\n     * Start data grouping module                                                 *\n     ******************************************************************************/\n    var DATA_GROUPING = 'dataGrouping',\n        seriesProto = Series.prototype,\n        baseProcessData = seriesProto.processData,\n        baseGeneratePoints = seriesProto.generatePoints,\n        baseDestroy = seriesProto.destroy,\n\n        commonOptions = {\n            approximation: 'average', // average, open, high, low, close, sum\n            //enabled: null, // (true for stock charts, false for basic),\n            //forced: undefined,\n            groupPixelWidth: 2,\n            // the first one is the point or start value, the second is the start value if we're dealing with range,\n            // the third one is the end value if dealing with a range\n            dateTimeLabelFormats: {\n                millisecond: ['%A, %b %e, %H:%M:%S.%L', '%A, %b %e, %H:%M:%S.%L', '-%H:%M:%S.%L'],\n                second: ['%A, %b %e, %H:%M:%S', '%A, %b %e, %H:%M:%S', '-%H:%M:%S'],\n                minute: ['%A, %b %e, %H:%M', '%A, %b %e, %H:%M', '-%H:%M'],\n                hour: ['%A, %b %e, %H:%M', '%A, %b %e, %H:%M', '-%H:%M'],\n                day: ['%A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],\n                week: ['Week from %A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],\n                month: ['%B %Y', '%B', '-%B %Y'],\n                year: ['%Y', '%Y', '-%Y']\n            }\n            // smoothed = false, // enable this for navigator series only\n        },\n\n        specificOptions = { // extends common options\n            line: {},\n            spline: {},\n            area: {},\n            areaspline: {},\n            column: {\n                approximation: 'sum',\n                groupPixelWidth: 10\n            },\n            arearange: {\n                approximation: 'range'\n            },\n            areasplinerange: {\n                approximation: 'range'\n            },\n            columnrange: {\n                approximation: 'range',\n                groupPixelWidth: 10\n            },\n            candlestick: {\n                approximation: 'ohlc',\n                groupPixelWidth: 10\n            },\n            ohlc: {\n                approximation: 'ohlc',\n                groupPixelWidth: 5\n            }\n        },\n\n        // units are defined in a separate array to allow complete overriding in case of a user option\n        defaultDataGroupingUnits = [\n            [\n                'millisecond', // unit name\n                [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples\n            ], [\n                'second',\n                [1, 2, 5, 10, 15, 30]\n            ], [\n                'minute',\n                [1, 2, 5, 10, 15, 30]\n            ], [\n                'hour',\n                [1, 2, 3, 4, 6, 8, 12]\n            ], [\n                'day',\n                [1]\n            ], [\n                'week',\n                [1]\n            ], [\n                'month',\n                [1, 3, 6]\n            ], [\n                'year',\n                null\n            ]\n        ],\n\n\n        /**\n         * Define the available approximation types. The data grouping approximations takes an array\n         * or numbers as the first parameter. In case of ohlc, four arrays are sent in as four parameters.\n         * Each array consists only of numbers. In case null values belong to the group, the property\n         * .hasNulls will be set to true on the array.\n         */\n        approximations = {\n            sum: function (arr) {\n                var len = arr.length,\n                    ret;\n\n                // 1. it consists of nulls exclusively\n                if (!len && arr.hasNulls) {\n                    ret = null;\n                // 2. it has a length and real values\n                } else if (len) {\n                    ret = 0;\n                    while (len--) {\n                        ret += arr[len];\n                    }\n                }\n                // 3. it has zero length, so just return undefined\n                // => doNothing()\n\n                return ret;\n            },\n            average: function (arr) {\n                var len = arr.length,\n                    ret = approximations.sum(arr);\n\n                // If we have a number, return it divided by the length. If not, return\n                // null or undefined based on what the sum method finds.\n                if (isNumber(ret) && len) {\n                    ret = ret / len;\n                }\n\n                return ret;\n            },\n            open: function (arr) {\n                return arr.length ? arr[0] : (arr.hasNulls ? null : UNDEFINED);\n            },\n            high: function (arr) {\n                return arr.length ? arrayMax(arr) : (arr.hasNulls ? null : UNDEFINED);\n            },\n            low: function (arr) {\n                return arr.length ? arrayMin(arr) : (arr.hasNulls ? null : UNDEFINED);\n            },\n            close: function (arr) {\n                return arr.length ? arr[arr.length - 1] : (arr.hasNulls ? null : UNDEFINED);\n            },\n            // ohlc and range are special cases where a multidimensional array is input and an array is output\n            ohlc: function (open, high, low, close) {\n                open = approximations.open(open);\n                high = approximations.high(high);\n                low = approximations.low(low);\n                close = approximations.close(close);\n\n                if (isNumber(open) || isNumber(high) || isNumber(low) || isNumber(close)) {\n                    return [open, high, low, close];\n                }\n                // else, return is undefined\n            },\n            range: function (low, high) {\n                low = approximations.low(low);\n                high = approximations.high(high);\n\n                if (isNumber(low) || isNumber(high)) {\n                    return [low, high];\n                }\n                // else, return is undefined\n            }\n        };\n\n\n    /**\n     * Takes parallel arrays of x and y data and groups the data into intervals defined by groupPositions, a collection\n     * of starting x values for each group.\n     */\n    seriesProto.groupData = function (xData, yData, groupPositions, approximation) {\n        var series = this,\n            data = series.data,\n            dataOptions = series.options.data,\n            groupedXData = [],\n            groupedYData = [],\n            groupMap = [],\n            dataLength = xData.length,\n            pointX,\n            pointY,\n            groupedY,\n            handleYData = !!yData, // when grouping the fake extended axis for panning, we don't need to consider y\n            values = [[], [], [], []],\n            approximationFn = typeof approximation === 'function' ? approximation : approximations[approximation],\n            pointArrayMap = series.pointArrayMap,\n            pointArrayMapLength = pointArrayMap && pointArrayMap.length,\n            i,\n            pos = 0,\n            start = 0;\n\n        // Start with the first point within the X axis range (#2696)\n        for (i = 0; i <= dataLength; i++) {\n            if (xData[i] >= groupPositions[0]) {\n                break;\n            }\n        }\n\n        for (i; i <= dataLength; i++) {\n\n            // when a new group is entered, summarize and initiate the previous group\n            while ((groupPositions[pos + 1] !== undefined && xData[i] >= groupPositions[pos + 1]) ||\n                    i === dataLength) { // get the last group\n\n                // get group x and y\n                pointX = groupPositions[pos];\n                series.dataGroupInfo = { start: start, length: values[0].length };\n                groupedY = approximationFn.apply(series, values);\n\n                // push the grouped data\n                if (groupedY !== UNDEFINED) {\n                    groupedXData.push(pointX);\n                    groupedYData.push(groupedY);\n                    groupMap.push(series.dataGroupInfo);\n                }\n\n                // reset the aggregate arrays\n                start = i;\n                values[0] = [];\n                values[1] = [];\n                values[2] = [];\n                values[3] = [];\n\n                // Advance on the group positions\n                pos += 1;\n\n                // don't loop beyond the last group\n                if (i === dataLength) {\n                    break;\n                }\n            }\n\n            // break out\n            if (i === dataLength) {\n                break;\n            }\n\n            // for each raw data point, push it to an array that contains all values for this specific group\n            if (pointArrayMap) {\n\n                var index = series.cropStart + i,\n                    point = (data && data[index]) || series.pointClass.prototype.applyOptions.apply({ series: series }, [dataOptions[index]]),\n                    j,\n                    val;\n\n                for (j = 0; j < pointArrayMapLength; j++) {\n                    val = point[pointArrayMap[j]];\n                    if (isNumber(val)) {\n                        values[j].push(val);\n                    } else if (val === null) {\n                        values[j].hasNulls = true;\n                    }\n                }\n\n            } else {\n                pointY = handleYData ? yData[i] : null;\n\n                if (isNumber(pointY)) {\n                    values[0].push(pointY);\n                } else if (pointY === null) {\n                    values[0].hasNulls = true;\n                }\n            }\n        }\n\n        return [groupedXData, groupedYData, groupMap];\n    };\n\n    /**\n     * Extend the basic processData method, that crops the data to the current zoom\n     * range, with data grouping logic.\n     */\n    seriesProto.processData = function () {\n        var series = this,\n            chart = series.chart,\n            options = series.options,\n            dataGroupingOptions = options[DATA_GROUPING],\n            groupingEnabled = series.allowDG !== false && dataGroupingOptions && pick(dataGroupingOptions.enabled, chart.options._stock),\n            hasGroupedData,\n            skip;\n\n        // run base method\n        series.forceCrop = groupingEnabled; // #334\n        series.groupPixelWidth = null; // #2110\n        series.hasProcessed = true; // #2692\n\n        // skip if processData returns false or if grouping is disabled (in that order) or #5493\n        skip = baseProcessData.apply(series, arguments) === false || !groupingEnabled || !series.visible;\n        if (!skip) {\n            series.destroyGroupedData();\n\n            var i,\n                processedXData = series.processedXData,\n                processedYData = series.processedYData,\n                plotSizeX = chart.plotSizeX,\n                xAxis = series.xAxis,\n                ordinal = xAxis.options.ordinal,\n                groupPixelWidth = series.groupPixelWidth = xAxis.getGroupPixelWidth && xAxis.getGroupPixelWidth();\n\n            // Execute grouping if the amount of points is greater than the limit defined in groupPixelWidth\n            if (groupPixelWidth) {\n                hasGroupedData = true;\n\n                series.isDirty = true; // force recreation of point instances in series.translate, #5699\n\n                var extremes = xAxis.getExtremes(),\n                    xMin = extremes.min,\n                    xMax = extremes.max,\n                    groupIntervalFactor = (ordinal && xAxis.getGroupIntervalFactor(xMin, xMax, series)) || 1,\n                    interval = (groupPixelWidth * (xMax - xMin) / plotSizeX) * groupIntervalFactor,\n                    groupPositions = xAxis.getTimeTicks(\n                        xAxis.normalizeTimeTickInterval(interval, dataGroupingOptions.units || defaultDataGroupingUnits),\n                        Math.min(xMin, processedXData[0]), // Processed data may extend beyond axis (#4907)\n                        Math.max(xMax, processedXData[processedXData.length - 1]),\n                        xAxis.options.startOfWeek,\n                        processedXData,\n                        series.closestPointRange\n                    ),\n                    groupedData = seriesProto.groupData.apply(series, [processedXData, processedYData, groupPositions, dataGroupingOptions.approximation]),\n                    groupedXData = groupedData[0],\n                    groupedYData = groupedData[1];\n\n                // prevent the smoothed data to spill out left and right, and make\n                // sure data is not shifted to the left\n                if (dataGroupingOptions.smoothed) {\n                    i = groupedXData.length - 1;\n                    groupedXData[i] = Math.min(groupedXData[i], xMax);\n                    while (i-- && i > 0) {\n                        groupedXData[i] += interval / 2;\n                    }\n                    groupedXData[0] = Math.max(groupedXData[0], xMin);\n                }\n\n                // record what data grouping values were used\n                series.currentDataGrouping = groupPositions.info;\n                series.closestPointRange = groupPositions.info.totalRange;\n                series.groupMap = groupedData[2];\n\n                // Make sure the X axis extends to show the first group (#2533)\n                if (defined(groupedXData[0]) && groupedXData[0] < xAxis.dataMin) {\n                    if (xAxis.min === xAxis.dataMin) {\n                        xAxis.min = groupedXData[0];\n                    }\n                    xAxis.dataMin = groupedXData[0];\n                }\n\n                // set series props\n                series.processedXData = groupedXData;\n                series.processedYData = groupedYData;\n            } else {\n                series.currentDataGrouping = series.groupMap = null;\n            }\n            series.hasGroupedData = hasGroupedData;\n        }\n    };\n\n    /**\n     * Destroy the grouped data points. #622, #740\n     */\n    seriesProto.destroyGroupedData = function () {\n\n        var groupedData = this.groupedData;\n\n        // clear previous groups\n        each(groupedData || [], function (point, i) {\n            if (point) {\n                groupedData[i] = point.destroy ? point.destroy() : null;\n            }\n        });\n        this.groupedData = null;\n    };\n\n    /**\n     * Override the generatePoints method by adding a reference to grouped data\n     */\n    seriesProto.generatePoints = function () {\n\n        baseGeneratePoints.apply(this);\n\n        // record grouped data in order to let it be destroyed the next time processData runs\n        this.destroyGroupedData(); // #622\n        this.groupedData = this.hasGroupedData ? this.points : null;\n    };\n\n    /**\n     * Override point prototype to throw a warning when trying to update grouped points\n     */\n    wrap(Point.prototype, 'update', function (proceed) {\n        if (this.dataGroup) {\n            error(24);\n        } else {\n            proceed.apply(this, [].slice.call(arguments, 1));\n        }\n    });\n\n    /**\n     * Extend the original method, make the tooltip's header reflect the grouped range\n     */\n    wrap(Tooltip.prototype, 'tooltipFooterHeaderFormatter', function (proceed, labelConfig, isFooter) {\n        var tooltip = this,\n            series = labelConfig.series,\n            options = series.options,\n            tooltipOptions = series.tooltipOptions,\n            dataGroupingOptions = options.dataGrouping,\n            xDateFormat = tooltipOptions.xDateFormat,\n            xDateFormatEnd,\n            xAxis = series.xAxis,\n            currentDataGrouping,\n            dateTimeLabelFormats,\n            labelFormats,\n            formattedKey;\n\n        // apply only to grouped series\n        if (xAxis && xAxis.options.type === 'datetime' && dataGroupingOptions && isNumber(labelConfig.key)) {\n\n            // set variables\n            currentDataGrouping = series.currentDataGrouping;\n            dateTimeLabelFormats = dataGroupingOptions.dateTimeLabelFormats;\n\n            // if we have grouped data, use the grouping information to get the right format\n            if (currentDataGrouping) {\n                labelFormats = dateTimeLabelFormats[currentDataGrouping.unitName];\n                if (currentDataGrouping.count === 1) {\n                    xDateFormat = labelFormats[0];\n                } else {\n                    xDateFormat = labelFormats[1];\n                    xDateFormatEnd = labelFormats[2];\n                }\n            // if not grouped, and we don't have set the xDateFormat option, get the best fit,\n            // so if the least distance between points is one minute, show it, but if the\n            // least distance is one day, skip hours and minutes etc.\n            } else if (!xDateFormat && dateTimeLabelFormats) {\n                xDateFormat = tooltip.getXDateFormat(labelConfig, tooltipOptions, xAxis);\n            }\n\n            // now format the key\n            formattedKey = dateFormat(xDateFormat, labelConfig.key);\n            if (xDateFormatEnd) {\n                formattedKey += dateFormat(xDateFormatEnd, labelConfig.key + currentDataGrouping.totalRange - 1);\n            }\n\n            // return the replaced format\n            return format(tooltipOptions[(isFooter ? 'footer' : 'header') + 'Format'], {\n                point: extend(labelConfig.point, { key: formattedKey }),\n                series: series\n            });\n    \n        }\n\n        // else, fall back to the regular formatter\n        return proceed.call(tooltip, labelConfig, isFooter);\n    });\n\n    /**\n     * Extend the series destroyer\n     */\n    seriesProto.destroy = function () {\n        var series = this,\n            groupedData = series.groupedData || [],\n            i = groupedData.length;\n\n        while (i--) {\n            if (groupedData[i]) {\n                groupedData[i].destroy();\n            }\n        }\n        baseDestroy.apply(series);\n    };\n\n\n    // Handle default options for data grouping. This must be set at runtime because some series types are\n    // defined after this.\n    wrap(seriesProto, 'setOptions', function (proceed, itemOptions) {\n\n        var options = proceed.call(this, itemOptions),\n            type = this.type,\n            plotOptions = this.chart.options.plotOptions,\n            defaultOptions = defaultPlotOptions[type].dataGrouping;\n\n        if (specificOptions[type]) { // #1284\n            if (!defaultOptions) {\n                defaultOptions = merge(commonOptions, specificOptions[type]);\n            }\n\n            options.dataGrouping = merge(\n                defaultOptions,\n                plotOptions.series && plotOptions.series.dataGrouping, // #1228\n                plotOptions[type].dataGrouping, // Set by the StockChart constructor\n                itemOptions.dataGrouping\n            );\n        }\n\n        if (this.chart.options._stock) {\n            this.requireSorting = true;\n        }\n\n        return options;\n    });\n\n\n    /**\n     * When resetting the scale reset the hasProccessed flag to avoid taking previous data grouping\n     * of neighbour series into accound when determining group pixel width (#2692).\n     */\n    wrap(Axis.prototype, 'setScale', function (proceed) {\n        proceed.call(this);\n        each(this.series, function (series) {\n            series.hasProcessed = false;\n        });\n    });\n\n    /**\n     * Get the data grouping pixel width based on the greatest defined individual width\n     * of the axis' series, and if whether one of the axes need grouping.\n     */\n    Axis.prototype.getGroupPixelWidth = function () {\n\n        var series = this.series,\n            len = series.length,\n            i,\n            groupPixelWidth = 0,\n            doGrouping = false,\n            dataLength,\n            dgOptions;\n\n        // If multiple series are compared on the same x axis, give them the same\n        // group pixel width (#334)\n        i = len;\n        while (i--) {\n            dgOptions = series[i].options.dataGrouping;\n            if (dgOptions) {\n                groupPixelWidth = mathMax(groupPixelWidth, dgOptions.groupPixelWidth);\n\n            }\n        }\n\n        // If one of the series needs grouping, apply it to all (#1634)\n        i = len;\n        while (i--) {\n            dgOptions = series[i].options.dataGrouping;\n\n            if (dgOptions && series[i].hasProcessed) { // #2692\n\n                dataLength = (series[i].processedXData || series[i].data).length;\n\n                // Execute grouping if the amount of points is greater than the limit defined in groupPixelWidth\n                if (series[i].groupPixelWidth || dataLength > (this.chart.plotSizeX / groupPixelWidth) || (dataLength && dgOptions.forced)) {\n                    doGrouping = true;\n                }\n            }\n        }\n\n        return doGrouping ? groupPixelWidth : 0;\n    };\n\n    /**\n     * Force data grouping on all the axis' series.\n     */\n    Axis.prototype.setDataGrouping = function (dataGrouping, redraw) {\n        var i;\n\n        redraw = pick(redraw, true);\n\n        if (!dataGrouping) {\n            dataGrouping = {\n                forced: false,\n                units: null\n            };\n        }\n\n        // Axis is instantiated, update all series\n        if (this instanceof Axis) {\n            i = this.series.length;\n            while (i--) {\n                this.series[i].update({\n                    dataGrouping: dataGrouping\n                }, false);\n            }\n\n        // Axis not yet instanciated, alter series options\n        } else {\n            each(this.chart.options.series, function (seriesOptions) {\n                seriesOptions.dataGrouping = dataGrouping;\n            }, false);\n        }\n\n        if (redraw) {\n            this.chart.redraw();\n        }\n    };\n\n\n\n    /* ****************************************************************************\n     * End data grouping module                                                   *\n     ******************************************************************************/\n    /* ****************************************************************************\n     * Start OHLC series code                                                     *\n     *****************************************************************************/\n\n    // 1 - Set default options\n    defaultPlotOptions.ohlc = merge(defaultPlotOptions.column, {\n        lineWidth: 1,\n        tooltip: {\n            pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> <b> {series.name}</b><br/>' +\n                'Open: {point.open}<br/>' +\n                'High: {point.high}<br/>' +\n                'Low: {point.low}<br/>' +\n                'Close: {point.close}<br/>'\n        },\n        states: {\n            hover: {\n                lineWidth: 3\n            }\n        },\n        threshold: null\n        //upColor: undefined\n    });\n\n    // 2 - Create the OHLCSeries object\n    var OHLCSeries = extendClass(seriesTypes.column, {\n        type: 'ohlc',\n        pointArrayMap: ['open', 'high', 'low', 'close'], // array point configs are mapped to this\n        toYData: function (point) { // return a plain array for speedy calculation\n            return [point.open, point.high, point.low, point.close];\n        },\n        pointValKey: 'high',\n\n        pointAttrToOptions: { // mapping between SVG attributes and the corresponding options\n            stroke: 'color',\n            'stroke-width': 'lineWidth'\n        },\n        upColorProp: 'stroke',\n\n        /**\n         * Postprocess mapping between options and SVG attributes\n         */\n        getAttribs: function () {\n            seriesTypes.column.prototype.getAttribs.apply(this, arguments);\n            var series = this,\n                options = series.options,\n                stateOptions = options.states,\n                upColor = options.upColor || series.color,\n                seriesDownPointAttr = merge(series.pointAttr),\n                upColorProp = series.upColorProp;\n\n            seriesDownPointAttr[''][upColorProp] = upColor;\n            seriesDownPointAttr.hover[upColorProp] = stateOptions.hover.upColor || upColor;\n            seriesDownPointAttr.select[upColorProp] = stateOptions.select.upColor || upColor;\n\n            each(series.points, function (point) {\n                if (point.open < point.close && !point.options.color) {\n                    point.pointAttr = seriesDownPointAttr;\n                }\n            });\n        },\n\n        /**\n         * Translate data points from raw values x and y to plotX and plotY\n         */\n        translate: function () {\n            var series = this,\n                yAxis = series.yAxis,\n                hasModifyValue = !!series.modifyValue,\n                translatedOLC = ['plotOpen', 'yBottom', 'plotClose'];\n\n            seriesTypes.column.prototype.translate.apply(series);\n\n            // Do the translation\n            each(series.points, function (point) {\n                each([point.open, point.low, point.close], function (value, i) {\n                    if (value !== null) {\n                        if (hasModifyValue) {\n                            value = series.modifyValue(value);\n                        }\n                        point[translatedOLC[i]] = yAxis.toPixels(value, true);\n                    }\n                });\n            });\n        },\n\n        /**\n         * Draw the data points\n         */\n        drawPoints: function () {\n            var series = this,\n                points = series.points,\n                chart = series.chart,\n                pointAttr,\n                plotOpen,\n                plotClose,\n                crispCorr,\n                halfWidth,\n                path,\n                graphic,\n                crispX;\n\n\n            each(points, function (point) {\n                if (point.plotY !== UNDEFINED) {\n\n                    graphic = point.graphic;\n                    pointAttr = point.pointAttr[point.selected ? 'selected' : ''] || series.pointAttr[NORMAL_STATE];\n\n                    // crisp vector coordinates\n                    crispCorr = (pointAttr['stroke-width'] % 2) / 2;\n                    crispX = mathRound(point.plotX) - crispCorr;  // #2596\n                    halfWidth = mathRound(point.shapeArgs.width / 2);\n\n                    // the vertical stem\n                    path = [\n                        'M',\n                        crispX, mathRound(point.yBottom),\n                        'L',\n                        crispX, mathRound(point.plotY)\n                    ];\n\n                    // open\n                    if (point.open !== null) {\n                        plotOpen = mathRound(point.plotOpen) + crispCorr;\n                        path.push(\n                            'M',\n                            crispX,\n                            plotOpen,\n                            'L',\n                            crispX - halfWidth,\n                            plotOpen\n                        );\n                    }\n\n                    // close\n                    if (point.close !== null) {\n                        plotClose = mathRound(point.plotClose) + crispCorr;\n                        path.push(\n                            'M',\n                            crispX,\n                            plotClose,\n                            'L',\n                            crispX + halfWidth,\n                            plotClose\n                        );\n                    }\n\n                    // create and/or update the graphic\n                    if (graphic) {\n                        graphic\n                            .attr(pointAttr) // #3897\n                            .animate({ d: path });\n                    } else {\n                        point.graphic = chart.renderer.path(path)\n                            .attr(pointAttr)\n                            .add(series.group);\n                    }\n\n                }\n\n\n            });\n\n        },\n\n        /**\n         * Disable animation\n         */\n        animate: null\n\n\n    });\n    seriesTypes.ohlc = OHLCSeries;\n    /* ****************************************************************************\n     * End OHLC series code                                                       *\n     *****************************************************************************/\n    /* ****************************************************************************\n     * Start Candlestick series code                                              *\n     *****************************************************************************/\n\n    // 1 - set default options\n    defaultPlotOptions.candlestick = merge(defaultPlotOptions.column, {\n        lineColor: 'black',\n        lineWidth: 1,\n        states: {\n            hover: {\n                lineWidth: 2\n            }\n        },\n        tooltip: defaultPlotOptions.ohlc.tooltip,\n        threshold: null,\n        upColor: 'white'\n        // upLineColor: null\n    });\n\n    // 2 - Create the CandlestickSeries object\n    var CandlestickSeries = extendClass(OHLCSeries, {\n        type: 'candlestick',\n\n        /**\n         * One-to-one mapping from options to SVG attributes\n         */\n        pointAttrToOptions: { // mapping between SVG attributes and the corresponding options\n            fill: 'color',\n            stroke: 'lineColor',\n            'stroke-width': 'lineWidth'\n        },\n        upColorProp: 'fill',\n\n        /**\n         * Postprocess mapping between options and SVG attributes\n         */\n        getAttribs: function () {\n            seriesTypes.ohlc.prototype.getAttribs.apply(this, arguments);\n            var series = this,\n                options = series.options,\n                stateOptions = options.states,\n                upLineColor = options.upLineColor || options.lineColor,\n                hoverStroke = stateOptions.hover.upLineColor || upLineColor,\n                selectStroke = stateOptions.select.upLineColor || upLineColor;\n\n            // Add custom line color for points going up (close > open).\n            // Fill is handled by OHLCSeries' getAttribs.\n            each(series.points, function (point) {\n                if (point.open < point.close) {\n\n                    // If an individual line color is set, we need to merge the\n                    // point attributes, because they are shared between all up\n                    // points by inheritance from OHCLSeries.\n                    if (point.lineColor) {\n                        point.pointAttr = merge(point.pointAttr);\n                        upLineColor = point.lineColor;\n                    }\n\n                    point.pointAttr[''].stroke = upLineColor;\n                    point.pointAttr.hover.stroke = hoverStroke;\n                    point.pointAttr.select.stroke = selectStroke;\n                }\n            });\n        },\n\n        /**\n         * Draw the data points\n         */\n        drawPoints: function () {\n            var series = this,  //state = series.state,\n                points = series.points,\n                chart = series.chart,\n                pointAttr,\n                seriesPointAttr = series.pointAttr[''],\n                plotOpen,\n                plotClose,\n                topBox,\n                bottomBox,\n                hasTopWhisker,\n                hasBottomWhisker,\n                crispCorr,\n                crispX,\n                graphic,\n                path,\n                halfWidth;\n\n\n            each(points, function (point) {\n\n                graphic = point.graphic;\n                if (point.plotY !== UNDEFINED) {\n\n                    pointAttr = point.pointAttr[point.selected ? 'selected' : ''] || seriesPointAttr;\n\n                    // crisp vector coordinates\n                    crispCorr = (pointAttr['stroke-width'] % 2) / 2;\n                    crispX = mathRound(point.plotX) - crispCorr; // #2596\n                    plotOpen = point.plotOpen;\n                    plotClose = point.plotClose;\n                    topBox = math.min(plotOpen, plotClose);\n                    bottomBox = math.max(plotOpen, plotClose);\n                    halfWidth = mathRound(point.shapeArgs.width / 2);\n                    hasTopWhisker = mathRound(topBox) !== mathRound(point.plotY);\n                    hasBottomWhisker = bottomBox !== point.yBottom;\n                    topBox = mathRound(topBox) + crispCorr;\n                    bottomBox = mathRound(bottomBox) + crispCorr;\n\n                    // Create the path. Due to a bug in Chrome 49, the path is first instanciated\n                    // with no values, then the values pushed. For unknown reasons, instanciated\n                    // the path array with all the values would lead to a crash when updating\n                    // frequently (#5193).\n                    path = [];\n                    path.push(\n                        'M',\n                        crispX - halfWidth, bottomBox,\n                        'L',\n                        crispX - halfWidth, topBox,\n                        'L',\n                        crispX + halfWidth, topBox,\n                        'L',\n                        crispX + halfWidth, bottomBox,\n                        'Z', // Use a close statement to ensure a nice rectangle #2602\n                        'M',\n                        crispX, topBox,\n                        'L',\n                        crispX, hasTopWhisker ? mathRound(point.plotY) : topBox, // #460, #2094\n                        'M',\n                        crispX, bottomBox,\n                        'L',\n                        crispX, hasBottomWhisker ? mathRound(point.yBottom) : bottomBox // #460, #2094\n                    );\n\n                    if (graphic) {\n                        graphic\n                            .attr(pointAttr) // #3897\n                            .animate({ d: path });\n                    } else {\n                        point.graphic = chart.renderer.path(path)\n                            .attr(pointAttr)\n                            .add(series.group)\n                            .shadow(series.options.shadow);\n                    }\n\n                }\n            });\n\n        }\n\n\n    });\n\n    seriesTypes.candlestick = CandlestickSeries;\n\n    /* ****************************************************************************\n     * End Candlestick series code                                                *\n     *****************************************************************************/\n    /* ****************************************************************************\n     * Start Flags series code                                                    *\n     *****************************************************************************/\n\n    var symbols = SVGRenderer.prototype.symbols;\n\n    // 1 - set default options\n    defaultPlotOptions.flags = merge(defaultPlotOptions.column, {\n        fillColor: 'white',\n        lineWidth: 1,\n        pointRange: 0, // #673\n        //radius: 2,\n        shape: 'flag',\n        stackDistance: 12,\n        states: {\n            hover: {\n                lineColor: 'black',\n                fillColor: '#FCFFC5'\n            }\n        },\n        style: {\n            fontSize: '11px',\n            fontWeight: 'bold',\n            textAlign: 'center'\n        },\n        tooltip: {\n            pointFormat: '{point.text}<br/>'\n        },\n        threshold: null,\n        y: -30\n    });\n\n    // 2 - Create the CandlestickSeries object\n    seriesTypes.flags = extendClass(seriesTypes.column, {\n        type: 'flags',\n        sorted: false,\n        noSharedTooltip: true,\n        allowDG: false,\n        takeOrdinalPosition: false, // #1074\n        trackerGroups: ['markerGroup'],\n        forceCrop: true,\n        /**\n         * Inherit the initialization from base Series\n         */\n        init: Series.prototype.init,\n\n        /**\n         * One-to-one mapping from options to SVG attributes\n         */\n        pointAttrToOptions: { // mapping between SVG attributes and the corresponding options\n            fill: 'fillColor',\n            stroke: 'color',\n            'stroke-width': 'lineWidth',\n            r: 'radius'\n        },\n\n        /**\n         * Extend the translate method by placing the point on the related series\n         */\n        translate: function () {\n\n            seriesTypes.column.prototype.translate.apply(this);\n\n            var series = this,\n                options = series.options,\n                chart = series.chart,\n                points = series.points,\n                cursor = points.length - 1,\n                point,\n                lastPoint,\n                optionsOnSeries = options.onSeries,\n                onSeries = optionsOnSeries && chart.get(optionsOnSeries),\n                onKey = options.onKey || 'y',\n                step = onSeries && onSeries.options.step,\n                onData = onSeries && onSeries.points,\n                i = onData && onData.length,\n                xAxis = series.xAxis,\n                xAxisExt = xAxis.getExtremes(),\n                xOffset = 0,\n                leftPoint,\n                lastX,\n                rightPoint,\n                currentDataGrouping;\n\n            // relate to a master series\n            if (onSeries && onSeries.visible && i) {\n                xOffset = (onSeries.pointXOffset || 0) + (onSeries.barW || 0) / 2;\n                currentDataGrouping = onSeries.currentDataGrouping;\n                lastX = onData[i - 1].x + (currentDataGrouping ? currentDataGrouping.totalRange : 0); // #2374\n\n                // sort the data points\n                points.sort(function (a, b) {\n                    return (a.x - b.x);\n                });\n\n                onKey = 'plot' + onKey[0].toUpperCase() + onKey.substr(1);\n                while (i-- && points[cursor]) {\n                    point = points[cursor];\n                    leftPoint = onData[i];\n                    if (leftPoint.x <= point.x && leftPoint[onKey] !== undefined) {\n                        if (point.x <= lastX) { // #803\n\n                            point.plotY = leftPoint[onKey];\n\n                            // interpolate between points, #666\n                            if (leftPoint.x < point.x && !step) {\n                                rightPoint = onData[i + 1];\n                                if (rightPoint && rightPoint[onKey] !== UNDEFINED) {\n                                    point.plotY +=\n                                        ((point.x - leftPoint.x) / (rightPoint.x - leftPoint.x)) * // the distance ratio, between 0 and 1\n                                        (rightPoint[onKey] - leftPoint[onKey]); // the y distance\n                                }\n                            }\n                        }\n                        cursor--;\n                        i++; // check again for points in the same x position\n                        if (cursor < 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            // Add plotY position and handle stacking\n            each(points, function (point, i) {\n\n                var stackIndex;\n\n                // Undefined plotY means the point is either on axis, outside series range or hidden series.\n                // If the series is outside the range of the x axis it should fall through with\n                // an undefined plotY, but then we must remove the shapeArgs (#847).\n                if (point.plotY === UNDEFINED) {\n                    if (point.x >= xAxisExt.min && point.x <= xAxisExt.max) { // we're inside xAxis range\n                        point.plotY = chart.chartHeight - xAxis.bottom - (xAxis.opposite ? xAxis.height : 0) + xAxis.offset - chart.plotTop;\n                    } else {\n                        point.shapeArgs = {}; // 847\n                    }\n                }\n                point.plotX += xOffset; // #2049\n                // if multiple flags appear at the same x, order them into a stack\n                lastPoint = points[i - 1];\n                if (lastPoint && lastPoint.plotX === point.plotX) {\n                    if (lastPoint.stackIndex === UNDEFINED) {\n                        lastPoint.stackIndex = 0;\n                    }\n                    stackIndex = lastPoint.stackIndex + 1;\n                }\n                point.stackIndex = stackIndex; // #3639\n            });\n\n\n        },\n\n        /**\n         * Draw the markers\n         */\n        drawPoints: function () {\n            var series = this,\n                pointAttr,\n                seriesPointAttr = series.pointAttr[''],\n                points = series.points,\n                chart = series.chart,\n                renderer = chart.renderer,\n                plotX,\n                plotY,\n                options = series.options,\n                optionsY = options.y,\n                shape,\n                i,\n                point,\n                graphic,\n                stackIndex,\n                anchorX,\n                anchorY,\n                outsideRight,\n                yAxis = series.yAxis,\n                text;\n\n            i = points.length;\n            while (i--) {\n                point = points[i];\n                outsideRight = point.plotX > series.xAxis.len;\n                plotX = point.plotX;\n                if (plotX > 0) { // #3119\n                    plotX -= pick(point.lineWidth, options.lineWidth) % 2; // #4285\n                }\n                stackIndex = point.stackIndex;\n                shape = point.options.shape || options.shape;\n                plotY = point.plotY;\n                if (plotY !== UNDEFINED) {\n                    plotY = point.plotY + optionsY - (stackIndex !== UNDEFINED && stackIndex * options.stackDistance);\n                }\n                anchorX = stackIndex ? UNDEFINED : point.plotX; // skip connectors for higher level stacked points\n                anchorY = stackIndex ? UNDEFINED : point.plotY;\n\n                graphic = point.graphic;\n\n                    \n                // only draw the point if y is defined and the flag is within the visible area\n                if (plotY !== UNDEFINED && plotX >= 0 && !outsideRight) {\n                    // shortcuts\n                    pointAttr = point.pointAttr[point.selected ? 'select' : ''] || seriesPointAttr;\n                    text = pick(point.options.title, options.title, 'A');\n                    if (graphic) { // update\n                        graphic.attr({\n                            text: text // first apply text, so text will be centered later\n                        }).attr({\n                            x: plotX,\n                            y: plotY,\n                            r: pointAttr.r,\n                            anchorX: anchorX,\n                            anchorY: anchorY\n                        });\n                    } else {\n                        graphic = point.graphic = renderer.label(\n                            text, \n                            plotX,\n                            plotY,\n                            shape,\n                            anchorX,\n                            anchorY,\n                            options.useHTML\n                        )\n                        .css(merge(options.style, point.style))\n                        .attr(pointAttr)\n                        .attr({\n                            align: shape === 'flag' ? 'left' : 'center',\n                            width: options.width,\n                            height: options.height\n                        })\n                        .add(series.markerGroup)\n                        .shadow(options.shadow);\n\n                    }\n\n                    // Set the tooltip anchor position\n                    point.tooltipPos = chart.inverted ? [yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - plotX] : [plotX, plotY];\n\n                } else if (graphic) {\n                    point.graphic = graphic.destroy();\n                }\n\n            }\n\n        },\n\n        /**\n         * Extend the column trackers with listeners to expand and contract stacks\n         */\n        drawTracker: function () {\n            var series = this,\n                points = series.points;\n\n            TrackerMixin.drawTrackerPoint.apply(this);\n\n            // Bring each stacked flag up on mouse over, this allows readability of vertically\n            // stacked elements as well as tight points on the x axis. #1924.\n            each(points, function (point) {\n                var graphic = point.graphic;\n                if (graphic) {\n                    addEvent(graphic.element, 'mouseover', function () {\n\n                        // Raise this point\n                        if (point.stackIndex > 0 && !point.raised) {\n                            point._y = graphic.y;\n                            graphic.attr({\n                                y: point._y - 8\n                            });\n                            point.raised = true;\n                        }\n\n                        // Revert other raised points\n                        each(points, function (otherPoint) {\n                            if (otherPoint !== point && otherPoint.raised && otherPoint.graphic) {\n                                otherPoint.graphic.attr({\n                                    y: otherPoint._y\n                                });\n                                otherPoint.raised = false;\n                            }\n                        });\n                    });\n                }\n            });\n        },\n\n        /**\n         * Disable animation\n         */\n        animate: noop,\n        buildKDTree: noop,\n        setClip: noop\n\n    });\n\n    // create the flag icon with anchor\n    symbols.flag = function (x, y, w, h, options) {\n        var anchorX = (options && options.anchorX) || x,\n            anchorY = (options &&  options.anchorY) || y;\n\n        return [\n            'M', anchorX, anchorY,\n            'L', x, y + h,\n            x, y,\n            x + w, y,\n            x + w, y + h,\n            x, y + h,\n            'Z'\n        ];\n    };\n\n    // create the circlepin and squarepin icons with anchor\n    each(['circle', 'square'], function (shape) {\n        symbols[shape + 'pin'] = function (x, y, w, h, options) {\n\n            var anchorX = options && options.anchorX,\n                anchorY = options &&  options.anchorY,\n                path,\n                labelTopOrBottomY;\n\n            // For single-letter flags, make sure circular flags are not taller than their width\n            if (shape === 'circle' && h > w) {\n                x -= mathRound((h - w) / 2);\n                w = h;\n            }\n\n            path = symbols[shape](x, y, w, h);\n\n            if (anchorX && anchorY) {\n                // if the label is below the anchor, draw the connecting line from the top edge of the label\n                // otherwise start drawing from the bottom edge\n                labelTopOrBottomY = (y > anchorY) ? y : y + h;\n                path.push('M', anchorX, labelTopOrBottomY, 'L', anchorX, anchorY);\n            }\n\n            return path;\n        };\n    });\n\n    // The symbol callbacks are generated on the SVGRenderer object in all browsers. Even\n    // VML browsers need this in order to generate shapes in export. Now share\n    // them with the VMLRenderer.\n    if (Renderer === Highcharts.VMLRenderer) {\n        each(['flag', 'circlepin', 'squarepin'], function (shape) {\n            VMLRenderer.prototype.symbols[shape] = symbols[shape];\n        });\n    }\n\n    /* ****************************************************************************\n     * End Flags series code                                                      *\n     *****************************************************************************/\n\n    var defaultScrollbarOptions =  {\n        //enabled: true\n        height: isTouchDevice ? 20 : 14,\n        barBackgroundColor: '#bfc8d1',\n        barBorderRadius: 0,\n        barBorderWidth: 1,\n        barBorderColor: '#bfc8d1',\n        buttonArrowColor: '#666',\n        buttonBackgroundColor: '#ebe7e8',\n        buttonBorderColor: '#bbb',\n        buttonBorderRadius: 0,\n        buttonBorderWidth: 1,\n        //showFull: true,\n        margin: 10,\n        minWidth: 6,\n        rifleColor: '#666',\n        zIndex: 3,\n        step: 0.2,\n        //size: null,\n        trackBackgroundColor: '#eeeeee',\n        trackBorderColor: '#eeeeee',\n        trackBorderWidth: 1,\n        // trackBorderRadius: 0\n        liveRedraw: hasSVG && !isTouchDevice\n    };\n\n    defaultOptions.scrollbar = merge(true, defaultScrollbarOptions, defaultOptions.scrollbar);\n\n    /**\n     * The Scrollbar class \n     * @param {Object} renderer\n     * @param {Object} options\n     * @param {Object} chart\n     */\n    function Scrollbar(renderer, options, chart) {\n        this.scrollbarButtons = [];\n\n        this.renderer = renderer;\n\n        this.userOptions = options;\n        this.options = merge(defaultScrollbarOptions, options);\n\n        this.chart = chart;\n\n        this.size = pick(this.options.size, this.options.height); // backward compatibility\n\n        // Init\n        this.render();\n        this.initEvents();\n        this.addEvents();\n    }\n\n    Scrollbar.prototype = {\n        /**\n        * Render scrollbar with all required items.\n        */\n        render: function () {\n            var scroller = this,\n                renderer = scroller.renderer,\n                options = scroller.options,\n                strokeWidth = options.trackBorderWidth,\n                scrollbarStrokeWidth = options.barBorderWidth,\n                size = scroller.size,\n                group;\n\n            // Draw the scrollbar group:\n            scroller.group = group = renderer.g(PREFIX + 'scrollbar').attr({\n                zIndex: options.zIndex,\n                translateY: -99999\n            }).add();\n\n            // Draw the scrollbar track:\n            scroller.track = renderer.rect().attr({\n                height: size,\n                width: size,\n                y: -strokeWidth % 2 / 2,\n                x: -strokeWidth % 2 / 2,\n                'stroke-width': strokeWidth,\n                fill: options.trackBackgroundColor,\n                stroke: options.trackBorderColor,\n                r: options.trackBorderRadius || 0\n            }).add(group);\n\n            // Draw the scrollbar itself:\n            scroller.scrollbarGroup = renderer.g().add(group);\n\n            scroller.scrollbar = renderer.rect().attr({\n                height: size,\n                width: size,\n                y: -scrollbarStrokeWidth % 2 / 2,\n                x: -scrollbarStrokeWidth % 2 / 2,\n                'stroke-width': scrollbarStrokeWidth,\n                fill: options.barBackgroundColor,\n                stroke: options.barBorderColor,\n                r: options.barBorderRadius || 0\n            }).add(scroller.scrollbarGroup);\n\n            // Draw the scrollbat rifles:\n            scroller.scrollbarRifles = renderer.path(scroller.swapXY([\n                M,\n                -3, size / 4,\n                L,\n                -3, 2 * size / 3,\n                M,\n                0, size / 4,\n                L,\n                0, 2 * size / 3,\n                M,\n                3, size / 4,\n                L,\n                3, 2 * size / 3\n            ], options.vertical)).attr({\n                stroke: options.rifleColor,\n                'stroke-width': 1\n            }).add(scroller.scrollbarGroup);\n\n            // Draw the buttons:\n            scroller.drawScrollbarButton(0);\n            scroller.drawScrollbarButton(1);\n        },\n\n        /**\n         * Position the scrollbar, method called from a parent with defined dimensions\n         * @param {Number} x - x-position on the chart\n         * @param {Number} y - y-position on the chart\n         * @param {Number} width - width of the scrollbar\n         * @param {Number} height - height of the scorllbar\n         */\n        position: function (x, y, width, height) {\n            var scroller = this,\n                options = scroller.options,\n                vertical = options.vertical,\n                xOffset = height,\n                yOffset = 0,\n                method = scroller.rendered ? 'animate' : 'attr';\n\n            scroller.x = x;\n            scroller.y = y + options.trackBorderWidth;\n            scroller.width = width; // width with buttons\n            scroller.height = height;\n            scroller.xOffset = xOffset;\n            scroller.yOffset = yOffset;\n\n            // If Scrollbar is a vertical type, swap options:\n            if (vertical) {\n                scroller.width = scroller.yOffset = width = yOffset = scroller.size;\n                scroller.xOffset = xOffset = 0;\n                scroller.barWidth = height - width * 2; // width without buttons\n                scroller.x = x = x + scroller.options.margin;\n            } else {\n                scroller.height = scroller.xOffset = height = xOffset = scroller.size;\n                scroller.barWidth = width - height * 2; // width without buttons\n                scroller.y = scroller.y + scroller.options.margin;\n            }\n\n            // Set general position for a group:\n            scroller.group[method]({\n                translateX: x,\n                translateY: scroller.y\n            });\n\n            // Resize background/track:\n            scroller.track[method]({\n                width: width,\n                height: height\n            });\n\n            // Move right/bottom button ot it's place:\n            scroller.scrollbarButtons[1].attr({\n                translateX: vertical ? 0 : width - xOffset,\n                translateY: vertical ? height - yOffset : 0\n            });\n        },\n\n        /**\n         * Draw the scrollbar buttons with arrows\n         * @param {Number} index 0 is left, 1 is right\n         */\n        drawScrollbarButton: function (index) {\n            var scroller = this,\n                renderer = scroller.renderer,\n                scrollbarButtons = scroller.scrollbarButtons,\n                options = scroller.options,\n                size = scroller.size,\n                group;\n\n            group = renderer.g().add(scroller.group);\n            scrollbarButtons.push(group);\n\n            // Button rect:\n            renderer.rect(\n                -0.5, \n                -0.5, \n                size + 1,  // +1 to compensate for crispifying in rect method\n                size + 1,\n                options.buttonBorderRadius,\n                options.buttonBorderWidth\n            ).attr({\n                stroke: options.buttonBorderColor,\n                'stroke-width': options.buttonBorderWidth,\n                fill: options.buttonBackgroundColor\n            }).add(group);\n\n            // Button arrow:\n            renderer.path(scroller.swapXY([\n                'M',\n                size / 2 + (index ? -1 : 1), \n                size / 2 - 3,\n                'L',\n                size / 2 + (index ? -1 : 1), \n                size / 2 + 3,\n                'L',\n                size / 2 + (index ? 2 : -2), \n                size / 2\n            ], options.vertical)).attr({\n                fill: options.buttonArrowColor\n            }).add(group);\n        },\n\n        /**\n        * When we have vertical scrollbar, rifles are rotated, the same for arrow in buttons:\n        * @param {Array} path - path to be rotated\n        * @param {Boolean} vertical - if vertical scrollbar, swap x-y values\n        */\n        swapXY: function (path, vertical) {\n            var i,\n                len = path.length,\n                temp;\n\n            if (vertical) {\n                for (i = 0; i < len; i += 3) {\n                    temp = path[i + 1];\n                    path[i + 1] = path[i + 2];\n                    path[i + 2] = temp;\n                }\n            }\n\n            return path;\n        },\n\n        /**\n        * Set scrollbar size, with a given scale.\n        * @param {Number} from - scale (0-1) where bar should start\n        * @param {Number} to - scale (0-1) where bar should end\n        */\n        setRange: function (from, to) {\n            var scroller = this,\n                options = scroller.options,\n                vertical = options.vertical,\n                minWidth = options.minWidth,\n                fullWidth = scroller.barWidth,\n                fromPX,\n                toPX,\n                newPos,\n                newSize,\n                newRiflesPos,\n                method = this.rendered && !this.hasDragged ? 'animate' : 'attr';\n\n            if (!defined(fullWidth)) {\n                return;\n            }\n\n            from = Math.max(from, 0);\n\n            fromPX = fullWidth * from;\n            toPX = fullWidth * Math.min(to, 1);\n            scroller.calculatedWidth = newSize = correctFloat(toPX - fromPX);\n\n            // We need to recalculate position, if minWidth is used\n            if (newSize < minWidth) {\n                fromPX = (fullWidth - minWidth + newSize) * from;\n                newSize = minWidth;\n            }\n            newPos = Math.floor(fromPX + scroller.xOffset + scroller.yOffset);\n            newRiflesPos = newSize / 2 - 0.5; // -0.5 -> rifle line width / 2\n\n            // Store current position:\n            scroller.from = from;\n            scroller.to = to;\n\n            if (!vertical) {\n                scroller.scrollbarGroup[method]({\n                    translateX: newPos\n                });\n                scroller.scrollbar[method]({\n                    width: newSize\n                });\n                scroller.scrollbarRifles[method]({\n                    translateX: newRiflesPos\n                });\n                scroller.scrollbarLeft = newPos;\n                scroller.scrollbarTop = 0;\n            } else {\n                scroller.scrollbarGroup[method]({\n                    translateY: newPos\n                });\n                scroller.scrollbar[method]({\n                    height: newSize\n                });\n                scroller.scrollbarRifles[method]({\n                    translateY: newRiflesPos\n                });\n                scroller.scrollbarTop = newPos;\n                scroller.scrollbarLeft = 0;\n            }\n\n            if (newSize <= 12) {\n                scroller.scrollbarRifles.hide();\n            } else {\n                scroller.scrollbarRifles.show(true);\n            }\n\n            // Show or hide the scrollbar based on the showFull setting\n            if (options.showFull === false) {\n                if (from <= 0 && to >= 1) {\n                    scroller.group.hide();\n                } else {\n                    scroller.group.show();\n                }\n            }\n\n            scroller.rendered = true;\n        },\n\n        /**\n        * Init events methods, so we have an access to the Scrollbar itself\n        */\n        initEvents: function () {\n            var scroller = this;\n            /**\n             * Event handler for the mouse move event.\n             */\n            scroller.mouseMoveHandler = function (e) {\n                var normalizedEvent = scroller.chart.pointer.normalize(e),\n                    options = scroller.options,\n                    direction = options.vertical ? 'chartY' : 'chartX',\n                    initPositions = scroller.initPositions,\n                    scrollPosition,\n                    chartPosition,\n                    change;\n\n                // In iOS, a mousemove event with e.pageX === 0 is fired when holding the finger\n                // down in the center of the scrollbar. This should be ignored.\n                if (scroller.grabbedCenter && (!e.touches || e.touches[0][direction] !== 0)) { // #4696, scrollbar failed on Android\n                    chartPosition = scroller.cursorToScrollbarPosition(normalizedEvent)[direction];\n                    scrollPosition = scroller[direction];\n\n                    change = chartPosition - scrollPosition;\n\n                    scroller.hasDragged = true;\n                    scroller.updatePosition(initPositions[0] + change, initPositions[1] + change);\n\n                    if (scroller.hasDragged) {\n                        fireEvent(scroller, 'changed', {\n                            from: scroller.from,\n                            to: scroller.to,\n                            trigger: 'scrollbar',\n                            DOMType: e.type,\n                            DOMEvent: e\n                        });\n                    }\n                }\n            };\n\n            /**\n             * Event handler for the mouse up event.\n             */\n            scroller.mouseUpHandler = function (e) {\n                if (scroller.hasDragged) {\n                    fireEvent(scroller, 'changed', {\n                        from: scroller.from,\n                        to: scroller.to,\n                        trigger: 'scrollbar',\n                        DOMType: e.type,\n                        DOMEvent: e\n                    });\n                }\n                scroller.grabbedCenter = scroller.hasDragged = scroller.chartX = scroller.chartY = null;\n            };\n\n            scroller.mouseDownHandler = function (e) {\n                var normalizedEvent = scroller.chart.pointer.normalize(e),\n                    mousePosition = scroller.cursorToScrollbarPosition(normalizedEvent);\n\n                scroller.chartX = mousePosition.chartX;\n                scroller.chartY = mousePosition.chartY;\n                scroller.initPositions = [scroller.from, scroller.to];\n\n                scroller.grabbedCenter = true;\n            };\n\n            scroller.buttonToMinClick = function (e) {\n                var range = correctFloat(scroller.to - scroller.from) * scroller.options.step;\n                scroller.updatePosition(correctFloat(scroller.from - range), correctFloat(scroller.to - range));\n                fireEvent(scroller, 'changed', {\n                    from: scroller.from,\n                    to: scroller.to,\n                    trigger: 'scrollbar',\n                    DOMEvent: e\n                });\n            };\n\n            scroller.buttonToMaxClick = function (e) {\n                var range = (scroller.to - scroller.from) * scroller.options.step;\n                scroller.updatePosition(scroller.from + range, scroller.to + range);\n                fireEvent(scroller, 'changed', {\n                    from: scroller.from,\n                    to: scroller.to,\n                    trigger: 'scrollbar',\n                    DOMEvent: e\n                });\n            };\n\n            scroller.trackClick = function (e) {\n                var normalizedEvent = scroller.chart.pointer.normalize(e),\n                    range = scroller.to - scroller.from,\n                    top = scroller.y + scroller.scrollbarTop,\n                    left = scroller.x + scroller.scrollbarLeft;\n\n                if ((scroller.options.vertical && normalizedEvent.chartY > top) || \n                    (!scroller.options.vertical && normalizedEvent.chartX > left)) {\n                    // On the top or on the left side of the track:\n                    scroller.updatePosition(scroller.from + range, scroller.to + range);\n                } else {\n                    // On the bottom or the right side of the track:\n                    scroller.updatePosition(scroller.from - range, scroller.to - range);\n                }\n\n                fireEvent(scroller, 'changed', {\n                    from: scroller.from,\n                    to: scroller.to,\n                    trigger: 'scrollbar',\n                    DOMEvent: e\n                });\n            };\n        },\n\n        /**\n         * Get normalized (0-1) cursor position over the scrollbar\n         * @param {Event} normalizedEvent - normalized event, with chartX and chartY values\n         * @return {Object} Local position {chartX, chartY}\n         */\n        cursorToScrollbarPosition: function (normalizedEvent) {\n            var scroller = this,\n                options = scroller.options,\n                minWidthDifference = options.minWidth > scroller.calculatedWidth ? options.minWidth : 0; // minWidth distorts translation\n\n            return {\n                chartX: (normalizedEvent.chartX - scroller.x - scroller.xOffset) / (scroller.barWidth - minWidthDifference),\n                chartY: (normalizedEvent.chartY - scroller.y - scroller.yOffset) / (scroller.barWidth - minWidthDifference)\n            };\n        },\n\n        /**\n        * Update position option in the Scrollbar, with normalized 0-1 scale\n        */\n        updatePosition: function (from, to) {\n            if (to > 1) {\n                from = correctFloat(1 - correctFloat(to - from));\n                to = 1;\n            }\n\n            if (from < 0) {\n                to = correctFloat(to - from);\n                from = 0;\n            }\n\n            this.from = from;\n            this.to = to;\n        },\n\n        /**\n         * Set up the mouse and touch events for the Scrollbar\n         */\n        addEvents: function () {\n            var buttonsOrder = this.options.inverted ? [1, 0] : [0, 1],\n                buttons = this.scrollbarButtons,\n                bar = this.scrollbarGroup.element,\n                track = this.track.element,\n                mouseDownHandler = this.mouseDownHandler,\n                mouseMoveHandler = this.mouseMoveHandler,\n                mouseUpHandler = this.mouseUpHandler,\n                _events;\n\n            // Mouse events\n            _events = [\n                [buttons[buttonsOrder[0]].element, 'click', this.buttonToMinClick],\n                [buttons[buttonsOrder[1]].element, 'click', this.buttonToMaxClick],\n                [track, 'click', this.trackClick],\n                [bar, 'mousedown', mouseDownHandler],\n                [doc, 'mousemove', mouseMoveHandler],\n                [doc, 'mouseup', mouseUpHandler]\n            ];\n\n            // Touch events\n            if (hasTouch) {\n                _events.push(\n                    [bar, 'touchstart', mouseDownHandler],\n                    [doc, 'touchmove', mouseMoveHandler],\n                    [doc, 'touchend', mouseUpHandler]\n                );\n            }\n\n            // Add them all\n            each(_events, function (args) {\n                addEvent.apply(null, args);\n            });\n            this._events = _events;\n        },\n\n        /**\n         * Removes the event handlers attached previously with addEvents.\n         */\n        removeEvents: function () {\n            each(this._events, function (args) {\n                removeEvent.apply(null, args);\n            });\n            this._events = UNDEFINED;\n        },\n\n        /**\n         * Destroys allocated elements.\n         */\n        destroy: function () {\n            var scroller = this;\n\n            // Disconnect events added in addEvents\n            scroller.removeEvents();\n\n            // Destroy properties\n            each([scroller.track, scroller.scrollbarRifles, scroller.scrollbar, scroller.scrollbarGroup, scroller.group], function (prop) {\n                if (prop && prop.destroy) {\n                    prop = prop.destroy();\n                }\n            });\n\n            // Destroy elements in collection\n            destroyObjectProperties(scroller.scrollbarButtons);\n        }\n    };\n\n    /**\n    * Wrap axis initialization and create scrollbar if enabled:\n    */\n    wrap(Axis.prototype, 'init', function (proceed) {\n        var axis = this;\n        proceed.apply(axis, [].slice.call(arguments, 1));\n\n        if (axis.options.scrollbar && axis.options.scrollbar.enabled) {\n            // Predefined options:\n            axis.options.scrollbar.vertical = !axis.horiz;\n            axis.options.startOnTick = axis.options.endOnTick = false;\n\n            axis.scrollbar = new Scrollbar(axis.chart.renderer, axis.options.scrollbar, axis.chart);\n\n            addEvent(axis.scrollbar, 'changed', function (e) {\n                var unitedMin = Math.min(pick(axis.options.min, axis.min), axis.min, axis.dataMin),\n                    unitedMax = Math.max(pick(axis.options.max, axis.max), axis.max, axis.dataMax),\n                    range = unitedMax - unitedMin,\n                    to,\n                    from;\n\n                if ((axis.horiz && !axis.reversed) || (!axis.horiz && axis.reversed)) {\n                    to = unitedMin + range * this.to;\n                    from = unitedMin + range * this.from;\n                } else {\n                    // y-values in browser are reversed, but this also applies for reversed horizontal axis:\n                    to = unitedMin + range * (1 - this.from);\n                    from = unitedMin + range * (1 - this.to);\n                }\n\n                axis.setExtremes(from, to, true, false, e);\n            });\n        }\n    });\n\n    /**\n    * Wrap rendering axis, and update scrollbar if one is created:\n    */\n    wrap(Axis.prototype, 'render', function (proceed) {\n        var axis = this,    \n            scrollMin = Math.min(pick(axis.options.min, axis.min), axis.min, axis.dataMin),\n            scrollMax = Math.max(pick(axis.options.max, axis.max), axis.max, axis.dataMax),\n            scrollbar = axis.scrollbar,\n            from,\n            to;\n\n        proceed.apply(axis, [].slice.call(arguments, 1));\n\n        if (scrollbar) {\n            if (axis.horiz) {\n                scrollbar.position(\n                    axis.left, \n                    axis.top + axis.height + axis.offset + 2 + (axis.opposite ? 0 : axis.axisTitleMargin),\n                    axis.width,\n                    axis.height\n                );\n            } else {\n                scrollbar.position(\n                    axis.left + axis.width + 2 + axis.offset + (axis.opposite ? axis.axisTitleMargin : 0), \n                    axis.top, \n                    axis.width, \n                    axis.height\n                );\n            }\n\n            if (isNaN(scrollMin) || isNaN(scrollMax) || !defined(axis.min) || !defined(axis.max)) {\n                scrollbar.setRange(0, 0); // default action: when there is not extremes on the axis, but scrollbar exists, make it full size\n            } else {\n                from = (axis.min - scrollMin) / (scrollMax - scrollMin);\n                to = (axis.max - scrollMin) / (scrollMax - scrollMin);\n\n                if ((axis.horiz && !axis.reversed) || (!axis.horiz && axis.reversed)) {\n                    scrollbar.setRange(from, to);\n                } else {\n                    scrollbar.setRange(1 - to, 1 - from); // inverse vertical axis\n                }\n            }\n        }\n    });\n\n    /**\n    * Make space for a scrollbar\n    */\n    wrap(Axis.prototype, 'getOffset', function (proceed) {\n        var axis = this,\n            index = axis.horiz ? 2 : 1,\n            scrollbar = axis.scrollbar;\n\n        proceed.apply(axis, [].slice.call(arguments, 1));\n\n        if (scrollbar) {\n            axis.chart.axisOffset[index] += scrollbar.size + scrollbar.options.margin;\n        }\n    });\n\n    /**\n    * Destroy scrollbar when connected to the specific axis\n    */\n    wrap(Axis.prototype, 'destroy', function (proceed) {\n        if (this.scrollbar) {\n            this.scrollbar = this.scrollbar.destroy();\n        }\n\n        proceed.apply(this, [].slice.call(arguments, 1));\n    });\n\n    Highcharts.Scrollbar = Scrollbar;\n    /* ****************************************************************************\n     * Start Navigator code                                                        *\n     *****************************************************************************/\n    var units = [].concat(defaultDataGroupingUnits), // copy\n        defaultSeriesType,\n\n        // Finding the min or max of a set of variables where we don't know if they are defined,\n        // is a pattern that is repeated several places in Highcharts. Consider making this\n        // a global utility method.\n        numExt = function (extreme) {\n            var numbers = grep(arguments, isNumber);\n            if (numbers.length) {\n                return Math[extreme].apply(0, numbers);\n            }\n        };\n\n    // add more resolution to units\n    units[4] = ['day', [1, 2, 3, 4]]; // allow more days\n    units[5] = ['week', [1, 2, 3]]; // allow more weeks\n\n    defaultSeriesType = seriesTypes.areaspline === UNDEFINED ? 'line' : 'areaspline';\n\n    extend(defaultOptions, {\n        navigator: {\n            //enabled: true,\n            handles: {\n                backgroundColor: '#ebe7e8',\n                borderColor: '#b2b1b6'\n            },\n            height: 40,\n            margin: 25,\n            maskFill: 'rgba(128,179,236,0.3)',\n            maskInside: true,\n            outlineColor: '#b2b1b6',\n            outlineWidth: 1,\n            series: {\n                type: defaultSeriesType,\n                color: '#4572A7',\n                compare: null,\n                fillOpacity: 0.05,\n                dataGrouping: {\n                    approximation: 'average',\n                    enabled: true,\n                    groupPixelWidth: 2,\n                    smoothed: true,\n                    units: units\n                },\n                dataLabels: {\n                    enabled: false,\n                    zIndex: 2 // #1839\n                },\n                id: PREFIX + 'navigator-series',\n                lineColor: null, // Allow color setting while disallowing default candlestick setting (#4602)\n                lineWidth: 1,\n                marker: {\n                    enabled: false\n                },\n                pointRange: 0,\n                shadow: false,\n                threshold: null\n            },\n            //top: undefined,\n            xAxis: {\n                tickWidth: 0,\n                lineWidth: 0,\n                gridLineColor: '#EEE',\n                gridLineWidth: 1,\n                tickPixelInterval: 200,\n                labels: {\n                    align: 'left',\n                    style: {\n                        color: '#888'\n                    },\n                    x: 3,\n                    y: -4\n                },\n                crosshair: false\n            },\n            yAxis: {\n                gridLineWidth: 0,\n                startOnTick: false,\n                endOnTick: false,\n                minPadding: 0.1,\n                maxPadding: 0.1,\n                labels: {\n                    enabled: false\n                },\n                crosshair: false,\n                title: {\n                    text: null\n                },\n                tickWidth: 0\n            }\n        }\n    });\n\n    /**\n     * The Navigator class\n     * @param {Object} chart\n     */\n    function Navigator(chart) {\n        var chartOptions = chart.options,\n            navigatorOptions = chartOptions.navigator,\n            navigatorEnabled = navigatorOptions.enabled,\n            scrollbarOptions = chartOptions.scrollbar,\n            scrollbarEnabled = scrollbarOptions.enabled,\n            height = navigatorEnabled ? navigatorOptions.height : 0,\n            scrollbarHeight = scrollbarEnabled ? scrollbarOptions.height : 0;\n\n        this.handles = [];\n        this.elementsToDestroy = []; // Array containing the elements to destroy when Navigator is destroyed\n\n        this.chart = chart;\n        this.setBaseSeries();\n\n        this.height = height;\n        this.scrollbarHeight = scrollbarHeight;\n        this.scrollbarEnabled = scrollbarEnabled;\n        this.navigatorEnabled = navigatorEnabled;\n        this.navigatorOptions = navigatorOptions;\n        this.outlineHeight = height + scrollbarHeight;\n\n        // Run scroller\n        this.init();\n    }\n\n    Navigator.prototype = {\n        /**\n         * Draw one of the handles on the side of the zoomed range in the navigator\n         * @param {Number} x The x center for the handle\n         * @param {Number} index 0 for left and 1 for right\n         */\n        drawHandle: function (x, index) {\n            var scroller = this,\n                chart = scroller.chart,\n                renderer = chart.renderer,\n                elementsToDestroy = scroller.elementsToDestroy,\n                handles = scroller.handles,\n                handlesOptions = scroller.navigatorOptions.handles,\n                attr = {\n                    fill: handlesOptions.backgroundColor,\n                    stroke: handlesOptions.borderColor,\n                    'stroke-width': 1\n                },\n                tempElem;\n\n            // create the elements\n            if (!scroller.rendered) {\n                // the group\n                handles[index] = renderer.g('navigator-handle-' + ['left', 'right'][index])\n                    .css({ cursor: 'ew-resize' })\n                    .attr({ zIndex: 10 - index }) // zIndex = 3 for right handle, 4 for left / 10 - #2908\n                    .add();\n\n                // the rectangle\n                tempElem = renderer.rect(-4.5, 0, 9, 16, 0, 1)\n                    .attr(attr)\n                    .add(handles[index]);\n                elementsToDestroy.push(tempElem);\n\n                // the rifles\n                tempElem = renderer\n                    .path([\n                        'M',\n                        -1.5, 4,\n                        'L',\n                        -1.5, 12,\n                        'M',\n                        0.5, 4,\n                        'L',\n                        0.5, 12\n                    ]).attr(attr)\n                    .add(handles[index]);\n                elementsToDestroy.push(tempElem);\n            }\n\n            // Place it\n            handles[index][scroller.rendered && !scroller.hasDragged ? 'animate' : 'attr']({\n                translateX: scroller.scrollerLeft + scroller.scrollbarHeight + parseInt(x, 10),\n                translateY: scroller.top + scroller.height / 2 - 8\n            });\n        },\n\n        /**\n         * Render the navigator\n         * @param {Number} min X axis value minimum\n         * @param {Number} max X axis value maximum\n         * @param {Number} pxMin Pixel value minimum\n         * @param {Number} pxMax Pixel value maximum\n         */\n        render: function (min, max, pxMin, pxMax) {\n            var scroller = this,\n                chart = scroller.chart,\n                renderer = chart.renderer,\n                navigatorLeft,\n                navigatorWidth,\n                scrollerLeft,\n                scrollerWidth,\n                navigatorGroup = scroller.navigatorGroup,\n                scrollbarHeight = scroller.scrollbarHeight,\n                xAxis = scroller.xAxis,\n                navigatorOptions = scroller.navigatorOptions,\n                height = scroller.height,\n                top = scroller.top,\n                navigatorEnabled = scroller.navigatorEnabled,\n                outlineWidth = navigatorOptions.outlineWidth,\n                halfOutline = outlineWidth / 2,\n                zoomedMin,\n                zoomedMax,\n                outlineHeight = scroller.outlineHeight,\n                outlineTop = top + halfOutline,\n                rendered = scroller.rendered,\n                verb;\n\n            // Don't render the navigator until we have data (#486, #4202, #5172). Don't redraw while moving the handles (#4703).\n            if (!isNumber(min) || !isNumber(max) ||    (scroller.hasDragged && !defined(pxMin))) {\n                return;\n            }\n\n            scroller.navigatorLeft = navigatorLeft = pick(\n                xAxis.left,\n                chart.plotLeft + scrollbarHeight // in case of scrollbar only, without navigator\n            );\n            scroller.navigatorWidth = navigatorWidth = pick(xAxis.len, chart.plotWidth - 2 * scrollbarHeight);\n            scroller.scrollerLeft = scrollerLeft = navigatorLeft - scrollbarHeight;\n            scroller.scrollerWidth = scrollerWidth = scrollerWidth = navigatorWidth + 2 * scrollbarHeight;\n\n            // Get the pixel position of the handles\n            pxMin = pick(pxMin, xAxis.translate(min));\n            pxMax = pick(pxMax, xAxis.translate(max));\n            if (!isNumber(pxMin) || mathAbs(pxMin) === Infinity) { // Verify (#1851, #2238)\n                pxMin = 0;\n                pxMax = scrollerWidth;\n            }\n\n            // Are we below the minRange? (#2618)\n            if (xAxis.translate(pxMax, true) - xAxis.translate(pxMin, true) < chart.xAxis[0].minRange) {\n                return;\n            }\n\n\n            // handles are allowed to cross, but never exceed the plot area\n            scroller.zoomedMax = mathMin(mathMax(pxMin, pxMax, 0), navigatorWidth);\n            scroller.zoomedMin = mathMin(mathMax(scroller.fixedWidth ? scroller.zoomedMax - scroller.fixedWidth : mathMin(pxMin, pxMax), 0), navigatorWidth);\n            scroller.range = scroller.zoomedMax - scroller.zoomedMin;\n            zoomedMax = mathRound(scroller.zoomedMax);\n            zoomedMin = mathRound(scroller.zoomedMin);\n\n            if (!rendered) {\n\n                if (navigatorEnabled) {\n\n                    // draw the navigator group\n                    scroller.navigatorGroup = navigatorGroup = renderer.g('navigator')\n                        .attr({\n                            zIndex: 3\n                        })\n                        .add();\n\n                    scroller.leftShade = renderer.rect()\n                        .attr({\n                            fill: navigatorOptions.maskFill\n                        }).add(navigatorGroup);\n\n                    if (navigatorOptions.maskInside) {\n                        scroller.leftShade.css({ cursor: 'ew-resize' });\n                    } else {\n                        scroller.rightShade = renderer.rect()\n                            .attr({\n                                fill: navigatorOptions.maskFill\n                            }).add(navigatorGroup);\n                    }\n\n\n                    scroller.outline = renderer.path()\n                        .attr({\n                            'stroke-width': outlineWidth,\n                            stroke: navigatorOptions.outlineColor\n                        })\n                        .add(navigatorGroup);\n                }\n            }\n\n            // place elements\n            verb = rendered && !scroller.hasDragged ? 'animate' : 'attr';\n            if (navigatorEnabled) {\n                scroller.leftShade[verb](navigatorOptions.maskInside ? {\n                    x: navigatorLeft + zoomedMin,\n                    y: top,\n                    width: zoomedMax - zoomedMin,\n                    height: height\n                } : {\n                    x: navigatorLeft,\n                    y: top,\n                    width: zoomedMin,\n                    height: height\n                });\n                if (scroller.rightShade) {\n                    scroller.rightShade[verb]({\n                        x: navigatorLeft + zoomedMax,\n                        y: top,\n                        width: navigatorWidth - zoomedMax,\n                        height: height\n                    });\n                }\n\n                scroller.outline[verb]({ d: [\n                    M,\n                    scrollerLeft, outlineTop, // left\n                    L,\n                    navigatorLeft + zoomedMin - halfOutline, outlineTop, // upper left of zoomed range\n                    navigatorLeft + zoomedMin - halfOutline, outlineTop + outlineHeight, // lower left of z.r.\n                    L,\n                    navigatorLeft + zoomedMax - halfOutline, outlineTop + outlineHeight, // lower right of z.r.\n                    L,\n                    navigatorLeft + zoomedMax - halfOutline, outlineTop, // upper right of z.r.\n                    scrollerLeft + scrollerWidth, outlineTop // right\n                ].concat(navigatorOptions.maskInside ? [\n                    M,\n                    navigatorLeft + zoomedMin + halfOutline, outlineTop, // upper left of zoomed range\n                    L,\n                    navigatorLeft + zoomedMax - halfOutline, outlineTop // upper right of z.r.\n                ] : []) });\n                // draw handles\n                scroller.drawHandle(zoomedMin + halfOutline, 0);\n                scroller.drawHandle(zoomedMax + halfOutline, 1);\n            }\n\n            if (scroller.scrollbar) {\n\n                scroller.scrollbar.hasDragged = scroller.hasDragged;\n                \n                // Keep scale 0-1\n                scroller.scrollbar.position(\n                    scroller.scrollerLeft,\n                    scroller.top + (navigatorEnabled ? scroller.height : -scroller.scrollbarHeight),\n                    scroller.scrollerWidth,\n                    scroller.scrollbarHeight\n                );\n                scroller.scrollbar.setRange(\n                    zoomedMin / navigatorWidth,\n                    zoomedMax / navigatorWidth\n                );\n            }\n            scroller.rendered = true;\n        },\n\n        /**\n         * Set up the mouse and touch events for the navigator\n         */\n        addEvents: function () {\n            var chart = this.chart,\n                container = chart.container,\n                mouseDownHandler = this.mouseDownHandler,\n                mouseMoveHandler = this.mouseMoveHandler,\n                mouseUpHandler = this.mouseUpHandler,\n                _events;\n\n            // Mouse events\n            _events = [\n                [container, 'mousedown', mouseDownHandler],\n                [container, 'mousemove', mouseMoveHandler],\n                [doc, 'mouseup', mouseUpHandler]\n            ];\n\n            // Touch events\n            if (hasTouch) {\n                _events.push(\n                    [container, 'touchstart', mouseDownHandler],\n                    [container, 'touchmove', mouseMoveHandler],\n                    [doc, 'touchend', mouseUpHandler]\n                );\n            }\n\n            // Add them all\n            each(_events, function (args) {\n                addEvent.apply(null, args);\n            });\n            this._events = _events;\n\n            // Data events\n            if (this.series) {\n                addEvent(this.series.xAxis, 'foundExtremes', function () {\n                    chart.scroller.modifyNavigatorAxisExtremes();\n                });\n            }\n\n            addEvent(chart, 'redraw', function () {\n                // Move the scrollbar after redraw, like after data updata even if axes don't redraw\n                var scroller = this.scroller,\n                    xAxis = scroller && scroller.baseSeries && scroller.baseSeries.xAxis;\n            \n                if (xAxis) {\n                    scroller.render(xAxis.min, xAxis.max);\n                }\n            });\n        },\n\n        /**\n         * Removes the event handlers attached previously with addEvents.\n         */\n        removeEvents: function () {\n\n            each(this._events, function (args) {\n                removeEvent.apply(null, args);\n            });\n            this._events = UNDEFINED;\n            this.removeBaseSeriesEvents();\n        },\n\n        removeBaseSeriesEvents: function () {\n            if (this.navigatorEnabled && this.baseSeries && this.baseSeries.xAxis && this.navigatorOptions.adaptToUpdatedData !== false) {\n                removeEvent(this.baseSeries, 'updatedData', this.updatedDataHandler);\n                removeEvent(this.baseSeries.xAxis, 'foundExtremes', this.modifyBaseAxisExtremes);\n            }\n        },\n\n        /**\n         * Initiate the Navigator object\n         */\n        init: function () {\n            var scroller = this,\n                chart = scroller.chart,\n                xAxis,\n                yAxis,\n                scrollbarHeight = scroller.scrollbarHeight,\n                navigatorOptions = scroller.navigatorOptions,\n                height = scroller.height,\n                top = scroller.top,\n                dragOffset,\n                baseSeries = scroller.baseSeries;\n\n            /**\n             * Event handler for the mouse down event.\n             */\n            scroller.mouseDownHandler = function (e) {\n                e = chart.pointer.normalize(e);\n\n                var zoomedMin = scroller.zoomedMin,\n                    zoomedMax = scroller.zoomedMax,\n                    top = scroller.top,\n                    scrollerLeft = scroller.scrollerLeft,\n                    scrollerWidth = scroller.scrollerWidth,\n                    navigatorLeft = scroller.navigatorLeft,\n                    navigatorWidth = scroller.navigatorWidth,\n                    scrollbarPad = scroller.scrollbarPad || 0,\n                    range = scroller.range,\n                    chartX = e.chartX,\n                    chartY = e.chartY,\n                    baseXAxis = chart.xAxis[0],\n                    fixedMax,\n                    ext,\n                    handleSensitivity = isTouchDevice ? 10 : 7,\n                    left;\n\n                if (chartY > top && chartY < top + height) { // we're vertically inside the navigator\n\n                    // grab the left handle\n                    if (math.abs(chartX - zoomedMin - navigatorLeft) < handleSensitivity) {\n                        scroller.grabbedLeft = true;\n                        scroller.otherHandlePos = zoomedMax;\n                        scroller.fixedExtreme = baseXAxis.max;\n                        chart.fixedRange = null;\n\n                    // grab the right handle\n                    } else if (math.abs(chartX - zoomedMax - navigatorLeft) < handleSensitivity) {\n                        scroller.grabbedRight = true;\n                        scroller.otherHandlePos = zoomedMin;\n                        scroller.fixedExtreme = baseXAxis.min;\n                        chart.fixedRange = null;\n\n                    // grab the zoomed range\n                    } else if (chartX > navigatorLeft + zoomedMin - scrollbarPad && chartX < navigatorLeft + zoomedMax + scrollbarPad) {\n                        scroller.grabbedCenter = chartX;\n                        scroller.fixedWidth = range;\n\n                        dragOffset = chartX - zoomedMin;\n\n                    // shift the range by clicking on shaded areas\n                    } else if (chartX > scrollerLeft && chartX < scrollerLeft + scrollerWidth) {                \n                        left = chartX - navigatorLeft - range / 2;\n                        if (left < 0) {\n                            left = 0;\n                        } else if (left + range >= navigatorWidth) {\n                            left = navigatorWidth - range;\n                            fixedMax = scroller.getUnionExtremes().dataMax; // #2293, #3543\n                        }\n                        if (left !== zoomedMin) { // it has actually moved\n                            scroller.fixedWidth = range; // #1370\n\n                            ext = xAxis.toFixedRange(left, left + range, null, fixedMax);\n                            baseXAxis.setExtremes(\n                                ext.min,\n                                ext.max,\n                                true,\n                                null, // auto animation\n                                { trigger: 'navigator' }\n                            );\n                        }\n                    }\n\n                }\n            };\n\n            /**\n             * Event handler for the mouse move event.\n             */\n            scroller.mouseMoveHandler = function (e) {\n                var scrollbarHeight = scroller.scrollbarHeight,\n                    navigatorLeft = scroller.navigatorLeft,\n                    navigatorWidth = scroller.navigatorWidth,\n                    scrollerLeft = scroller.scrollerLeft,\n                    scrollerWidth = scroller.scrollerWidth,\n                    range = scroller.range,\n                    chartX;\n\n                // In iOS, a mousemove event with e.pageX === 0 is fired when holding the finger\n                // down in the center of the scrollbar. This should be ignored.\n                if (!e.touches || e.touches[0].pageX !== 0) { // #4696, scrollbar failed on Android\n\n                    e = chart.pointer.normalize(e);\n                    chartX = e.chartX;\n\n                    // validation for handle dragging\n                    if (chartX < navigatorLeft) {\n                        chartX = navigatorLeft;\n                    } else if (chartX > scrollerLeft + scrollerWidth - scrollbarHeight) {\n                        chartX = scrollerLeft + scrollerWidth - scrollbarHeight;\n                    }\n\n                    // drag left handle\n                    if (scroller.grabbedLeft) {\n                        scroller.hasDragged = true;\n                        scroller.render(0, 0, chartX - navigatorLeft, scroller.otherHandlePos);\n\n                    // drag right handle\n                    } else if (scroller.grabbedRight) {\n                        scroller.hasDragged = true;\n                        scroller.render(0, 0, scroller.otherHandlePos, chartX - navigatorLeft);\n\n                    // drag scrollbar or open area in navigator\n                    } else if (scroller.grabbedCenter) {\n\n                        scroller.hasDragged = true;\n                        if (chartX < dragOffset) { // outside left\n                            chartX = dragOffset;\n                        } else if (chartX > navigatorWidth + dragOffset - range) { // outside right\n                            chartX = navigatorWidth + dragOffset - range;\n                        }\n\n                        scroller.render(0, 0, chartX - dragOffset, chartX - dragOffset + range);\n                    }\n                    if (scroller.hasDragged && scroller.scrollbar && scroller.scrollbar.options.liveRedraw) {\n                        e.DOMType = e.type; // DOMType is for IE8 because it can't read type async\n                        setTimeout(function () {\n                            scroller.mouseUpHandler(e);\n                        }, 0);\n                    }\n                }\n            };\n\n            /**\n             * Event handler for the mouse up event.\n             */\n            scroller.mouseUpHandler = function (e) {\n                var ext,\n                    fixedMin,\n                    fixedMax,\n                    DOMEvent = e.DOMEvent || e;\n\n                if (scroller.hasDragged || e.trigger === 'scrollbar') {\n                    // When dragging one handle, make sure the other one doesn't change\n                    if (scroller.zoomedMin === scroller.otherHandlePos) {\n                        fixedMin = scroller.fixedExtreme;\n                    } else if (scroller.zoomedMax === scroller.otherHandlePos) {\n                        fixedMax = scroller.fixedExtreme;\n                    }\n\n                    // Snap to right edge (#4076)\n                    if (scroller.zoomedMax === scroller.navigatorWidth) {\n                        fixedMax = scroller.getUnionExtremes().dataMax;\n                    }\n\n                    ext = xAxis.toFixedRange(scroller.zoomedMin, scroller.zoomedMax, fixedMin, fixedMax);\n                    if (defined(ext.min)) {\n                        chart.xAxis[0].setExtremes(\n                            ext.min,\n                            ext.max,\n                            true,\n                            scroller.hasDragged ? false : null, // Run animation when clicking buttons, scrollbar track etc, but not when dragging handles or scrollbar\n                            {\n                                trigger: 'navigator',\n                                triggerOp: 'navigator-drag',\n                                DOMEvent: DOMEvent // #1838\n                            }\n                        );\n                    }\n                }\n\n                if (e.DOMType !== 'mousemove') {\n                    scroller.grabbedLeft = scroller.grabbedRight = scroller.grabbedCenter = scroller.fixedWidth =\n                        scroller.fixedExtreme = scroller.otherHandlePos = scroller.hasDragged = dragOffset = null;\n                }\n\n            };\n\n\n\n            var xAxisIndex = chart.xAxis.length,\n                yAxisIndex = chart.yAxis.length;\n\n            // make room below the chart\n            chart.extraBottomMargin = scroller.outlineHeight + navigatorOptions.margin;\n            \n\n            if (scroller.navigatorEnabled) {\n                // an x axis is required for scrollbar also\n                scroller.xAxis = xAxis = new Axis(chart, merge({\n                    // inherit base xAxis' break and ordinal options\n                    breaks: baseSeries && baseSeries.xAxis.options.breaks,\n                    ordinal: baseSeries && baseSeries.xAxis.options.ordinal\n                }, navigatorOptions.xAxis, {\n                    id: 'navigator-x-axis',\n                    isX: true,\n                    type: 'datetime',\n                    index: xAxisIndex,\n                    height: height,\n                    offset: 0,\n                    offsetLeft: scrollbarHeight,\n                    offsetRight: -scrollbarHeight,\n                    keepOrdinalPadding: true, // #2436\n                    startOnTick: false,\n                    endOnTick: false,\n                    minPadding: 0,\n                    maxPadding: 0,\n                    zoomEnabled: false\n                }));\n\n                scroller.yAxis = yAxis = new Axis(chart, merge(navigatorOptions.yAxis, {\n                    id: 'navigator-y-axis',\n                    alignTicks: false,\n                    height: height,\n                    offset: 0,\n                    index: yAxisIndex,\n                    zoomEnabled: false\n                }));\n\n                // If we have a base series, initialize the navigator series\n                if (baseSeries || navigatorOptions.series.data) {\n                    scroller.addBaseSeries();\n\n                // If not, set up an event to listen for added series\n                } else if (chart.series.length === 0) {\n\n                    wrap(chart, 'redraw', function (proceed, animation) {\n                        // We've got one, now add it as base and reset chart.redraw\n                        if (chart.series.length > 0 && !scroller.series) {\n                            scroller.setBaseSeries();\n                            chart.redraw = proceed; // reset\n                        }\n                        proceed.call(chart, animation);\n                    });\n                }\n\n            // in case of scrollbar only, fake an x axis to get translation\n            } else {\n                scroller.xAxis = xAxis = {\n                    translate: function (value, reverse) {\n                        var axis = chart.xAxis[0],\n                            ext = axis.getExtremes(),\n                            scrollTrackWidth = chart.plotWidth - 2 * scrollbarHeight,\n                            min = numExt('min', axis.options.min, ext.dataMin),\n                            valueRange = numExt('max', axis.options.max, ext.dataMax) - min;\n\n                        return reverse ?\n                            // from pixel to value\n                            (value * valueRange / scrollTrackWidth) + min :\n                            // from value to pixel\n                            scrollTrackWidth * (value - min) / valueRange;\n                    },\n                    toFixedRange: Axis.prototype.toFixedRange\n                };\n            }\n\n\n            // Initialize the scrollbar\n            if (chart.options.scrollbar.enabled) {\n                scroller.scrollbar = new Scrollbar(\n                    chart.renderer,\n                    merge(chart.options.scrollbar, { margin: scroller.navigatorEnabled ? 0 : 10 }),\n                    chart\n                );\n                addEvent(scroller.scrollbar, 'changed', function (e) {\n                    var range = scroller.navigatorWidth,\n                        to = range * this.to,\n                        from = range * this.from;\n\n                    scroller.hasDragged = scroller.scrollbar.hasDragged;\n                    scroller.render(0, 0, from, to);\n\n                    if (chart.options.scrollbar.liveRedraw || e.DOMType !== 'mousemove') {\n                        setTimeout(function () {\n                            scroller.mouseUpHandler(e);\n                        });\n                    }\n                });\n            }\n\n            // Add data events\n            scroller.addBaseSeriesEvents();\n\n\n            /**\n             * For stock charts, extend the Chart.getMargins method so that we can set the final top position\n             * of the navigator once the height of the chart, including the legend, is determined. #367.\n             */\n            wrap(chart, 'getMargins', function (proceed) {\n\n                var legend = this.legend,\n                    legendOptions = legend.options;\n\n                proceed.apply(this, [].slice.call(arguments, 1));\n\n                // Compute the top position\n                scroller.top = top = scroller.navigatorOptions.top ||\n                    this.chartHeight - scroller.height - scroller.scrollbarHeight - this.spacing[2] -\n                            (legendOptions.verticalAlign === 'bottom' && legendOptions.enabled && !legendOptions.floating ?\n                                legend.legendHeight + pick(legendOptions.margin, 10) : 0);\n\n                if (xAxis && yAxis) { // false if navigator is disabled (#904)\n\n                    xAxis.options.top = yAxis.options.top = top;\n\n                    xAxis.setAxisSize();\n                    yAxis.setAxisSize();\n                }\n            });\n\n            scroller.addEvents();\n        },\n\n        /**\n         * Get the union data extremes of the chart - the outer data extremes of the base\n         * X axis and the navigator axis.\n         */\n        getUnionExtremes: function (returnFalseOnNoBaseSeries) {\n            var baseAxis = this.chart.xAxis[0],\n                navAxis = this.xAxis,\n                navAxisOptions = navAxis.options,\n                baseAxisOptions = baseAxis.options,\n                ret;\n\n            if (!returnFalseOnNoBaseSeries || baseAxis.dataMin !== null) {\n                ret = {\n                    dataMin: pick( // #4053\n                        navAxisOptions && navAxisOptions.min,\n                        numExt(\n                            'min',\n                            baseAxisOptions.min,\n                            baseAxis.dataMin,\n                            navAxis.dataMin,\n                            navAxis.min\n                        )\n                    ),\n                    dataMax: pick(\n                        navAxisOptions && navAxisOptions.max,\n                        numExt(\n                            'max',\n                            baseAxisOptions.max,\n                            baseAxis.dataMax,\n                            navAxis.dataMax,\n                            navAxis.max\n                        )\n                    )\n                };\n            }\n            return ret;\n        },\n\n        /**\n         * Set the base series. With a bit of modification we should be able to make\n         * this an API method to be called from the outside\n         */\n        setBaseSeries: function (baseSeriesOption) {\n            var chart = this.chart;\n\n            baseSeriesOption = baseSeriesOption || chart.options.navigator.baseSeries;\n\n            // If we're resetting, remove the existing series\n            if (this.series) {\n                this.removeBaseSeriesEvents();\n                this.series.remove();\n            }\n\n            // Set the new base series\n            this.baseSeries = chart.series[baseSeriesOption] ||\n                (typeof baseSeriesOption === 'string' && chart.get(baseSeriesOption)) ||\n                chart.series[0];\n\n            // When run after render, this.xAxis already exists\n            if (this.xAxis) {\n                this.addBaseSeries();\n            }\n        },\n\n        addBaseSeries: function () {\n            var baseSeries = this.baseSeries,\n                baseOptions = baseSeries ? baseSeries.options : {},\n                baseData = baseOptions.data,\n                mergedNavSeriesOptions,\n                navigatorSeriesOptions = this.navigatorOptions.series,\n                navigatorData;\n\n            // remove it to prevent merging one by one\n            navigatorData = navigatorSeriesOptions.data;\n            this.hasNavigatorData = !!navigatorData;\n\n            // Merge the series options\n            mergedNavSeriesOptions = merge(baseOptions, navigatorSeriesOptions, {\n                enableMouseTracking: false,\n                group: 'nav', // for columns\n                padXAxis: false,\n                xAxis: 'navigator-x-axis',\n                yAxis: 'navigator-y-axis',\n                name: 'Navigator',\n                showInLegend: false,\n                stacking: false, // We only allow one series anyway (#4823)\n                isInternal: true,\n                visible: true\n            });\n\n            // Set the data. Do a slice to avoid mutating the navigator options from base series (#4923).\n            mergedNavSeriesOptions.data = navigatorData || baseData.slice(0);\n\n            // Add the series\n            this.series = this.chart.initSeries(mergedNavSeriesOptions);\n\n            this.addBaseSeriesEvents();\n\n        },\n        addBaseSeriesEvents: function () {\n            var baseSeries = this.baseSeries;\n\n            // Respond to updated data in the base series.\n            // Abort if lazy-loading data from the server.\n            if (baseSeries && baseSeries.xAxis && this.navigatorOptions.adaptToUpdatedData !== false) {\n                addEvent(baseSeries, 'updatedData', this.updatedDataHandler);\n                addEvent(baseSeries.xAxis, 'foundExtremes', this.modifyBaseAxisExtremes);\n        \n                // Survive Series.update()\n                baseSeries.userOptions.events = extend(baseSeries.userOptions.event, { updatedData: this.updatedDataHandler });\n            }\n        },\n        /**\n         * Set the scroller x axis extremes to reflect the total. The navigator extremes\n         * should always be the extremes of the union of all series in the chart as\n         * well as the navigator series.\n         */\n        modifyNavigatorAxisExtremes: function () {\n            var xAxis = this.xAxis,\n                unionExtremes;\n\n            if (xAxis.getExtremes) {\n                unionExtremes = this.getUnionExtremes(true);\n                if (unionExtremes && (unionExtremes.dataMin !== xAxis.min || unionExtremes.dataMax !== xAxis.max)) {\n                    xAxis.min = unionExtremes.dataMin;\n                    xAxis.max = unionExtremes.dataMax;\n                }\n            }\n        },\n\n        /**\n         * Hook to modify the base axis extremes with information from the Navigator\n         */\n        modifyBaseAxisExtremes: function () {\n            if (!this.chart.scroller.baseSeries || !this.chart.scroller.baseSeries.xAxis) {\n                return;\n            }\n        \n            var baseXAxis = this,\n                scroller = baseXAxis.chart.scroller,\n                baseExtremes = baseXAxis.getExtremes(),\n                baseMin = baseExtremes.min,\n                baseMax = baseExtremes.max,\n                baseDataMin = baseExtremes.dataMin,\n                baseDataMax = baseExtremes.dataMax,\n                range = baseMax - baseMin,\n                stickToMin = scroller.stickToMin,\n                stickToMax = scroller.stickToMax,\n                newMax,\n                newMin,\n                navigatorSeries = scroller.series,\n                hasSetExtremes = !!baseXAxis.setExtremes,\n\n                // When the extremes have been set by range selector button, don't stick to min or max.\n                // The range selector buttons will handle the extremes. (#5489)\n                unmutable = baseXAxis.eventArgs && baseXAxis.eventArgs.trigger === 'rangeSelectorButton';\n\n            if (!unmutable) {\n        \n                // If the zoomed range is already at the min, move it to the right as new data\n                // comes in\n                if (stickToMin) {\n                    newMin = baseDataMin;\n                    newMax = newMin + range;\n                }\n\n                // If the zoomed range is already at the max, move it to the right as new data\n                // comes in\n                if (stickToMax) {\n                    newMax = baseDataMax;\n                    if (!stickToMin) { // if stickToMin is true, the new min value is set above\n                        newMin = mathMax(newMax - range, navigatorSeries && navigatorSeries.xData ? navigatorSeries.xData[0] : -Number.MAX_VALUE);\n                    }\n                }\n\n                // Update the extremes\n                if (hasSetExtremes && (stickToMin || stickToMax)) {\n                    if (isNumber(newMin)) {\n                        baseXAxis.min = baseXAxis.userMin = newMin;\n                        baseXAxis.max = baseXAxis.userMax = newMax;\n                    }\n                }\n            }\n\n            // Reset\n            scroller.stickToMin = scroller.stickToMax = null;\n        },\n\n        /**\n         * Handler for updated data on the base series. When data is modified, the navigator series\n         * must reflect it. This is called from the Chart.redraw function before axis and series \n         * extremes are computed.\n         */\n        updatedDataHandler: function () {\n            var scroller = this.chart.scroller,\n                baseSeries = scroller.baseSeries,\n                navigatorSeries = scroller.series;\n\n            // Detect whether the zoomed area should stick to the minimum or maximum. If the current\n            // axis minimum falls outside the new updated dataset, we must adjust.\n            scroller.stickToMin = isNumber(baseSeries.xAxis.min) && (baseSeries.xAxis.min <= baseSeries.xData[0]);\n            // If the scrollbar is scrolled all the way to the right, keep right as new data \n            // comes in.\n            scroller.stickToMax = Math.round(scroller.zoomedMax) >= Math.round(scroller.navigatorWidth);\n\n            // Set the navigator series data to the new data of the base series\n            if (navigatorSeries && !scroller.hasNavigatorData) {\n                navigatorSeries.options.pointStart = baseSeries.xData[0];\n                navigatorSeries.setData(baseSeries.options.data, false, null, false); // #5414\n            }\n        },\n\n        /**\n         * Destroys allocated elements.\n         */\n        destroy: function () {\n            var scroller = this;\n\n            // Disconnect events added in addEvents\n            scroller.removeEvents();\n\n            // Destroy properties\n            each([scroller.scrollbar, scroller.xAxis, scroller.yAxis, scroller.leftShade, scroller.rightShade, scroller.outline], function (prop) {\n                if (prop && prop.destroy) {\n                    prop.destroy();\n                }\n            });\n            scroller.xAxis = scroller.yAxis = scroller.leftShade = scroller.rightShade = scroller.outline = null;\n\n            // Destroy elements in collection\n            each([scroller.handles, scroller.elementsToDestroy], function (coll) {\n                destroyObjectProperties(coll);\n            });\n        }\n    };\n\n    Highcharts.Navigator = Navigator;\n\n    /**\n     * For Stock charts, override selection zooming with some special features because\n     * X axis zooming is already allowed by the Navigator and Range selector.\n     */\n    wrap(Axis.prototype, 'zoom', function (proceed, newMin, newMax) {\n        var chart = this.chart,\n            chartOptions = chart.options,\n            zoomType = chartOptions.chart.zoomType,\n            previousZoom,\n            navigator = chartOptions.navigator,\n            rangeSelector = chartOptions.rangeSelector,\n            ret;\n\n        if (this.isXAxis && ((navigator && navigator.enabled) ||\n                (rangeSelector && rangeSelector.enabled))) {\n\n            // For x only zooming, fool the chart.zoom method not to create the zoom button\n            // because the property already exists\n            if (zoomType === 'x') {\n                chart.resetZoomButton = 'blocked';\n\n            // For y only zooming, ignore the X axis completely\n            } else if (zoomType === 'y') {\n                ret = false;\n\n            // For xy zooming, record the state of the zoom before zoom selection, then when\n            // the reset button is pressed, revert to this state\n            } else if (zoomType === 'xy') {\n                previousZoom = this.previousZoom;\n                if (defined(newMin)) {\n                    this.previousZoom = [this.min, this.max];\n                } else if (previousZoom) {\n                    newMin = previousZoom[0];\n                    newMax = previousZoom[1];\n                    delete this.previousZoom;\n                }\n            }\n\n        }\n        return ret !== UNDEFINED ? ret : proceed.call(this, newMin, newMax);\n    });\n\n    // Initialize scroller for stock charts\n    wrap(Chart.prototype, 'init', function (proceed, options, callback) {\n\n        addEvent(this, 'beforeRender', function () {\n            var options = this.options;\n            if (options.navigator.enabled || options.scrollbar.enabled) {\n                this.scroller = new Navigator(this);\n            }\n        });\n\n        proceed.call(this, options, callback);\n\n    });\n\n    // Pick up badly formatted point options to addPoint\n    wrap(Series.prototype, 'addPoint', function (proceed, options, redraw, shift, animation) {\n        var turboThreshold = this.options.turboThreshold;\n        if (turboThreshold && this.xData.length > turboThreshold && isObject(options, true) && this.chart.scroller) {\n            error(20, true);\n        }\n        proceed.call(this, options, redraw, shift, animation);\n    });\n\n    /* ****************************************************************************\n     * End Navigator code                                                          *\n     *****************************************************************************/\n    /* ****************************************************************************\n     * Start Range Selector code                                                  *\n     *****************************************************************************/\n    extend(defaultOptions, {\n        rangeSelector: {\n            // allButtonsEnabled: false,\n            // enabled: true,\n            // buttons: {Object}\n            // buttonSpacing: 0,\n            buttonTheme: {\n                width: 28,\n                height: 18,\n                fill: '#f7f7f7',\n                padding: 2,\n                r: 0,\n                'stroke-width': 0,\n                style: {\n                    color: '#444',\n                    cursor: 'pointer',\n                    fontWeight: 'normal'\n                },\n                zIndex: 7, // #484, #852\n                states: {\n                    hover: {\n                        fill: '#e7e7e7'\n                    },\n                    select: {\n                        fill: '#e7f0f9',\n                        style: {\n                            color: 'black',\n                            fontWeight: 'bold'\n                        }\n                    }\n                }\n            },\n            height: 35, // reserved space for buttons and input\n            inputPosition: {\n                align: 'right'\n            },\n            // inputDateFormat: '%b %e, %Y',\n            // inputEditDateFormat: '%Y-%m-%d',\n            // inputEnabled: true,\n            // inputStyle: {},\n            labelStyle: {\n                color: '#666'\n            }\n            // selected: undefined\n        }\n    });\n    defaultOptions.lang = merge(defaultOptions.lang, {\n        rangeSelectorZoom: 'Zoom',\n        rangeSelectorFrom: 'From',\n        rangeSelectorTo: 'To'\n    });\n\n    /**\n     * The object constructor for the range selector\n     * @param {Object} chart\n     */\n    function RangeSelector(chart) {\n\n        // Run RangeSelector\n        this.init(chart);\n    }\n\n    RangeSelector.prototype = {\n        /**\n         * The method to run when one of the buttons in the range selectors is clicked\n         * @param {Number} i The index of the button\n         * @param {Object} rangeOptions\n         * @param {Boolean} redraw\n         */\n        clickButton: function (i, redraw) {\n            var rangeSelector = this,\n                selected = rangeSelector.selected,\n                chart = rangeSelector.chart,\n                buttons = rangeSelector.buttons,\n                rangeOptions = rangeSelector.buttonOptions[i],\n                baseAxis = chart.xAxis[0],\n                unionExtremes = (chart.scroller && chart.scroller.getUnionExtremes()) || baseAxis || {},\n                dataMin = unionExtremes.dataMin,\n                dataMax = unionExtremes.dataMax,\n                newMin,\n                newMax = baseAxis && mathRound(mathMin(baseAxis.max, pick(dataMax, baseAxis.max))), // #1568\n                now,\n                type = rangeOptions.type,\n                baseXAxisOptions,\n                range = rangeOptions._range,\n                rangeMin,\n                year,\n                minSetting,\n                rangeSetting,\n                ctx,\n                dataGrouping = rangeOptions.dataGrouping;\n\n            if (dataMin === null || dataMax === null || // chart has no data, base series is removed\n                    i === rangeSelector.selected) { // same button is clicked twice\n                return;\n            }\n\n            // Set the fixed range before range is altered\n            chart.fixedRange = range;\n\n            // Apply dataGrouping associated to button\n            if (dataGrouping) {\n                this.forcedDataGrouping = true;\n                Axis.prototype.setDataGrouping.call(baseAxis || { chart: this.chart }, dataGrouping, false);\n            }\n\n            // Apply range\n            if (type === 'month' || type === 'year') {\n                if (!baseAxis) {\n                    // This is set to the user options and picked up later when the axis is instantiated\n                    // so that we know the min and max.\n                    range = rangeOptions;\n                } else {\n                    ctx = {\n                        range: rangeOptions,\n                        max: newMax,\n                        dataMin: dataMin,\n                        dataMax: dataMax\n                    };\n                    newMin = baseAxis.minFromRange.call(ctx);\n                    if (isNumber(ctx.newMax)) {\n                        newMax = ctx.newMax;\n                    }\n                }\n\n            // Fixed times like minutes, hours, days\n            } else if (range) {\n                newMin = mathMax(newMax - range, dataMin);\n                newMax = mathMin(newMin + range, dataMax);\n\n            } else if (type === 'ytd') {\n\n                // On user clicks on the buttons, or a delayed action running from the beforeRender\n                // event (below), the baseAxis is defined.\n                if (baseAxis) {\n\n                    // When \"ytd\" is the pre-selected button for the initial view, its calculation\n                    // is delayed and rerun in the beforeRender event (below). When the series\n                    // are initialized, but before the chart is rendered, we have access to the xData\n                    // array (#942).\n                    if (dataMax === UNDEFINED) {\n                        dataMin = Number.MAX_VALUE;\n                        dataMax = Number.MIN_VALUE;\n                        each(chart.series, function (series) {\n                            var xData = series.xData; // reassign it to the last item\n                            dataMin = mathMin(xData[0], dataMin);\n                            dataMax = mathMax(xData[xData.length - 1], dataMax);\n                        });\n                        redraw = false;\n                    }\n                    now = new Date(dataMax);\n                    year = now.getFullYear();\n                    newMin = rangeMin = mathMax(dataMin || 0, Date.UTC(year, 0, 1));\n                    now = now.getTime();\n                    newMax = mathMin(dataMax || now, now);\n\n                // \"ytd\" is pre-selected. We don't yet have access to processed point and extremes data\n                // (things like pointStart and pointInterval are missing), so we delay the process (#942)\n                } else {\n                    addEvent(chart, 'beforeRender', function () {\n                        rangeSelector.clickButton(i);\n                    });\n                    return;\n                }\n            } else if (type === 'all' && baseAxis) {\n                newMin = dataMin;\n                newMax = dataMax;\n            }\n\n            // Deselect previous button\n            if (buttons[selected]) {\n                buttons[selected].setState(0);\n            }\n            // Select this button\n            if (buttons[i]) {\n                buttons[i].setState(2);\n                rangeSelector.lastSelected = i;\n            }\n\n            // Update the chart\n            if (!baseAxis) {\n                // Axis not yet instanciated. Temporarily set min and range\n                // options and remove them on chart load (#4317).\n                baseXAxisOptions = splat(chart.options.xAxis)[0];\n                rangeSetting = baseXAxisOptions.range;\n                baseXAxisOptions.range = range;\n                minSetting = baseXAxisOptions.min;\n                baseXAxisOptions.min = rangeMin;\n                rangeSelector.setSelected(i);\n                addEvent(chart, 'load', function resetMinAndRange() {\n                    baseXAxisOptions.range = rangeSetting;\n                    baseXAxisOptions.min = minSetting;\n                });\n            } else {\n                // Existing axis object. Set extremes after render time.\n                baseAxis.setExtremes(\n                    newMin,\n                    newMax,\n                    pick(redraw, 1),\n                    null, // auto animation\n                    {\n                        trigger: 'rangeSelectorButton',\n                        rangeSelectorButton: rangeOptions\n                    }\n                );\n                rangeSelector.setSelected(i);\n            }\n        },\n\n        /**\n         * Set the selected option. This method only sets the internal flag, it doesn't\n         * update the buttons or the actual zoomed range.\n         */\n        setSelected: function (selected) {\n            this.selected = this.options.selected = selected;\n        },\n\n        /**\n         * The default buttons for pre-selecting time frames\n         */\n        defaultButtons: [{\n            type: 'month',\n            count: 1,\n            text: '1m'\n        }, {\n            type: 'month',\n            count: 3,\n            text: '3m'\n        }, {\n            type: 'month',\n            count: 6,\n            text: '6m'\n        }, {\n            type: 'ytd',\n            text: 'YTD'\n        }, {\n            type: 'year',\n            count: 1,\n            text: '1y'\n        }, {\n            type: 'all',\n            text: 'All'\n        }],\n\n        /**\n         * Initialize the range selector\n         */\n        init: function (chart) {\n\n            var rangeSelector = this,\n                options = chart.options.rangeSelector,\n                buttonOptions = options.buttons || [].concat(rangeSelector.defaultButtons),\n                selectedOption = options.selected,\n                blurInputs = rangeSelector.blurInputs = function () {\n                    var minInput = rangeSelector.minInput,\n                        maxInput = rangeSelector.maxInput;\n                    if (minInput && minInput.blur) { //#3274 in some case blur is not defined\n                        fireEvent(minInput, 'blur'); //#3274\n                    }\n                    if (maxInput && maxInput.blur) { //#3274 in some case blur is not defined\n                        fireEvent(maxInput, 'blur'); //#3274\n                    }\n                };\n\n            rangeSelector.chart = chart;\n            rangeSelector.options = options;\n            rangeSelector.buttons = [];\n\n            chart.extraTopMargin = options.height;\n            rangeSelector.buttonOptions = buttonOptions;\n\n            addEvent(chart.container, 'mousedown', blurInputs);\n            addEvent(chart, 'resize', blurInputs);\n\n            // Extend the buttonOptions with actual range\n            each(buttonOptions, rangeSelector.computeButtonRange);\n\n            // zoomed range based on a pre-selected button index\n            if (selectedOption !== UNDEFINED && buttonOptions[selectedOption]) {\n                this.clickButton(selectedOption, false);\n            }\n\n\n            addEvent(chart, 'load', function () {\n                // If a data grouping is applied to the current button, release it when extremes change\n                addEvent(chart.xAxis[0], 'setExtremes', function (e) {\n                    if (this.max - this.min !== chart.fixedRange && e.trigger !== 'rangeSelectorButton' &&\n                            e.trigger !== 'updatedData' && rangeSelector.forcedDataGrouping) {\n                        this.setDataGrouping(false, false);\n                    }\n                });\n                // Normalize the pressed button whenever a new range is selected\n                addEvent(chart.xAxis[0], 'afterSetExtremes', function () {\n                    rangeSelector.updateButtonStates(true);\n                });\n            });\n        },\n\n        /**\n         * Dynamically update the range selector buttons after a new range has been set\n         */\n        updateButtonStates: function (updating) {\n            var rangeSelector = this,\n                chart = this.chart,\n                baseAxis = chart.xAxis[0],\n                unionExtremes = (chart.scroller && chart.scroller.getUnionExtremes()) || baseAxis,\n                dataMin = unionExtremes.dataMin,\n                dataMax = unionExtremes.dataMax,\n                selected = rangeSelector.selected,\n                allButtonsEnabled = rangeSelector.options.allButtonsEnabled,\n                buttons = rangeSelector.buttons;\n\n            if (updating && chart.fixedRange !== mathRound(baseAxis.max - baseAxis.min)) {\n                if (buttons[selected]) {\n                    buttons[selected].setState(0);\n                }\n                rangeSelector.setSelected(null);\n            }\n\n            each(rangeSelector.buttonOptions, function (rangeOptions, i) {\n                var actualRange = mathRound(baseAxis.max - baseAxis.min),\n                    range = rangeOptions._range,\n                    type = rangeOptions.type,\n                    count = rangeOptions.count || 1,\n                    // Disable buttons where the range exceeds what is allowed in the current view\n                    isTooGreatRange = range > dataMax - dataMin,\n                    // Disable buttons where the range is smaller than the minimum range\n                    isTooSmallRange = range < baseAxis.minRange,\n                    // Disable the All button if we're already showing all\n                    isAllButAlreadyShowingAll = rangeOptions.type === 'all' && baseAxis.max - baseAxis.min >= dataMax - dataMin &&\n                        buttons[i].state !== 2,\n                    // Set a button on export\n                    isSelectedForExport = chart.renderer.forExport && i === selected,\n\n                    isSameRange = range === actualRange,\n\n                    hasNoData = !baseAxis.hasVisibleSeries;\n\n                // Months and years have a variable range so we check the extremes\n                if ((type === 'month' || type === 'year') && (actualRange >= { month: 28, year: 365 }[type] * 24 * 36e5 * count) &&\n                        (actualRange <= { month: 31, year: 366 }[type] * 24 * 36e5 * count)) {\n                    isSameRange = true;\n                }\n                // The new zoom area happens to match the range for a button - mark it selected.\n                // This happens when scrolling across an ordinal gap. It can be seen in the intraday\n                // demos when selecting 1h and scroll across the night gap.\n                if (isSelectedForExport || (isSameRange && i !== selected) && i === rangeSelector.lastSelected) {\n                    rangeSelector.setSelected(i);\n                    buttons[i].setState(2);\n\n                } else if (!allButtonsEnabled && (isTooGreatRange || isTooSmallRange || isAllButAlreadyShowingAll || hasNoData)) {\n                    buttons[i].setState(3);\n\n                } else if (buttons[i].state === 3) {\n                    buttons[i].setState(0);\n                }\n            });\n        },\n\n        /**\n         * Compute and cache the range for an individual button\n         */\n        computeButtonRange: function (rangeOptions) {\n            var type = rangeOptions.type,\n                count = rangeOptions.count || 1,\n\n                // these time intervals have a fixed number of milliseconds, as opposed\n                // to month, ytd and year\n                fixedTimes = {\n                    millisecond: 1,\n                    second: 1000,\n                    minute: 60 * 1000,\n                    hour: 3600 * 1000,\n                    day: 24 * 3600 * 1000,\n                    week: 7 * 24 * 3600 * 1000\n                };\n\n            // Store the range on the button object\n            if (fixedTimes[type]) {\n                rangeOptions._range = fixedTimes[type] * count;\n            } else if (type === 'month' || type === 'year') {\n                rangeOptions._range = { month: 30, year: 365 }[type] * 24 * 36e5 * count;\n            }\n        },\n\n        /**\n         * Set the internal and displayed value of a HTML input for the dates\n         * @param {String} name\n         * @param {Number} time\n         */\n        setInputValue: function (name, time) {\n            var options = this.chart.options.rangeSelector;\n\n            if (defined(time)) {\n                this[name + 'Input'].HCTime = time;\n            }\n\n            this[name + 'Input'].value = dateFormat(\n                options.inputEditDateFormat || '%Y-%m-%d',\n                this[name + 'Input'].HCTime\n            );\n            this[name + 'DateBox'].attr({\n                text: dateFormat(options.inputDateFormat || '%b %e, %Y', this[name + 'Input'].HCTime)\n            });\n        },\n\n        showInput: function (name) {\n            var inputGroup = this.inputGroup,\n                dateBox = this[name + 'DateBox'];\n\n            css(this[name + 'Input'], {\n                left: (inputGroup.translateX + dateBox.x) + PX,\n                top: inputGroup.translateY + PX,\n                width: (dateBox.width - 2) + PX,\n                height: (dateBox.height - 2) + PX,\n                border: '2px solid silver'\n            });\n        },\n\n        hideInput: function (name) {\n            css(this[name + 'Input'], {\n                border: 0,\n                width: '1px',\n                height: '1px'\n            });\n            this.setInputValue(name);\n        },\n\n        /**\n         * Draw either the 'from' or the 'to' HTML input box of the range selector\n         * @param {Object} name\n         */\n        drawInput: function (name) {\n            var rangeSelector = this,\n                chart = rangeSelector.chart,\n                chartStyle = chart.renderer.style,\n                renderer = chart.renderer,\n                options = chart.options.rangeSelector,\n                lang = defaultOptions.lang,\n                div = rangeSelector.div,\n                isMin = name === 'min',\n                input,\n                label,\n                dateBox,\n                inputGroup = this.inputGroup;\n\n            function updateExtremes() {\n                var inputValue = input.value,\n                    value = (options.inputDateParser || Date.parse)(inputValue),\n                    xAxis = chart.scroller && chart.scroller.xAxis ? chart.scroller.xAxis : chart.xAxis[0],\n                    dataMin = xAxis.dataMin,\n                    dataMax = xAxis.dataMax;\n                if (value !== input.previousValue) {\n                    input.previousValue = value;\n                    // If the value isn't parsed directly to a value by the browser's Date.parse method,\n                    // like YYYY-MM-DD in IE, try parsing it a different way\n                    if (!isNumber(value)) {\n                        value = inputValue.split('-');\n                        value = Date.UTC(pInt(value[0]), pInt(value[1]) - 1, pInt(value[2]));\n                    }\n\n                    if (isNumber(value)) {\n\n                        // Correct for timezone offset (#433)\n                        if (!defaultOptions.global.useUTC) {\n                            value = value + new Date().getTimezoneOffset() * 60 * 1000;\n                        }\n\n                        // Validate the extremes. If it goes beyound the data min or max, use the\n                        // actual data extreme (#2438).\n                        if (isMin) {\n                            if (value > rangeSelector.maxInput.HCTime) {\n                                value = UNDEFINED;\n                            } else if (value < dataMin) {\n                                value = dataMin;\n                            }\n                        } else {\n                            if (value < rangeSelector.minInput.HCTime) {\n                                value = UNDEFINED;\n                            } else if (value > dataMax) {\n                                value = dataMax;\n                            }\n                        }\n\n                        // Set the extremes\n                        if (value !== UNDEFINED) {\n                            chart.xAxis[0].setExtremes(\n                                isMin ? value : xAxis.min,\n                                isMin ? xAxis.max : value,\n                                UNDEFINED,\n                                UNDEFINED,\n                                { trigger: 'rangeSelectorInput' }\n                            );\n                        }\n                    }\n                }\n            }\n\n            // Create the text label\n            this[name + 'Label'] = label = renderer.label(lang[isMin ? 'rangeSelectorFrom' : 'rangeSelectorTo'], this.inputGroup.offset)\n                .attr({\n                    padding: 2\n                })\n                .css(merge(chartStyle, options.labelStyle))\n                .add(inputGroup);\n            inputGroup.offset += label.width + 5;\n\n            // Create an SVG label that shows updated date ranges and and records click events that\n            // bring in the HTML input.\n            this[name + 'DateBox'] = dateBox = renderer.label('', inputGroup.offset)\n                .attr({\n                    padding: 2,\n                    width: options.inputBoxWidth || 90,\n                    height: options.inputBoxHeight || 17,\n                    stroke: options.inputBoxBorderColor || 'silver',\n                    'stroke-width': 1\n                })\n                .css(merge({\n                    textAlign: 'center',\n                    color: '#444'\n                }, chartStyle, options.inputStyle))\n                .on('click', function () {\n                    rangeSelector.showInput(name); // If it is already focused, the onfocus event doesn't fire (#3713)\n                    rangeSelector[name + 'Input'].focus();\n                })\n                .add(inputGroup);\n            inputGroup.offset += dateBox.width + (isMin ? 10 : 0);\n\n\n            // Create the HTML input element. This is rendered as 1x1 pixel then set to the right size\n            // when focused.\n            this[name + 'Input'] = input = createElement('input', {\n                name: name,\n                className: PREFIX + 'range-selector',\n                type: 'text'\n            }, extend({\n                position: ABSOLUTE,\n                border: 0,\n                width: '1px', // Chrome needs a pixel to see it\n                height: '1px',\n                padding: 0,\n                textAlign: 'center',\n                fontSize: chartStyle.fontSize,\n                fontFamily: chartStyle.fontFamily,\n                left: '-9em', // #4798\n                top: chart.plotTop + PX // prevent jump on focus in Firefox\n            }, options.inputStyle), div);\n\n            // Blow up the input box\n            input.onfocus = function () {\n                rangeSelector.showInput(name);\n            };\n            // Hide away the input box\n            input.onblur = function () {\n                rangeSelector.hideInput(name);\n            };\n\n            // handle changes in the input boxes\n            input.onchange = updateExtremes;\n\n            input.onkeypress = function (event) {\n                // IE does not fire onchange on enter\n                if (event.keyCode === 13) {\n                    updateExtremes();\n                }\n            };\n        },\n\n        /**\n         * Get the position of the range selector buttons and inputs. This can be overridden from outside for custom positioning.\n         */\n        getPosition: function () {\n            var chart = this.chart,\n                options = chart.options.rangeSelector,\n                buttonTop = pick((options.buttonPosition || {}).y, chart.plotTop - chart.axisOffset[0] - options.height);\n\n            return {\n                buttonTop: buttonTop,\n                inputTop: buttonTop - 10\n            };\n        },\n\n        /**\n         * Render the range selector including the buttons and the inputs. The first time render\n         * is called, the elements are created and positioned. On subsequent calls, they are\n         * moved and updated.\n         * @param {Number} min X axis minimum\n         * @param {Number} max X axis maximum\n         */\n        render: function (min, max) {\n\n            var rangeSelector = this,\n                chart = rangeSelector.chart,\n                renderer = chart.renderer,\n                container = chart.container,\n                chartOptions = chart.options,\n                navButtonOptions = chartOptions.exporting && chartOptions.exporting.enabled !== false &&\n                    chartOptions.navigation && chartOptions.navigation.buttonOptions,\n                options = chartOptions.rangeSelector,\n                buttons = rangeSelector.buttons,\n                lang = defaultOptions.lang,\n                div = rangeSelector.div,\n                inputGroup = rangeSelector.inputGroup,\n                buttonTheme = options.buttonTheme,\n                buttonPosition = options.buttonPosition || {},\n                inputEnabled = options.inputEnabled,\n                states = buttonTheme && buttonTheme.states,\n                plotLeft = chart.plotLeft,\n                buttonLeft,\n                pos = this.getPosition(),\n                buttonGroup = rangeSelector.group,\n                buttonBBox,\n                rendered = rangeSelector.rendered;\n\n\n            // create the elements\n            if (!rendered) {\n\n                rangeSelector.group = buttonGroup = renderer.g('range-selector-buttons').add();\n\n                rangeSelector.zoomText = renderer.text(lang.rangeSelectorZoom, pick(buttonPosition.x, plotLeft), 15)\n                    .css(options.labelStyle)\n                    .add(buttonGroup);\n\n                // button starting position\n                buttonLeft = pick(buttonPosition.x, plotLeft) + rangeSelector.zoomText.getBBox().width + 5;\n\n                each(rangeSelector.buttonOptions, function (rangeOptions, i) {\n                    buttons[i] = renderer.button(\n                            rangeOptions.text,\n                            buttonLeft,\n                            0,\n                            function () {\n                                rangeSelector.clickButton(i);\n                                rangeSelector.isActive = true;\n                            },\n                            buttonTheme,\n                            states && states.hover,\n                            states && states.select,\n                            states && states.disabled\n                        )\n                        .css({\n                            textAlign: 'center'\n                        })\n                        .add(buttonGroup);\n\n                    // increase button position for the next button\n                    buttonLeft += buttons[i].width + pick(options.buttonSpacing, 5);\n\n                    if (rangeSelector.selected === i) {\n                        buttons[i].setState(2);\n                    }\n                });\n\n                rangeSelector.updateButtonStates();\n\n                // first create a wrapper outside the container in order to make\n                // the inputs work and make export correct\n                if (inputEnabled !== false) {\n                    rangeSelector.div = div = createElement('div', null, {\n                        position: 'relative',\n                        height: 0,\n                        zIndex: 1 // above container\n                    });\n\n                    container.parentNode.insertBefore(div, container);\n\n                    // Create the group to keep the inputs\n                    rangeSelector.inputGroup = inputGroup = renderer.g('input-group')\n                        .add();\n                    inputGroup.offset = 0;\n\n                    rangeSelector.drawInput('min');\n                    rangeSelector.drawInput('max');\n                }\n            }\n\n            // Set or update the group position\n            buttonGroup[rendered ? 'animate' : 'attr']({\n                translateY: pos.buttonTop\n            });\n\n            if (inputEnabled !== false) {\n\n                // Update the alignment to the updated spacing box\n                inputGroup.align(extend({\n                    y: pos.inputTop,\n                    width: inputGroup.offset,\n                    // Detect collision with the exporting buttons\n                    x: navButtonOptions && (pos.inputTop < (navButtonOptions.y || 0) + navButtonOptions.height - chart.spacing[0]) ?\n                        -40 : 0\n                }, options.inputPosition), true, chart.spacingBox);\n\n                // Hide if overlapping - inputEnabled is null or undefined\n                if (!defined(inputEnabled)) {\n                    buttonBBox = buttonGroup.getBBox();\n                    inputGroup[inputGroup.translateX < buttonBBox.x + buttonBBox.width + 10 ? 'hide' : 'show']();\n                }\n\n                // Set or reset the input values\n                rangeSelector.setInputValue('min', min);\n                rangeSelector.setInputValue('max', max);\n            }\n\n            rangeSelector.rendered = true;\n        },\n\n        /**\n         * Destroys allocated elements.\n         */\n        destroy: function () {\n            var minInput = this.minInput,\n                maxInput = this.maxInput,\n                chart = this.chart,\n                blurInputs = this.blurInputs,\n                key;\n\n            removeEvent(chart.container, 'mousedown', blurInputs);\n            removeEvent(chart, 'resize', blurInputs);\n\n            // Destroy elements in collections\n            destroyObjectProperties(this.buttons);\n\n            // Clear input element events\n            if (minInput) {\n                minInput.onfocus = minInput.onblur = minInput.onchange = null;\n            }\n            if (maxInput) {\n                maxInput.onfocus = maxInput.onblur = maxInput.onchange = null;\n            }\n\n            // Destroy HTML and SVG elements\n            for (key in this) {\n                if (this[key] && key !== 'chart') {\n                    if (this[key].destroy) { // SVGElement\n                        this[key].destroy();\n                    } else if (this[key].nodeType) { // HTML element\n                        discardElement(this[key]);\n                    }\n                }\n                this[key] = null;\n            }\n        }\n    };\n\n    /**\n     * Add logic to normalize the zoomed range in order to preserve the pressed state of range selector buttons\n     */\n    Axis.prototype.toFixedRange = function (pxMin, pxMax, fixedMin, fixedMax) {\n        var fixedRange = this.chart && this.chart.fixedRange,\n            newMin = pick(fixedMin, this.translate(pxMin, true)),\n            newMax = pick(fixedMax, this.translate(pxMax, true)),\n            changeRatio = fixedRange && (newMax - newMin) / fixedRange;\n\n        // If the difference between the fixed range and the actual requested range is\n        // too great, the user is dragging across an ordinal gap, and we need to release\n        // the range selector button.\n        if (changeRatio > 0.7 && changeRatio < 1.3) {\n            if (fixedMax) {\n                newMin = newMax - fixedRange;\n            } else {\n                newMax = newMin + fixedRange;\n            }\n        }\n        if (!isNumber(newMin)) { // #1195\n            newMin = newMax = undefined;\n        }\n\n        return {\n            min: newMin,\n            max: newMax\n        };\n    };\n\n    Axis.prototype.minFromRange = function () {\n        var rangeOptions = this.range,\n            type = rangeOptions.type,\n            timeName = { month: 'Month', year: 'FullYear' }[type],\n            min,\n            max = this.max,\n            dataMin,\n            range,\n            // Get the true range from a start date\n            getTrueRange = function (base, count) {\n                var date = new Date(base);\n                date['set' + timeName](date['get' + timeName]() + count);\n                return date.getTime() - base;\n            };\n\n        if (isNumber(rangeOptions)) {\n            min = this.max - rangeOptions;\n            range = rangeOptions;\n        } else {\n            min = max + getTrueRange(max, -rangeOptions.count);\n        }\n\n        dataMin = pick(this.dataMin, Number.MIN_VALUE);\n        if (!isNumber(min)) {\n            min = dataMin;\n        }\n        if (min <= dataMin) {\n            min = dataMin;\n            if (range === undefined) { // #4501\n                range = getTrueRange(min, rangeOptions.count);\n            }\n            this.newMax = mathMin(min + range, this.dataMax);\n        }\n        if (!isNumber(max)) {\n            min = undefined;\n        }\n        return min;\n\n    };\n\n    // Initialize scroller for stock charts\n    wrap(Chart.prototype, 'init', function (proceed, options, callback) {\n\n        addEvent(this, 'init', function () {\n            if (this.options.rangeSelector.enabled) {\n                this.rangeSelector = new RangeSelector(this);\n            }\n        });\n\n        proceed.call(this, options, callback);\n\n    });\n\n\n    Highcharts.RangeSelector = RangeSelector;\n\n    /* ****************************************************************************\n     * End Range Selector code                                                    *\n     *****************************************************************************/\n\n\n\n    Chart.prototype.callbacks.push(function (chart) {\n        var extremes,\n            scroller = chart.scroller,\n            rangeSelector = chart.rangeSelector;\n\n        function renderRangeSelector() {\n            extremes = chart.xAxis[0].getExtremes();\n            if (isNumber(extremes.min)) {\n                rangeSelector.render(extremes.min, extremes.max);\n            }\n        }\n\n        function afterSetExtremesHandlerRangeSelector(e) {\n            rangeSelector.render(e.min, e.max);\n        }\n\n        function destroyEvents() {\n            if (rangeSelector) {\n                removeEvent(chart, 'resize', renderRangeSelector);\n                removeEvent(chart.xAxis[0], 'afterSetExtremes', afterSetExtremesHandlerRangeSelector);\n            }\n        }\n\n        // initiate the scroller\n        if (scroller) {\n            extremes = chart.xAxis[0].getExtremes();\n            scroller.render(extremes.min, extremes.max);\n        }\n        if (rangeSelector) {\n            // redraw the scroller on setExtremes\n            addEvent(chart.xAxis[0], 'afterSetExtremes', afterSetExtremesHandlerRangeSelector);\n\n            // redraw the scroller chart resize\n            addEvent(chart, 'resize', renderRangeSelector);\n\n            // do it now\n            renderRangeSelector();\n        }\n\n        // Remove resize/afterSetExtremes at chart destroy\n        addEvent(chart, 'destroy', destroyEvents);\n    });\n    /**\n     * A wrapper for Chart with all the default values for a Stock chart\n     */\n    Highcharts.StockChart = Highcharts.stockChart = function (a, b, c) {\n        var hasRenderToArg = isString(a) || a.nodeName,\n            options = arguments[hasRenderToArg ? 1 : 0],\n            seriesOptions = options.series, // to increase performance, don't merge the data\n            opposite,\n\n            // Always disable startOnTick:true on the main axis when the navigator is enabled (#1090)\n            navigatorEnabled = pick(options.navigator && options.navigator.enabled, true),\n            disableStartOnTick = navigatorEnabled ? {\n                startOnTick: false,\n                endOnTick: false\n            } : null,\n\n            lineOptions = {\n\n                marker: {\n                    enabled: false,\n                    radius: 2\n                }\n                // gapSize: 0\n            },\n            columnOptions = {\n                shadow: false,\n                borderWidth: 0\n            };\n\n        // apply X axis options to both single and multi y axes\n        options.xAxis = map(splat(options.xAxis || {}), function (xAxisOptions) {\n            return merge(\n                { // defaults\n                    minPadding: 0,\n                    maxPadding: 0,\n                    ordinal: true,\n                    title: {\n                        text: null\n                    },\n                    labels: {\n                        overflow: 'justify'\n                    },\n                    showLastLabel: true\n                }, xAxisOptions, // user options\n                { // forced options\n                    type: 'datetime',\n                    categories: null\n                },\n                disableStartOnTick\n            );\n        });\n\n        // apply Y axis options to both single and multi y axes\n        options.yAxis = map(splat(options.yAxis || {}), function (yAxisOptions) {\n            opposite = pick(yAxisOptions.opposite, true);\n            return merge({ // defaults\n                labels: {\n                    y: -2\n                },\n                opposite: opposite,\n                showLastLabel: false,\n                title: {\n                    text: null\n                }\n            }, yAxisOptions // user options\n            );\n        });\n\n        options.series = null;\n\n        options = merge(\n            {\n                chart: {\n                    panning: true,\n                    pinchType: 'x'\n                },\n                navigator: {\n                    enabled: true\n                },\n                scrollbar: {\n                    enabled: true\n                },\n                rangeSelector: {\n                    enabled: true\n                },\n                title: {\n                    text: null,\n                    style: {\n                        fontSize: '16px'\n                    }\n                },\n                tooltip: {\n                    shared: true,\n                    crosshairs: true\n                },\n                legend: {\n                    enabled: false\n                },\n\n                plotOptions: {\n                    line: lineOptions,\n                    spline: lineOptions,\n                    area: lineOptions,\n                    areaspline: lineOptions,\n                    arearange: lineOptions,\n                    areasplinerange: lineOptions,\n                    column: columnOptions,\n                    columnrange: columnOptions,\n                    candlestick: columnOptions,\n                    ohlc: columnOptions\n                }\n\n            },\n            options, // user's options\n\n            { // forced options\n                _stock: true, // internal flag\n                chart: {\n                    inverted: false\n                }\n            }\n        );\n\n        options.series = seriesOptions;\n\n        return hasRenderToArg ? \n            new Chart(a, options, c) :\n            new Chart(options, b);\n    };\n\n    // Implement the pinchType option\n    wrap(Pointer.prototype, 'init', function (proceed, chart, options) {\n\n        var pinchType = options.chart.pinchType || '';\n\n        proceed.call(this, chart, options);\n\n        // Pinch status\n        this.pinchX = this.pinchHor = pinchType.indexOf('x') !== -1;\n        this.pinchY = this.pinchVert = pinchType.indexOf('y') !== -1;\n        this.hasZoom = this.hasZoom || this.pinchHor || this.pinchVert;\n    });\n\n    // Override the automatic label alignment so that the first Y axis' labels\n    // are drawn on top of the grid line, and subsequent axes are drawn outside\n    wrap(Axis.prototype, 'autoLabelAlign', function (proceed) {\n        var chart = this.chart,\n            options = this.options,\n            panes = chart._labelPanes = chart._labelPanes || {},\n            key,\n            labelOptions = this.options.labels;\n        if (this.chart.options._stock && this.coll === 'yAxis') {\n            key = options.top + ',' + options.height;\n            if (!panes[key] && labelOptions.enabled) { // do it only for the first Y axis of each pane\n                if (labelOptions.x === 15) { // default\n                    labelOptions.x = 0;\n                }\n                if (labelOptions.align === undefined) {\n                    labelOptions.align = 'right';\n                }\n                panes[key] = 1;\n                return 'right';\n            }\n        }\n        return proceed.call(this, [].slice.call(arguments, 1));\n    });\n\n    // Override getPlotLinePath to allow for multipane charts\n    wrap(Axis.prototype, 'getPlotLinePath', function (proceed, value, lineWidth, old, force, translatedValue) {\n        var axis = this,\n            series = (this.isLinked && !this.series ? this.linkedParent.series : this.series),\n            chart = axis.chart,\n            renderer = chart.renderer,\n            axisLeft = axis.left,\n            axisTop = axis.top,\n            x1,\n            y1,\n            x2,\n            y2,\n            result = [],\n            axes = [], //#3416 need a default array\n            axes2,\n            uniqueAxes,\n            transVal;\n\n        // Ignore in case of color Axis. #3360, #3524\n        if (axis.coll === 'colorAxis') {\n            return proceed.apply(this, [].slice.call(arguments, 1));\n        }\n\n        // Get the related axes based on series\n        axes = (axis.isXAxis ?\n            (defined(axis.options.yAxis) ?\n                [chart.yAxis[axis.options.yAxis]] :\n                map(series, function (s) {\n                    return s.yAxis;\n                })\n            ) :\n            (defined(axis.options.xAxis) ?\n                [chart.xAxis[axis.options.xAxis]] :\n                map(series, function (s) {\n                    return s.xAxis;\n                })\n            )\n        );\n\n        // Get the related axes based options.*Axis setting #2810\n        axes2 = (axis.isXAxis ? chart.yAxis : chart.xAxis);\n        each(axes2, function (A) {\n            if (defined(A.options.id) ? A.options.id.indexOf('navigator') === -1 : true) {\n                var a = (A.isXAxis ? 'yAxis' : 'xAxis'),\n                    rax = (defined(A.options[a]) ? chart[a][A.options[a]] : chart[a][0]);\n\n                if (axis === rax) {\n                    axes.push(A);\n                }\n            }\n        });\n\n\n        // Remove duplicates in the axes array. If there are no axes in the axes array,\n        // we are adding an axis without data, so we need to populate this with grid\n        // lines (#2796).\n        uniqueAxes = axes.length ? [] : [axis.isXAxis ? chart.yAxis[0] : chart.xAxis[0]]; //#3742\n        each(axes, function (axis2) {\n            if (inArray(axis2, uniqueAxes) === -1) {\n                uniqueAxes.push(axis2);\n            }\n        });\n\n        transVal = pick(translatedValue, axis.translate(value, null, null, old));\n        if (isNumber(transVal)) {\n            if (axis.horiz) {\n                each(uniqueAxes, function (axis2) {\n                    var skip;\n\n                    y1 = axis2.pos;\n                    y2 = y1 + axis2.len;\n                    x1 = x2 = mathRound(transVal + axis.transB);\n\n                    if (x1 < axisLeft || x1 > axisLeft + axis.width) { // outside plot area\n                        if (force) {\n                            x1 = x2 = mathMin(mathMax(axisLeft, x1), axisLeft + axis.width);\n                        } else {\n                            skip = true;\n                        }\n                    }\n                    if (!skip) {\n                        result.push('M', x1, y1, 'L', x2, y2);\n                    }\n                });\n            } else {\n                each(uniqueAxes, function (axis2) {\n                    var skip;\n\n                    x1 = axis2.pos;\n                    x2 = x1 + axis2.len;\n                    y1 = y2 = mathRound(axisTop + axis.height - transVal);\n\n                    if (y1 < axisTop || y1 > axisTop + axis.height) { // outside plot area\n                        if (force) {\n                            y1 = y2 = mathMin(mathMax(axisTop, y1), axis.top + axis.height);\n                        } else {\n                            skip = true;\n                        }\n                    }\n                    if (!skip) {\n                        result.push('M', x1, y1, 'L', x2, y2);\n                    }\n                });\n            }\n        }\n        return result.length > 0 ?\n            renderer.crispPolyLine(result, lineWidth || 1) :\n            null; //#3557 getPlotLinePath in regular Highcharts also returns null\n    });\n\n    // Override getPlotBandPath to allow for multipane charts\n    Axis.prototype.getPlotBandPath = function (from, to) {\n        var toPath = this.getPlotLinePath(to, null, null, true),\n            path = this.getPlotLinePath(from, null, null, true),\n            result = [],\n            i;\n\n        if (path && toPath && path.toString() !== toPath.toString()) {\n            // Go over each subpath\n            for (i = 0; i < path.length; i += 6) {\n                result.push('M', path[i + 1], path[i + 2], 'L', path[i + 4], path[i + 5], toPath[i + 4], toPath[i + 5], toPath[i + 1], toPath[i + 2]);\n            }\n        } else { // outside the axis area\n            result = null;\n        }\n\n        return result;\n    };\n\n    // Function to crisp a line with multiple segments\n    SVGRenderer.prototype.crispPolyLine = function (points, width) {\n        // points format: [M, 0, 0, L, 100, 0]\n        // normalize to a crisp line\n        var i;\n        for (i = 0; i < points.length; i = i + 6) {\n            if (points[i + 1] === points[i + 4]) {\n                // Substract due to #1129. Now bottom and left axis gridlines behave the same.\n                points[i + 1] = points[i + 4] = mathRound(points[i + 1]) - (width % 2 / 2);\n            }\n            if (points[i + 2] === points[i + 5]) {\n                points[i + 2] = points[i + 5] = mathRound(points[i + 2]) + (width % 2 / 2);\n            }\n        }\n        return points;\n    };\n    if (Renderer === Highcharts.VMLRenderer) {\n        VMLRenderer.prototype.crispPolyLine = SVGRenderer.prototype.crispPolyLine;\n    }\n\n\n    // Wrapper to hide the label\n    wrap(Axis.prototype, 'hideCrosshair', function (proceed, i) {\n        proceed.call(this, i);\n\n        if (this.crossLabel) {\n            this.crossLabel = this.crossLabel.hide();\n        }\n    });\n\n    // Wrapper to draw the label\n    wrap(Axis.prototype, 'drawCrosshair', function (proceed, e, point) {\n        // Draw the crosshair\n        proceed.call(this, e, point);\n\n        // Check if the label has to be drawn\n        if (!defined(this.crosshair.label) || !this.crosshair.label.enabled || !this.cross) {\n            return;\n        }\n\n        var chart = this.chart,\n            options = this.options.crosshair.label,        // the label's options\n            horiz = this.horiz,                            // axis orientation\n            opposite = this.opposite,                    // axis position\n            left = this.left,                            // left position\n            top = this.top,                                // top position\n            crossLabel = this.crossLabel,                // reference to the svgElement\n            posx,\n            posy,\n            crossBox,\n            formatOption = options.format,\n            formatFormat = '',\n            limit,\n            align,\n            tickInside = this.options.tickPosition === 'inside',\n            snap = this.crosshair.snap !== false,\n            value,\n            offset = 0;\n\n        // Use last available event (#5287)\n        if (!e) {\n            e = this.cross && this.cross.e;\n        }\n\n        align = (horiz ? 'center' : opposite ? (this.labelAlign === 'right' ? 'right' : 'left') : (this.labelAlign === 'left' ? 'left' : 'center'));\n\n        // If the label does not exist yet, create it.\n        if (!crossLabel) {\n            crossLabel = this.crossLabel = chart.renderer.label(null, null, null, options.shape || 'callout')\n            .attr({\n                align: options.align || align,\n                zIndex: 12,\n                fill: options.backgroundColor || (this.series[0] && this.series[0].color) || 'gray',\n                padding: pick(options.padding, 8),\n                stroke: options.borderColor || '',\n                'stroke-width': options.borderWidth || 0,\n                r: pick(options.borderRadius, 3)\n            })\n            .css(extend({\n                color: 'white',\n                fontWeight: 'normal',\n                fontSize: '11px',\n                textAlign: 'center'\n            }, options.style))\n            .add();\n        }\n\n        if (horiz) {\n            posx = snap ? point.plotX + left : e.chartX;\n            posy = top + (opposite ? 0 : this.height);\n        } else {\n            posx = opposite ? this.width + left : 0;\n            posy = snap ? point.plotY + top : e.chartY;\n        }\n\n        if (!formatOption && !options.formatter) {\n            if (this.isDatetimeAxis) {\n                formatFormat = '%b %d, %Y';\n            }\n            formatOption = '{value' + (formatFormat ? ':' + formatFormat : '') + '}';\n        }\n\n        // Show the label\n        value = snap ? point[this.isXAxis ? 'x' : 'y'] : this.toValue(horiz ? e.chartX : e.chartY);\n        crossLabel.attr({\n            text: formatOption ? format(formatOption, { value: value }) : options.formatter.call(this, value),\n            x: posx,\n            y: posy,\n            visibility: 'visible'\n        });\n\n        crossBox = crossLabel.getBBox();\n\n        // now it is placed we can correct its position\n        if (horiz) {\n            if ((tickInside && !opposite) || (!tickInside && opposite)) {\n                posy = crossLabel.y - crossBox.height;\n            }\n        } else {\n            posy = crossLabel.y - (crossBox.height / 2);\n        }\n\n        // check the edges\n        if (horiz) {\n            limit = {\n                left: left - crossBox.x,\n                right: left + this.width - crossBox.x\n            };\n        } else {\n            limit = {\n                left: this.labelAlign === 'left' ? left : 0,\n                right: this.labelAlign === 'right' ? left + this.width : chart.chartWidth\n            };\n        }\n\n        // left edge\n        if (crossLabel.translateX < limit.left) {\n            offset = limit.left - crossLabel.translateX;\n        }\n        // right edge\n        if (crossLabel.translateX + crossBox.width >= limit.right) {\n            offset = -(crossLabel.translateX + crossBox.width - limit.right);\n        }\n\n        // show the crosslabel\n        crossLabel.attr({\n            x: posx + offset,\n            y: posy,\n            // First set x and y, then anchorX and anchorY, when box is actually calculated, #5702\n            anchorX: horiz ? posx : (this.opposite ? 0 : chart.chartWidth),\n            anchorY: horiz ? (this.opposite ? chart.chartHeight : 0) : posy + crossBox.height / 2\n        });\n    });\n\n    /* ****************************************************************************\n     * Start value compare logic                                                  *\n     *****************************************************************************/\n\n    var seriesInit = seriesProto.init,\n        seriesProcessData = seriesProto.processData,\n        pointTooltipFormatter = Point.prototype.tooltipFormatter;\n\n    /**\n     * Extend series.init by adding a method to modify the y value used for plotting\n     * on the y axis. This method is called both from the axis when finding dataMin\n     * and dataMax, and from the series.translate method.\n     */\n    seriesProto.init = function () {\n\n        // Call base method\n        seriesInit.apply(this, arguments);\n\n        // Set comparison mode\n        this.setCompare(this.options.compare);\n    };\n\n    /**\n     * The setCompare method can be called also from the outside after render time\n     */\n    seriesProto.setCompare = function (compare) {\n\n        // Set or unset the modifyValue method\n        this.modifyValue = (compare === 'value' || compare === 'percent') ? function (value, point) {\n            var compareValue = this.compareValue;\n\n            if (value !== UNDEFINED) { // #2601\n\n                // get the modified value\n                value = compare === 'value' ?\n                    value - compareValue : // compare value\n                    value = 100 * (value / compareValue) - 100; // compare percent\n\n                // record for tooltip etc.\n                if (point) {\n                    point.change = value;\n                }\n\n            }\n\n            return value;\n        } : null;\n\n        // Survive to export, #5485\n        this.userOptions.compare = compare;\n\n        // Mark dirty\n        if (this.chart.hasRendered) {\n            this.isDirty = true;\n        }\n\n    };\n\n    /**\n     * Extend series.processData by finding the first y value in the plot area,\n     * used for comparing the following values\n     */\n    seriesProto.processData = function () {\n        var series = this,\n            i,\n            keyIndex = -1,\n            processedXData,\n            processedYData,\n            length,\n            compareValue;\n\n        // call base method\n        seriesProcessData.apply(this, arguments);\n\n        if (series.xAxis && series.processedYData) { // not pies\n\n            // local variables\n            processedXData = series.processedXData;\n            processedYData = series.processedYData;\n            length = processedYData.length;\n\n            // For series with more than one value (range, OHLC etc), compare against\n            // close or the pointValKey (#4922, #3112)\n            if (series.pointArrayMap) {\n                // Use close if present (#3112)\n                keyIndex = inArray('close', series.pointArrayMap);\n                if (keyIndex === -1) {\n                    keyIndex = inArray(series.pointValKey || 'y', series.pointArrayMap);\n                }\n            }\n\n            // find the first value for comparison\n            for (i = 0; i < length - 1; i++) {\n                compareValue = keyIndex > -1 ? \n                    processedYData[i][keyIndex] :\n                    processedYData[i];\n                if (isNumber(compareValue) && processedXData[i + 1] >= series.xAxis.min && compareValue !== 0) {\n                    series.compareValue = compareValue;\n                    break;\n                }\n            }\n        }\n    };\n\n    /**\n     * Modify series extremes\n     */\n    wrap(seriesProto, 'getExtremes', function (proceed) {\n        var extremes;\n\n        proceed.apply(this, [].slice.call(arguments, 1));\n\n        if (this.modifyValue) {\n            extremes = [this.modifyValue(this.dataMin), this.modifyValue(this.dataMax)];\n            this.dataMin = arrayMin(extremes);\n            this.dataMax = arrayMax(extremes);\n        }\n    });\n\n    /**\n     * Add a utility method, setCompare, to the Y axis\n     */\n    Axis.prototype.setCompare = function (compare, redraw) {\n        if (!this.isXAxis) {\n            each(this.series, function (series) {\n                series.setCompare(compare);\n            });\n            if (pick(redraw, true)) {\n                this.chart.redraw();\n            }\n        }\n    };\n\n    /**\n     * Extend the tooltip formatter by adding support for the point.change variable\n     * as well as the changeDecimals option\n     */\n    Point.prototype.tooltipFormatter = function (pointFormat) {\n        var point = this;\n\n        pointFormat = pointFormat.replace(\n            '{point.change}',\n            (point.change > 0 ? '+' : '') + Highcharts.numberFormat(point.change, pick(point.series.tooltipOptions.changeDecimals, 2))\n        );\n\n        return pointTooltipFormatter.apply(this, [pointFormat]);\n    };\n\n    /* ****************************************************************************\n     * End value compare logic                                                    *\n     *****************************************************************************/\n\n\n    /**\n     * Extend the Series prototype to create a separate series clip box. This is related\n     * to using multiple panes, and a future pane logic should incorporate this feature (#2754).\n     */\n    wrap(Series.prototype, 'render', function (proceed) {\n        // Only do this on stock charts (#2939), and only if the series type handles clipping\n        // in the animate method (#2975).\n        if (this.chart.options._stock && this.xAxis) {\n\n            // First render, initial clip box\n            if (!this.clipBox && this.animate) {\n                this.clipBox = merge(this.chart.clipBox);\n                this.clipBox.width = this.xAxis.len;\n                this.clipBox.height = this.yAxis.len;\n\n            // On redrawing, resizing etc, update the clip rectangle\n            } else if (this.chart[this.sharedClipKey]) {\n                stop(this.chart[this.sharedClipKey]); // #2998\n                this.chart[this.sharedClipKey].attr({\n                    width: this.xAxis.len,\n                    height: this.yAxis.len\n                });\n            // #3111\n            } else if (this.clipBox) {\n                this.clipBox.width = this.xAxis.len;\n                this.clipBox.height = this.yAxis.len;\n            }\n        }\n        proceed.call(this);\n    });\n\n    // global variables\n    extend(Highcharts, {\n\n        // Constructors\n        Color: Color,\n        Point: Point,\n        Tick: Tick,\n        Renderer: Renderer,\n        SVGElement: SVGElement,\n        SVGRenderer: SVGRenderer,\n\n        // Various\n        arrayMin: arrayMin,\n        arrayMax: arrayMax,\n        charts: charts,\n        correctFloat: correctFloat,\n        dateFormat: dateFormat,\n        error: error,\n        format: format,\n        pathAnim: pathAnim,\n        getOptions: getOptions,\n        hasBidiBug: hasBidiBug,\n        isTouchDevice: isTouchDevice,\n        setOptions: setOptions,\n        addEvent: addEvent,\n        removeEvent: removeEvent,\n        createElement: createElement,\n        discardElement: discardElement,\n        css: css,\n        each: each,\n        map: map,\n        merge: merge,\n        splat: splat,\n        stableSort: stableSort,\n        extendClass: extendClass,\n        pInt: pInt,\n        svg: hasSVG,\n        canvas: useCanVG,\n        vml: !hasSVG && !useCanVG,\n        product: PRODUCT,\n        version: VERSION\n    });\n    \n    return Highcharts;\n}));\n";
},661:function(t,n){t.exports='/*!\n * jQuery JavaScript Library v3.1.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2016-09-22T22:30Z\n */\n( function( global, factory ) {\n\n\t"use strict";\n\n\tif ( typeof module === "object" && typeof module.exports === "object" ) {\n\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require("jquery")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( "jQuery requires a window with a document" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {\n\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n// enough that all such attempts are guarded in a try block.\n"use strict";\n\nvar arr = [];\n\nvar document = window.document;\n\nvar getProto = Object.getPrototypeOf;\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar fnToString = hasOwn.toString;\n\nvar ObjectFunctionString = fnToString.call( Object );\n\nvar support = {};\n\n\n\n\tfunction DOMEval( code, doc ) {\n\t\tdoc = doc || document;\n\n\t\tvar script = doc.createElement( "script" );\n\n\t\tscript.text = code;\n\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t}\n/* global Symbol */\n// Defining this global in .eslintrc.json would create a danger of using the global\n// unguarded in another place, it seems safer to define global only for this module\n\n\n\nvar\n\tversion = "3.1.1",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor \'enhanced\'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android <=4.0 only\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([a-z])/g,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t};\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\n\t\t// Return all the elements in a clean array\n\t\tif ( num == null ) {\n\t\t\treturn slice.call( this );\n\t\t}\n\n\t\t// Return just the one element from the set\n\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array\'s method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === "boolean" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== "object" && !jQuery.isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we\'re merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = jQuery.isArray( copy ) ) ) ) {\n\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray( src ) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject( src ) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don\'t bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: "jQuery" + ( version + Math.random() ).replace( /\\D/g, "" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type( obj ) === "function";\n\t},\n\n\tisArray: Array.isArray,\n\n\tisWindow: function( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\n\t\t// As of jQuery 3.0, isNumeric is limited to\n\t\t// strings and numbers (primitives or objects)\n\t\t// that can be coerced to finite numbers (gh-2662)\n\t\tvar type = jQuery.type( obj );\n\t\treturn ( type === "number" || type === "string" ) &&\n\n\t\t\t// parseFloat NaNs numeric-cast false positives ("")\n\t\t\t// ...but misinterprets leading-number strings, particularly hex literals ("0x...")\n\t\t\t// subtraction forces infinities to NaN\n\t\t\t!isNaN( obj - parseFloat( obj ) );\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\tvar proto, Ctor;\n\n\t\t// Detect obvious negatives\n\t\t// Use toString instead of jQuery.type to catch host objects\n\t\tif ( !obj || toString.call( obj ) !== "[object Object]" ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tproto = getProto( obj );\n\n\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\tif ( !proto ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\tCtor = hasOwn.call( proto, "constructor" ) && proto.constructor;\n\t\treturn typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\n\t\t/* eslint-disable no-unused-vars */\n\t\t// See https://github.com/eslint/eslint/issues/6125\n\t\tvar name;\n\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn obj + "";\n\t\t}\n\n\t\t// Support: Android <=2.3 only (functionish RegExp)\n\t\treturn typeof obj === "object" || typeof obj === "function" ?\n\t\t\tclass2type[ toString.call( obj ) ] || "object" :\n\t\t\ttypeof obj;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tDOMEval( code );\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Support: IE <=9 - 11, Edge 12 - 13\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\tnodeName: function( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android <=4.0 only\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t"" :\n\t\t\t( text + "" ).replace( rtrim, "" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === "string" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t// push.apply(_, arraylike) throws on ancient WebKit\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar tmp, args, proxy;\n\n\t\tif ( typeof context === "string" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\tnow: Date.now,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\nif ( typeof Symbol === "function" ) {\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n}\n\n// Populate the class2type map\njQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),\nfunction( i, name ) {\n\tclass2type[ "[object " + name + "]" ] = name.toLowerCase();\n} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn\'t used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && "length" in obj && obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( type === "function" || jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === "array" || length === 0 ||\n\t\ttypeof length === "number" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.3.3\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2016-08-08\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = "sizzle" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it\'s faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = "[\\\\x20\\\\t\\\\r\\\\n\\\\f]",\n\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = "(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = "\\\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +\n\t\t// Operator (capture 2)\n\t\t"*([*^$|!~]?=)" + whitespace +\n\t\t// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"\n\t\t"*(?:\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\"|(" + identifier + "))|)" + whitespace +\n\t\t"*\\\\]",\n\n\tpseudos = ":(" + identifier + ")(?:\\\\((" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t"(\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\")|" +\n\t\t// 2. simple (capture 6)\n\t\t"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|" + attributes + ")*)|" +\n\t\t// 3. anything else (capture 2)\n\t\t".*" +\n\t\t")\\\\)|)",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + "+", "g" ),\n\trtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)" + whitespace + "+$", "g" ),\n\n\trcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),\n\trcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),\n\n\trattributeQuotes = new RegExp( "=" + whitespace + "*([^\\\\]\'\\"]*?)" + whitespace + "*\\\\]", "g" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( "^" + identifier + "$" ),\n\n\tmatchExpr = {\n\t\t"ID": new RegExp( "^#(" + identifier + ")" ),\n\t\t"CLASS": new RegExp( "^\\\\.(" + identifier + ")" ),\n\t\t"TAG": new RegExp( "^(" + identifier + "|[*])" ),\n\t\t"ATTR": new RegExp( "^" + attributes ),\n\t\t"PSEUDO": new RegExp( "^" + pseudos ),\n\t\t"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(" + whitespace +\n\t\t\t"*(even|odd|(([+-]|)(\\\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +\n\t\t\t"*(\\\\d+)|))" + whitespace + "*\\\\)|)", "i" ),\n\t\t"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(" +\n\t\t\twhitespace + "*((?:-\\\\d)?\\\\d*)" + whitespace + "*\\\\)|)(?=[^-]|$)", "i" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( "\\\\\\\\([\\\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = "0x" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +"0x"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === "\\0" ) {\n\t\t\t\treturn "\\uFFFD";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + "\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn "\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a "Permission Denied"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tdisabledAncestor = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && ("form" in elem || "label" in elem);\n\t\t},\n\t\t{ dir: "parentNode", next: "legend" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can\'t trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== "string" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a "get*By*" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don\'t exist)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( (m = match[1]) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!compilerCache[ selector + " " ] &&\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\n\t\t\t\tif ( nodeType !== 1 ) {\n\t\t\t\t\tnewContext = context;\n\t\t\t\t\tnewSelector = selector;\n\n\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t// Support: IE <=8\n\t\t\t\t// Exclude object elements\n\t\t\t\t} else if ( context.nodeName.toLowerCase() !== "object" ) {\n\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\tif ( (nid = context.getAttribute( "id" )) ) {\n\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( "id", (nid = expando) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = "#" + nid + " " + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( "," );\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\t\t\t\t}\n\n\t\t\t\tif ( newSelector ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\t\tcontext.removeAttribute( "id" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, "$1" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + " " ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + " " ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement("fieldset");\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split("|"),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === "input" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === "input" || name === "button") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( "form" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a "form" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( "label" in elem ) {\n\t\t\t\t\tif ( "label" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\tdisabledAncestor( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can\'t be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn\'t\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( "label" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== "undefined" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn\'t yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== "HTML" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9-11, Edge\n\t// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)\n\tif ( preferredDoc !== document &&\n\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( "unload", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( "onunload", unloadHandler );\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( el ) {\n\t\tel.className = "i";\n\t\treturn !el.getAttribute("className");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName("*") returns only elements\n\tsupport.getElementsByTagName = assert(function( el ) {\n\t\tel.appendChild( document.createComment("") );\n\t\treturn !el.getElementsByTagName("*").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don\'t pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t});\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter["ID"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute("id") === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find["ID"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== "undefined" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter["ID"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== "undefined" &&\n\t\t\t\t\telem.getAttributeNode("id");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find["ID"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== "undefined" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode("id");\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( (elem = elems[i++]) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode("id");\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find["TAG"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== "undefined" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don\'t have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === "*" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( el ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE\'s treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = "<a id=\'" + expando + "\'></a>" +\n\t\t\t\t"<select id=\'" + expando + "-\\r\\\\\' msallowcapture=\'\'>" +\n\t\t\t\t"<option selected=\'\'></option></select>";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but "safe" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll("[msallowcapture^=\'\']").length ) {\n\t\t\t\trbuggyQSA.push( "[*^$]=" + whitespace + "*(?:\'\'|\\"\\")" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and "value" are not treated correctly\n\t\t\tif ( !el.querySelectorAll("[selected]").length ) {\n\t\t\t\trbuggyQSA.push( "\\\\[" + whitespace + "*(?:value|" + booleans + ")" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {\n\t\t\t\trbuggyQSA.push("~=");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll(":checked").length ) {\n\t\t\t\trbuggyQSA.push(":checked");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {\n\t\t\t\trbuggyQSA.push(".#.+[+~]");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( el ) {\n\t\t\tel.innerHTML = "<a href=\'\' disabled=\'disabled\'></a>" +\n\t\t\t\t"<select disabled=\'disabled\'><option/></select>";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement("input");\n\t\t\tinput.setAttribute( "type", "hidden" );\n\t\t\tel.appendChild( input ).setAttribute( "name", "D" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll("[name=d]").length ) {\n\t\t\t\trbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll(":enabled").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( ":enabled", ":disabled" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE\'s :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll(":disabled").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( ":enabled", ":disabled" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll("*,:x");\n\t\t\trbuggyQSA.push(",.*:");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( el ) {\n\t\t\t// Check to see if it\'s possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, "*" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, "[s!=\'\']:x" );\n\t\t\trbuggyMatches.push( "!=", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === document ? -1 :\n\t\t\t\tb === document ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, "=\'$1\']" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!compilerCache[ expr + " " ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9\'s matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don\'t get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn (sel + "").replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( "Syntax error, unrecognized expression: " + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = "",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === "string" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t">": { dir: "parentNode", first: true },\n\t\t" ": { dir: "parentNode" },\n\t\t"+": { dir: "previousSibling", first: true },\n\t\t"~": { dir: "previousSibling" }\n\t},\n\n\tpreFilter: {\n\t\t"ATTR": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === "~=" ) {\n\t\t\t\tmatch[3] = " " + match[3] + " ";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t"CHILD": function( match ) {\n\t\t\t/* matches from matchExpr["CHILD"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === "nth" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t"PSEUDO": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr["CHILD"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || "";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t"TAG": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === "*" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t"CLASS": function( className ) {\n\t\t\tvar pattern = classCache[ className + " " ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );\n\t\t\t\t});\n\t\t},\n\n\t\t"ATTR": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === "!=";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += "";\n\n\t\t\t\treturn operator === "=" ? result === check :\n\t\t\t\t\toperator === "!=" ? result !== check :\n\t\t\t\t\toperator === "^=" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === "*=" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === "$=" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t"CHILD": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== "nth",\n\t\t\t\tforward = type.slice( -4 ) !== "last",\n\t\t\t\tofType = what === "of-type";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? "nextSibling" : "previousSibling",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven\'t yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === "only" && !start && "nextSibling";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t"PSEUDO": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( "unsupported pseudo: " + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, "", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t"not": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, "$1" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don\'t keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t"has": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t"contains": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// "Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element\'s language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by "-".\n\t\t// The matching of C against the element\'s language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name."\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t"lang": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || "") ) {\n\t\t\t\tSizzle.error( "unsupported lang: " + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t"target": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t"root": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t"focus": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t"enabled": createDisabledPseudo( false ),\n\t\t"disabled": createDisabledPseudo( true ),\n\n\t\t"checked": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);\n\t\t},\n\n\t\t"selected": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t"empty": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t"parent": function( elem ) {\n\t\t\treturn !Expr.pseudos["empty"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t"header": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t"input": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t"button": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === "input" && elem.type === "button" || name === "button";\n\t\t},\n\n\t\t"text": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === "input" &&\n\t\t\t\telem.type === "text" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"\n\t\t\t\t( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t"first": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t"last": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t"even": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t"odd": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos["nth"] = Expr.pseudos["eq"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + " " ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don\'t consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, " " )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we\'re just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = "";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === "parentNode",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can\'t set arbitrary data on XML nodes, so they don\'t benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we\'re done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[" "],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })\n\t\t\t\t\t).replace( rtrim, "$1" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = "0",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find["TAG"]( "*", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn\'t visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a "00" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + " " ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle\'s compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === "function" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&\n\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split("").sort( sortOrder ).join("") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren\'t passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( el ) {\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement("fieldset") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property "interpolation"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( el ) {\n\tel.innerHTML = "<a href=\'#\'></a>";\n\treturn el.firstChild.getAttribute("href") === "#" ;\n}) ) {\n\taddHandle( "type|href|height|width", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute("value")\nif ( !support.attributes || !assert(function( el ) {\n\tel.innerHTML = "<input/>";\n\tel.firstChild.setAttribute( "value", "" );\n\treturn el.firstChild.getAttribute( "value" ) === "";\n}) ) {\n\taddHandle( "value", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === "input" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( el ) {\n\treturn el.getAttribute("disabled") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\n\n// Deprecated\njQuery.expr[ ":" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\njQuery.escapeSelector = Sizzle.escape;\n\n\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\nvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\n\n\nvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\t}\n\n\t// Single element\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\t}\n\n\t// Arraylike of elements (jQuery, arguments, Array)\n\tif ( typeof qualifier !== "string" ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t} );\n\t}\n\n\t// Simple selector that can be filtered directly, removing non-Elements\n\tif ( risSimple.test( qualifier ) ) {\n\t\treturn jQuery.filter( qualifier, elements, not );\n\t}\n\n\t// Complex selector, compare the two sets, removing non-Elements\n\tqualifier = jQuery.filter( qualifier, elements );\n\treturn jQuery.grep( elements, function( elem ) {\n\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;\n\t} );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = ":not(" + expr + ")";\n\t}\n\n\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t}\n\n\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\treturn elem.nodeType === 1;\n\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i, ret,\n\t\t\tlen = this.length,\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== "string" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tret = this.pushStack( [] );\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $("p:first").is("p:last") won\'t return true for a doc with two "p".\n\t\t\ttypeof selector === "string" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\t// Shortcut simple #id case for speed\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(""), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === "string" ) {\n\t\t\tif ( selector[ 0 ] === "<" &&\n\t\t\t\tselector[ selector.length - 1 ] === ">" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn root.ready !== undefined ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\ttargets = typeof selectors !== "string" && jQuery( selectors );\n\n\t\t// Positional selectors never match, since there\'s no _selection_ context\n\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\n\t\t\t\t\t\t// Don\'t pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === "string" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, "parentNode" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn dir( elem, "parentNode", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, "nextSibling" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, "previousSibling" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, "nextSibling" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, "previousSibling" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn dir( elem, "nextSibling", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn dir( elem, "previousSibling", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== "Until" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === "string" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n} );\nvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * "fired" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest "memorized"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === "string" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn\'t re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we\'re done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we\'re done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = "";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( jQuery.isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = "";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\tlist = memory = "";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\nfunction Identity( v ) {\n\treturn v;\n}\nfunction Thrower( ex ) {\n\tthrow ex;\n}\n\nfunction adoptValue( value, resolve, reject ) {\n\tvar method;\n\n\ttry {\n\n\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\tif ( value && jQuery.isFunction( ( method = value.promise ) ) ) {\n\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\n\t\t// Other thenables\n\t\t} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {\n\t\t\tmethod.call( value, resolve, reject );\n\n\t\t// Other non-thenables\n\t\t} else {\n\n\t\t\t// Support: Android 4.0 only\n\t\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\t\tresolve.call( undefined, value );\n\t\t}\n\n\t// For Promises/A+, convert exceptions into rejections\n\t// Since jQuery.when doesn\'t unwrap thenables, we can skip the extra checks appearing in\n\t// Deferred#then to conditionally suppress rejection.\n\t} catch ( value ) {\n\n\t\t// Support: Android 4.0 only\n\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\treject.call( undefined, value );\n\t}\n}\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t[ "notify", "progress", jQuery.Callbacks( "memory" ),\n\t\t\t\t\tjQuery.Callbacks( "memory" ), 2 ],\n\t\t\t\t[ "resolve", "done", jQuery.Callbacks( "once memory" ),\n\t\t\t\t\tjQuery.Callbacks( "once memory" ), 0, "resolved" ],\n\t\t\t\t[ "reject", "fail", jQuery.Callbacks( "once memory" ),\n\t\t\t\t\tjQuery.Callbacks( "once memory" ), 1, "rejected" ]\n\t\t\t],\n\t\t\tstate = "pending",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t"catch": function( fn ) {\n\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + "With" ](\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\tthrow new TypeError( "Thenable self-resolution" );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\tthen = returned &&\n\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t( typeof returned === "object" ||\n\t\t\t\t\t\t\t\t\t\t\ttypeof returned === "function" ) &&\n\t\t\t\t\t\t\t\t\t\treturned.then;\n\n\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\tif ( jQuery.isFunction( then ) ) {\n\n\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t// since it\'s otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 5 ];\n\n\t\t\t// promise.progress = list.add\n\t\t\t// promise.done = list.add\n\t\t\t// promise.fail = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(\n\t\t\t\t\tfunction() {\n\n\t\t\t\t\t\t// state = "resolved" (i.e., fulfilled)\n\t\t\t\t\t\t// state = "rejected"\n\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[ 0 ][ 2 ].lock\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// progress_handlers.fire\n\t\t\t// fulfilled_handlers.fire\n\t\t\t// rejected_handlers.fire\n\t\t\tlist.add( tuple[ 3 ].fire );\n\n\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\tdeferred[ tuple[ 0 ] + "With" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( singleValue ) {\n\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array( i ),\n\t\t\tresolveValues = slice.call( arguments ),\n\n\t\t\t// the master Deferred\n\t\t\tmaster = jQuery.Deferred(),\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function( i ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\tmaster.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\tif ( remaining <= 1 ) {\n\t\t\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );\n\n\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\tif ( master.state() === "pending" ||\n\t\t\t\tjQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\n\t\t\t\treturn master.then();\n\t\t\t}\n\t\t}\n\n\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\twhile ( i-- ) {\n\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n\t\t}\n\n\t\treturn master.promise();\n\t}\n} );\n\n\n// These usually indicate a programmer mistake during development,\n// warn about them ASAP rather than swallowing them by default.\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\njQuery.Deferred.exceptionHook = function( error, stack ) {\n\n\t// Support: IE 8 - 9 only\n\t// Console exists when dev tools are open, which can happen at any time\n\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\twindow.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );\n\t}\n};\n\n\n\n\njQuery.readyException = function( error ) {\n\twindow.setTimeout( function() {\n\t\tthrow error;\n\t} );\n};\n\n\n\n\n// The deferred used on DOM ready\nvar readyList = jQuery.Deferred();\n\njQuery.fn.ready = function( fn ) {\n\n\treadyList\n\t\t.then( fn )\n\n\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t// happens at the time of error handling instead of callback\n\t\t// registration.\n\t\t.catch( function( error ) {\n\t\t\tjQuery.readyException( error );\n\t\t} );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Hold (or release) the ready event\n\tholdReady: function( hold ) {\n\t\tif ( hold ) {\n\t\t\tjQuery.readyWait++;\n\t\t} else {\n\t\t\tjQuery.ready( true );\n\t\t}\n\t},\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we\'re already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\t}\n} );\n\njQuery.ready.then = readyList.then;\n\n// The ready event handler and self cleanup method\nfunction completed() {\n\tdocument.removeEventListener( "DOMContentLoaded", completed );\n\twindow.removeEventListener( "load", completed );\n\tjQuery.ready();\n}\n\n// Catch cases where $(document).ready() is called\n// after the browser event has already occurred.\n// Support: IE <=9 - 10 only\n// Older IE sometimes signals "interactive" too soon\nif ( document.readyState === "complete" ||\n\t( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {\n\n\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\twindow.setTimeout( jQuery.ready );\n\n} else {\n\n\t// Use the handy event callback\n\tdocument.addEventListener( "DOMContentLoaded", completed );\n\n\t// A fallback to window.onload, that will always work\n\twindow.addEventListener( "load", completed );\n}\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it\'s a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( jQuery.type( key ) === "object" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\tvalue :\n\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( chainable ) {\n\t\treturn elems;\n\t}\n\n\t// Gets\n\tif ( bulk ) {\n\t\treturn fn.call( elems );\n\t}\n\n\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n};\nvar acceptData = function( owner ) {\n\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\n\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tcache: function( owner ) {\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\t// Always use camelCase key (gh-2257)\n\t\tif ( typeof data === "string" ) {\n\t\t\tcache[ jQuery.camelCase( data ) ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ jQuery.camelCase( prop ) ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\towner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];\n\t},\n\taccess: function( owner, key, value ) {\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the "read" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === "string" ) && value === undefined ) ) {\n\n\t\t\treturn this.get( owner, key );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the "set" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key !== undefined ) {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( jQuery.isArray( key ) ) {\n\n\t\t\t\t// If key is an array of keys...\n\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\tkey = key.map( jQuery.camelCase );\n\t\t\t} else {\n\t\t\t\tkey = jQuery.camelCase( key );\n\n\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\tkey = key in cache ?\n\t\t\t\t\t[ key ] :\n\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t}\n\n\t\t\ti = key.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there\'s no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <=35 - 45\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\nvar dataPriv = new Data();\n\nvar dataUser = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module\'s maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support "private" and "user" data.\n//\t4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /[A-Z]/g;\n\nfunction getData( data ) {\n\tif ( data === "true" ) {\n\t\treturn true;\n\t}\n\n\tif ( data === "false" ) {\n\t\treturn false;\n\t}\n\n\tif ( data === "null" ) {\n\t\treturn null;\n\t}\n\n\t// Only convert to a number if it doesn\'t change the string\n\tif ( data === +data + "" ) {\n\t\treturn +data;\n\t}\n\n\tif ( rbrace.test( data ) ) {\n\t\treturn JSON.parse( data );\n\t}\n\n\treturn data;\n}\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === "string" ) {\n\t\t\ttry {\n\t\t\t\tdata = getData( data );\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn\'t changed later\n\t\t\tdataUser.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend( {\n\thasData: function( elem ) {\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn dataUser.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdataUser.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to dataPriv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn dataPriv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdataPriv.remove( elem, name );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = dataUser.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( "data-" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.set( elem, "hasDataAttrs", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === "object" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.set( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data;\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to "discover" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn\'t exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each( function() {\n\n\t\t\t\t// We always store the camelCased key\n\t\t\t\tdataUser.set( this, key, value );\n\t\t\t} );\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tdataUser.remove( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || "fx" ) + "queue";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || "fx";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === "inprogress" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === "fx" ) {\n\t\t\t\tqueue.unshift( "inprogress" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + "queueHooks";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( "once memory" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + "queue", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== "string" ) {\n\t\t\tdata = type;\n\t\t\ttype = "fx";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === "fx" && queue[ 0 ] !== "inprogress" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || "fx", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== "string" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || "fx";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + "queueHooks" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );\n\n\nvar cssExpand = [ "Top", "Right", "Bottom", "Left" ];\n\nvar isHiddenWithinTree = function( elem, el ) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === "none" ||\n\t\t\telem.style.display === "" &&\n\n\t\t\t// Otherwise, check computed style\n\t\t\t// Support: Firefox <=43 - 45\n\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t// in the document.\n\t\t\tjQuery.contains( elem.ownerDocument, elem ) &&\n\n\t\t\tjQuery.css( elem, "display" ) === "none";\n\t};\n\nvar swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted,\n\t\tscale = 1,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() {\n\t\t\t\treturn tween.cur();\n\t\t\t} :\n\t\t\tfunction() {\n\t\t\t\treturn jQuery.css( elem, prop, "" );\n\t\t\t},\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\tdo {\n\n\t\t\t// If previous iteration zeroed out, double until we get *something*.\n\t\t\t// Use string for doubling so we don\'t accidentally see scale as unchanged below\n\t\t\tscale = scale || ".5";\n\n\t\t\t// Adjust and apply\n\t\t\tinitialInUnit = initialInUnit / scale;\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t// Break the loop if scale is unchanged or perfect, or if we\'ve just had enough.\n\t\t} while (\n\t\t\tscale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations\n\t\t);\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\n\n\nvar defaultDisplayMap = {};\n\nfunction getDefaultDisplay( elem ) {\n\tvar temp,\n\t\tdoc = elem.ownerDocument,\n\t\tnodeName = elem.nodeName,\n\t\tdisplay = defaultDisplayMap[ nodeName ];\n\n\tif ( display ) {\n\t\treturn display;\n\t}\n\n\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\tdisplay = jQuery.css( temp, "display" );\n\n\ttemp.parentNode.removeChild( temp );\n\n\tif ( display === "none" ) {\n\t\tdisplay = "block";\n\t}\n\tdefaultDisplayMap[ nodeName ] = display;\n\n\treturn display;\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\t// Determine new display value for elements that need to change\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t// inline or about-to-be-restored)\n\t\t\tif ( display === "none" ) {\n\t\t\t\tvalues[ index ] = dataPriv.get( elem, "display" ) || null;\n\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\telem.style.display = "";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {\n\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( display !== "none" ) {\n\t\t\t\tvalues[ index ] = "none";\n\n\t\t\t\t// Remember what we\'re overwriting\n\t\t\t\tdataPriv.set( elem, "display", display );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of the elements in a second loop to avoid constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\tif ( values[ index ] != null ) {\n\t\t\telements[ index ].style.display = values[ index ];\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend( {\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === "boolean" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i );\n\nvar rscriptType = ( /^$|\\/(?:java|ecma)script/i );\n\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n\n\t// Support: IE <=9 only\n\toption: [ 1, "<select multiple=\'multiple\'>", "</select>" ],\n\n\t// XHTML parsers do not magically insert elements in the\n\t// same way that tag soup parsers do. So we cannot shorten\n\t// this by omitting <tbody> or other required elements.\n\tthead: [ 1, "<table>", "</table>" ],\n\tcol: [ 2, "<table><colgroup>", "</colgroup></table>" ],\n\ttr: [ 2, "<table><tbody>", "</tbody></table>" ],\n\ttd: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],\n\n\t_default: [ 0, "", "" ]\n};\n\n// Support: IE <=9 only\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n\nfunction getAll( context, tag ) {\n\n\t// Support: IE <=9 - 11 only\n\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\tvar ret;\n\n\tif ( typeof context.getElementsByTagName !== "undefined" ) {\n\t\tret = context.getElementsByTagName( tag || "*" );\n\n\t} else if ( typeof context.querySelectorAll !== "undefined" ) {\n\t\tret = context.querySelectorAll( tag || "*" );\n\n\t} else {\n\t\tret = [];\n\t}\n\n\tif ( tag === undefined || tag && jQuery.nodeName( context, tag ) ) {\n\t\treturn jQuery.merge( [ context ], ret );\n\t}\n\n\treturn ret;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdataPriv.set(\n\t\t\telems[ i ],\n\t\t\t"globalEval",\n\t\t\t!refElements || dataPriv.get( refElements[ i ], "globalEval" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/;\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar elem, tmp, tag, wrap, contains, j,\n\t\tfragment = context.createDocumentFragment(),\n\t\tnodes = [],\n\t\ti = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( jQuery.type( elem ) === "object" ) {\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( "div" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Remember the top-level container\n\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\ttmp.textContent = "";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove wrapper from fragment\n\tfragment.textContent = "";\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( fragment.appendChild( elem ), "script" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( contains ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || "" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n\n( function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( "div" ) ),\n\t\tinput = document.createElement( "input" );\n\n\t// Support: Android 4.0 - 4.3 only\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( "type", "radio" );\n\tinput.setAttribute( "checked", "checked" );\n\tinput.setAttribute( "name", "t" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Android <=4.1 only\n\t// Older WebKit doesn\'t clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE <=11 only\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = "<textarea>x</textarea>";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n} )();\nvar documentElement = document.documentElement;\n\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// Support: IE <=9 only\n// See #13393 for more info\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === "object" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== "string" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === "string" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards\' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.get( elem );\n\n\t\t// Don\'t attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\tif ( selector ) {\n\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element\'s event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || "" ).match( rnothtmlwhite ) || [ "" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( "." )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we\'re the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element\'s handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || "" ).match( rnothtmlwhite ) || [ "" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( "(^|\\\\.)" + namespaces.join( "\\\\.(?:.*\\\\.|)" ) + "(\\\\.|$)" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === "**" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove data and the expando if it\'s no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdataPriv.remove( elem, "handle events" );\n\t\t}\n\t},\n\n\tdispatch: function( nativeEvent ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tvar event = jQuery.event.fix( nativeEvent );\n\n\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\targs = new Array( arguments.length ),\n\t\t\thandlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\n\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\tif ( delegateCount &&\n\n\t\t\t// Support: IE <=9\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\tcur.nodeType &&\n\n\t\t\t// Support: Firefox <=42\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t// Support: IE 11 only\n\t\t\t// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t!( event.type === "click" && event.button >= 1 ) ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don\'t check non-elements (#13208)\n\t\t\t\t// Don\'t process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {\n\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don\'t conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + " ";\n\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tcur = this;\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\taddProp: function( name, hook ) {\n\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\n\t\t\tget: jQuery.isFunction( hook ) ?\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t}\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\tset: function( value ) {\n\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: value\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t},\n\n\tfix: function( originalEvent ) {\n\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\toriginalEvent :\n\t\t\tnew jQuery.Event( originalEvent );\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: "focusin"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: "focusout"\n\t\t},\n\t\tclick: {\n\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don\'t fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn jQuery.nodeName( event.target, "a" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn\'t alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\n\t// This "if" is needed for plain objects\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the \'new\' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t\t// Create target properties\n\t\t// Support: Safari <=6 - 7 only\n\t\t// Target should not be a text node (#504, #13143)\n\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\tsrc.target.parentNode :\n\t\t\tsrc.target;\n\n\t\tthis.currentTarget = src.currentTarget;\n\t\tthis.relatedTarget = src.relatedTarget;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn\'t have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\tisSimulated: false,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\njQuery.each( {\n\taltKey: true,\n\tbubbles: true,\n\tcancelable: true,\n\tchangedTouches: true,\n\tctrlKey: true,\n\tdetail: true,\n\teventPhase: true,\n\tmetaKey: true,\n\tpageX: true,\n\tpageY: true,\n\tshiftKey: true,\n\tview: true,\n\t"char": true,\n\tcharCode: true,\n\tkey: true,\n\tkeyCode: true,\n\tbutton: true,\n\tbuttons: true,\n\tclientX: true,\n\tclientY: true,\n\toffsetX: true,\n\toffsetY: true,\n\tpointerId: true,\n\tpointerType: true,\n\tscreenX: true,\n\tscreenY: true,\n\ttargetTouches: true,\n\ttoElement: true,\n\ttouches: true,\n\n\twhich: function( event ) {\n\t\tvar button = event.button;\n\n\t\t// Add which for key events\n\t\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\n\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n\t\t}\n\n\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\n\t\t\tif ( button & 1 ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ( button & 2 ) {\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\tif ( button & 4 ) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn event.which;\n\t}\n}, jQuery.event.addProp );\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: "mouseover",\n\tmouseleave: "mouseout",\n\tpointerenter: "pointerover",\n\tpointerleave: "pointerout"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\njQuery.fn.extend( {\n\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + "." + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === "object" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === "function" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t}\n} );\n\n\nvar\n\n\t/* eslint-disable max-len */\n\n\t// See https://github.com/eslint/eslint/issues/3229\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\n\t/* eslint-enable */\n\n\t// Support: IE <=10 - 11, Edge 12 - 13\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked="checked" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\nfunction manipulationTarget( elem, content ) {\n\tif ( jQuery.nodeName( elem, "table" ) &&\n\t\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {\n\n\t\treturn elem.getElementsByTagName( "tbody" )[ 0 ] || elem;\n\t}\n\n\treturn elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\n\tif ( match ) {\n\t\telem.type = match[ 1 ];\n\t} else {\n\t\telem.removeAttribute( "type" );\n\t}\n\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( dataPriv.hasData( src ) ) {\n\t\tpdataOld = dataPriv.access( src );\n\t\tpdataCur = dataPriv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( dataUser.hasData( src ) ) {\n\t\tudataOld = dataUser.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdataUser.set( dest, udataCur );\n\t}\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === "input" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === "input" || nodeName === "textarea" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = concat.apply( [], args );\n\n\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tisFunction = jQuery.isFunction( value );\n\n\t// We can\'t cloneNode fragments that contain checked, in WebKit\n\tif ( isFunction ||\n\t\t\t( l > 1 && typeof value === "string" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( isFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, "script" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, "script" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Reenable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || "" ) &&\n\t\t\t\t\t\t!dataPriv.access( node, "globalEval" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won\'t run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, "" ), doc );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, "script" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html.replace( rxhtmlTag, "<$1></$2>" );\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, "script" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, "script" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove\'s overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t}\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = "";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === "string" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: "append",\n\tprependTo: "prepend",\n\tinsertBefore: "before",\n\tinsertAfter: "after",\n\treplaceAll: "replaceWith"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\nvar rmargin = ( /^margin/ );\n\nvar rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );\n\nvar getStyles = function( elem ) {\n\n\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\n\n\n( function() {\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they\'re executed at the same time to save the second computation.\n\tfunction computeStyleTests() {\n\n\t\t// This is a singleton, we need to execute it only once\n\t\tif ( !div ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdiv.style.cssText =\n\t\t\t"box-sizing:border-box;" +\n\t\t\t"position:relative;display:block;" +\n\t\t\t"margin:auto;border:1px;padding:1px;" +\n\t\t\t"top:1%;width:50%";\n\t\tdiv.innerHTML = "";\n\t\tdocumentElement.appendChild( container );\n\n\t\tvar divStyle = window.getComputedStyle( div );\n\t\tpixelPositionVal = divStyle.top !== "1%";\n\n\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\treliableMarginLeftVal = divStyle.marginLeft === "2px";\n\t\tboxSizingReliableVal = divStyle.width === "4px";\n\n\t\t// Support: Android 4.0 - 4.3 only\n\t\t// Some styles come back with percentage values, even though they shouldn\'t\n\t\tdiv.style.marginRight = "50%";\n\t\tpixelMarginRightVal = divStyle.marginRight === "4px";\n\n\t\tdocumentElement.removeChild( container );\n\n\t\t// Nullify the div so it wouldn\'t be stored in the memory and\n\t\t// it will also be a sign that checks already performed\n\t\tdiv = null;\n\t}\n\n\tvar pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,\n\t\tcontainer = document.createElement( "div" ),\n\t\tdiv = document.createElement( "div" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE <=9 - 11 only\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = "content-box";\n\tdiv.cloneNode( true ).style.backgroundClip = "";\n\tsupport.clearCloneStyle = div.style.backgroundClip === "content-box";\n\n\tcontainer.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +\n\t\t"padding:0;margin-top:1px;position:absolute";\n\tcontainer.appendChild( div );\n\n\tjQuery.extend( support, {\n\t\tpixelPosition: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelPositionVal;\n\t\t},\n\t\tboxSizingReliable: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\t\tpixelMarginRight: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelMarginRightVal;\n\t\t},\n\t\treliableMarginLeft: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn reliableMarginLeftVal;\n\t\t}\n\t} );\n} )();\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// Support: IE <=9 only\n\t// getPropertyValue is only needed for .css(\'filter\') (#12537)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\n\t\tif ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// A tribute to the "awesome hack by Dean Edwards"\n\t\t// Android Browser returns percentage for some values,\n\t\t// but width seems to be reliably pixels.\n\t\t// This is against the CSSOM draft spec:\n\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\tif ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// IE returns zIndex value as an integer.\n\t\tret + "" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we\'ll check on the first run if it\'s really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it\'s not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar\n\n\t// Swappable if display is none or starts with table\n\t// except "table", "table-cell", or "table-caption"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\tcssShow = { position: "absolute", visibility: "hidden", display: "block" },\n\tcssNormalTransform = {\n\t\tletterSpacing: "0",\n\t\tfontWeight: "400"\n\t},\n\n\tcssPrefixes = [ "Webkit", "Moz", "ms" ],\n\temptyStyle = document.createElement( "div" ).style;\n\n// Return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( name ) {\n\n\t// Shortcut for names that are not vendor prefixed\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\n\t// Check for vendor prefixed names\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\n\t// Any relative (+/-) values have already been\n\t// normalized at this point\n\tvar matches = rcssNum.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined "subtract", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i,\n\t\tval = 0;\n\n\t// If we already have the right measurement, avoid augmentation\n\tif ( extra === ( isBorderBox ? "border" : "content" ) ) {\n\t\ti = 4;\n\n\t// Otherwise initialize for horizontal or vertical properties\n\t} else {\n\t\ti = name === "width" ? 1 : 0;\n\t}\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// Both box models exclude margin, so add it if we want it\n\t\tif ( extra === "margin" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === "content" ) {\n\t\t\t\tval -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// At this point, extra isn\'t border nor margin, so remove border\n\t\t\tif ( extra !== "margin" ) {\n\t\t\t\tval -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );\n\t\t\t}\n\t\t} else {\n\n\t\t\t// At this point, extra isn\'t content, so add padding\n\t\t\tval += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );\n\n\t\t\t// At this point, extra isn\'t content nor padding, so add border\n\t\t\tif ( extra !== "padding" ) {\n\t\t\t\tval += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with offset property, which is equivalent to the border-box value\n\tvar val,\n\t\tvalueIsBorderBox = true,\n\t\tstyles = getStyles( elem ),\n\t\tisBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";\n\n\t// Support: IE <=11 only\n\t// Running getBoundingClientRect on a disconnected node\n\t// in IE throws an error.\n\tif ( elem.getClientRects().length ) {\n\t\tval = elem.getBoundingClientRect()[ name ];\n\t}\n\n\t// Some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\tif ( val <= 0 || val == null ) {\n\n\t\t// Fall back to computed then uncomputed css if necessary\n\t\tval = curCSS( elem, name, styles );\n\t\tif ( val < 0 || val == null ) {\n\t\t\tval = elem.style[ name ];\n\t\t}\n\n\t\t// Computed unit is not pixels. Stop here and return.\n\t\tif ( rnumnonpx.test( val ) ) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// Check for style in case a browser which returns unreliable values\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\tvalueIsBorderBox = isBorderBox &&\n\t\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\n\n\t\t// Normalize "", auto, and prepare for extra\n\t\tval = parseFloat( val ) || 0;\n\t}\n\n\t// Use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? "border" : "content" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + "px";\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, "opacity" );\n\t\t\t\t\treturn ret === "" ? "1" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don\'t automatically add "px" to these possibly-unitless properties\n\tcssNumber: {\n\t\t"animationIterationCount": true,\n\t\t"columnCount": true,\n\t\t"fillOpacity": true,\n\t\t"flexGrow": true,\n\t\t"flexShrink": true,\n\t\t"fontWeight": true,\n\t\t"lineHeight": true,\n\t\t"opacity": true,\n\t\t"order": true,\n\t\t"orphans": true,\n\t\t"widows": true,\n\t\t"zIndex": true,\n\t\t"zoom": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t"float": "cssFloat"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don\'t set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we\'re working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tstyle = elem.style;\n\n\t\tname = jQuery.cssProps[ origName ] ||\n\t\t\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we\'re setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert "+=" or "-=" to relative numbers (#7345)\n\t\t\tif ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = "number";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren\'t set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\tif ( type === "number" ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );\n\t\t\t}\n\n\t\t\t// background-* props affect original clone\'s values\n\t\t\tif ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {\n\t\t\t\tstyle[ name ] = "inherit";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( "set" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\tstyle[ name ] = value;\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && "get" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = jQuery.camelCase( name );\n\n\t\t// Make sure that we\'re working with the right name\n\t\tname = jQuery.cssProps[ origName ] ||\n\t\t\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && "get" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert "normal" to computed value\n\t\tif ( val === "normal" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === "" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ "height", "width" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, "display" ) ) &&\n\n\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t\t} ) :\n\t\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar matches,\n\t\t\t\tstyles = extra && getStyles( elem ),\n\t\t\t\tsubtract = extra && augmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tjQuery.css( elem, "boxSizing", false, styles ) === "border-box",\n\t\t\t\t\tstyles\n\t\t\t\t);\n\n\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t( matches[ 3 ] || "px" ) !== "px" ) {\n\n\t\t\t\telem.style[ name ] = value;\n\t\t\t\tvalue = jQuery.css( elem, name );\n\t\t\t}\n\n\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t}\n\t};\n} );\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn ( parseFloat( curCSS( elem, "marginLeft" ) ) ||\n\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t} )\n\t\t\t\t) + "px";\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: "",\n\tpadding: "",\n\tborder: "Width"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === "string" ? value.split( " " ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as "10px" are parsed to Float;\n\t\t\t// complex values such as "rotate(1rad)" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, "" );\n\n\t\t\t// Empty strings, null, undefined and "auto" are converted to 0.\n\t\t\treturn !result || result === "auto" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 &&\n\t\t\t\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\n\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9 only\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: "swing"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, timerId,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\nfunction raf() {\n\tif ( timerId ) {\n\t\twindow.requestAnimationFrame( raf );\n\t\tjQuery.fx.tick();\n\t}\n}\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = jQuery.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ "margin" + which ] = attrs[ "padding" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// We\'re done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\tisBox = "width" in props || "height" in props,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\tdataShow = dataPriv.get( elem, "fxshow" );\n\n\t// Queue-skipping animations hijack the fx hooks\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, "fx" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, "fx" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// Detect show/hide animations\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.test( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === "toggle";\n\t\t\tif ( value === ( hidden ? "hide" : "show" ) ) {\n\n\t\t\t\t// Pretend to be hidden if this is a "show" and\n\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\tif ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\n\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\t// Bail out if this is a no-op like .hide().hide()\n\tpropTween = !jQuery.isEmptyObject( props );\n\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\treturn;\n\t}\n\n\t// Restrict "overflow" and "display" styles during box animations\n\tif ( isBox && elem.nodeType === 1 ) {\n\n\t\t// Support: IE <=9 - 11, Edge 12 - 13\n\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t// from identically-valued overflowX and overflowY\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\trestoreDisplay = dataShow && dataShow.display;\n\t\tif ( restoreDisplay == null ) {\n\t\t\trestoreDisplay = dataPriv.get( elem, "display" );\n\t\t}\n\t\tdisplay = jQuery.css( elem, "display" );\n\t\tif ( display === "none" ) {\n\t\t\tif ( restoreDisplay ) {\n\t\t\t\tdisplay = restoreDisplay;\n\t\t\t} else {\n\n\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\tdisplay = jQuery.css( elem, "display" );\n\t\t\t\tshowHide( [ elem ] );\n\t\t\t}\n\t\t}\n\n\t\t// Animate inline elements as inline-block\n\t\tif ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {\n\t\t\tif ( jQuery.css( elem, "float" ) === "none" ) {\n\n\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\tif ( !propTween ) {\n\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t} );\n\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\trestoreDisplay = display === "none" ? "" : display;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstyle.display = "inline-block";\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = "hidden";\n\t\tanim.always( function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t} );\n\t}\n\n\t// Implement show/hide animations\n\tpropTween = false;\n\tfor ( prop in orig ) {\n\n\t\t// General show/hide setup for this element animation\n\t\tif ( !propTween ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( "hidden" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );\n\t\t\t}\n\n\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` "reverses"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\n\t\t\t// Show elements before animating them\n\t\t\tif ( hidden ) {\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t}\n\n\t\t\t/* eslint-disable no-loop-func */\n\n\t\t\tanim.done( function() {\n\n\t\t\t/* eslint-enable no-loop-func */\n\n\t\t\t\t// The final step of a "hide" animation is actually hiding the element\n\t\t\t\tif ( !hidden ) {\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t\tdataPriv.remove( elem, "fxshow" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Per-property setup\n\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\tif ( !( prop in dataShow ) ) {\n\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\tif ( hidden ) {\n\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\tpropTween.start = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( jQuery.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && "expand" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won\'t overwrite existing keys.\n\t\t\t// Reusing \'index\' because we have the correct "name"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// Don\'t match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t// Archaic crash bug won\'t allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t} else {\n\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( jQuery.isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tjQuery.proxy( result.stop, result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\t// attach callbacks from options\n\treturn animation.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweeners: {\n\t\t"*": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ "*" ];\n\t\t} else {\n\t\t\tprops = props.match( rnothtmlwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\t// Go to the end state if fx are off or if document is hidden\n\tif ( jQuery.fx.off || document.hidden ) {\n\t\topt.duration = 0;\n\n\t} else {\n\t\tif ( typeof opt.duration !== "number" ) {\n\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\n\t\t\t} else {\n\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize opt.queue - true/undefined/null -> "fx"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = "fx";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won\'t be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || dataPriv.get( this, "finish" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== "string" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || "fx", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + "queueHooks",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = dataPriv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn\'t forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || "fx";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\tqueue = data[ type + "queue" ],\n\t\t\t\thooks = data[ type + "queueHooks" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === "boolean" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( "show" ),\n\tslideUp: genFx( "hide" ),\n\tslideToggle: genFx( "toggle" ),\n\tfadeIn: { opacity: "show" },\n\tfadeOut: { opacity: "hide" },\n\tfadeToggle: { opacity: "toggle" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Checks the timer has not already been removed\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tif ( timer() ) {\n\t\tjQuery.fx.start();\n\t} else {\n\t\tjQuery.timers.pop();\n\t}\n};\n\njQuery.fx.interval = 13;\njQuery.fx.start = function() {\n\tif ( !timerId ) {\n\t\ttimerId = window.requestAnimationFrame ?\n\t\t\twindow.requestAnimationFrame( raf ) :\n\t\t\twindow.setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t}\n};\n\njQuery.fx.stop = function() {\n\tif ( window.cancelAnimationFrame ) {\n\t\twindow.cancelAnimationFrame( timerId );\n\t} else {\n\t\twindow.clearInterval( timerId );\n\t}\n\n\ttimerId = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || "fx";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar input = document.createElement( "input" ),\n\t\tselect = document.createElement( "select" ),\n\t\topt = select.appendChild( document.createElement( "option" ) );\n\n\tinput.type = "checkbox";\n\n\t// Support: Android <=4.3 only\n\t// Default value for a checkbox should be "on"\n\tsupport.checkOn = input.value !== "";\n\n\t// Support: IE <=11 only\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: IE <=11 only\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( "input" );\n\tinput.value = "t";\n\tinput.type = "radio";\n\tsupport.radioValue = input.value === "t";\n} )();\n\n\nvar boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don\'t get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === "undefined" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// Attribute hooks are determined by the lowercase version\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && "set" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + "" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === "radio" &&\n\t\t\t\t\tjQuery.nodeName( elem, "input" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( "type", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name,\n\t\t\ti = 0,\n\n\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\n\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle,\n\t\t\tlowercaseName = name.toLowerCase();\n\n\t\tif ( !isXML ) {\n\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tlowercaseName :\n\t\t\t\tnull;\n\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n} );\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don\'t get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && "set" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t// elem.tabIndex doesn\'t always return the\n\t\t\t\t// correct value when it hasn\'t been explicitly set\n\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, "tabindex" );\n\n\t\t\t\tif ( tabindex ) {\n\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\telem.href\n\t\t\t\t) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t"for": "htmlFor",\n\t\t"class": "className"\n\t}\n} );\n\n// Support: IE <=11 only\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\n// eslint rule "no-unused-expressions" is disabled for this code\n// since it considers such accessions noop\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: "off" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: "off" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t"tabIndex",\n\t"readOnly",\n\t"maxLength",\n\t"cellSpacing",\n\t"cellPadding",\n\t"rowSpan",\n\t"colSpan",\n\t"useMap",\n\t"frameBorder",\n\t"contentEditable"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n\n\n\n\t// Strip and collapse whitespace according to HTML spec\n\t// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace\n\tfunction stripAndCollapse( value ) {\n\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\treturn tokens.join( " " );\n\t}\n\n\nfunction getClass( elem ) {\n\treturn elem.getAttribute && elem.getAttribute( "class" ) || "";\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( typeof value === "string" && value ) {\n\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\t\t\t\tcur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\tif ( cur.indexOf( " " + clazz + " " ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + " ";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( "class", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( "class", "" );\n\t\t}\n\n\t\tif ( typeof value === "string" && value ) {\n\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( " " + clazz + " " ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( " " + clazz + " ", " " );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( "class", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value;\n\n\t\tif ( typeof stateVal === "boolean" && type === "string" ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar className, i, self, classNames;\n\n\t\t\tif ( type === "string" ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\ti = 0;\n\t\t\t\tself = jQuery( this );\n\t\t\t\tclassNames = value.match( rnothtmlwhite ) || [];\n\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === "boolean" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// Store className if set\n\t\t\t\t\tdataPriv.set( this, "__className__", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we\'re passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\tthis.setAttribute( "class",\n\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t"" :\n\t\t\t\t\t\tdataPriv.get( this, "__className__" ) || ""\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = " " + selector + " ";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, isFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks &&\n\t\t\t\t\t"get" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, "value" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\t// Handle most common string cases\n\t\t\t\tif ( typeof ret === "string" ) {\n\t\t\t\t\treturn ret.replace( rreturn, "" );\n\t\t\t\t}\n\n\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\treturn ret == null ? "" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as ""; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = "";\n\n\t\t\t} else if ( typeof val === "number" ) {\n\t\t\t\tval += "";\n\n\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? "" : value + "";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\tvar val = jQuery.find.attr( elem, "value" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option, i,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === "select-one",\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length;\n\n\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\ti = max;\n\n\t\t\t\t} else {\n\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t}\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t// IE8-9 doesn\'t update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don\'t return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don\'t need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t/* eslint-disable no-cond-assign */\n\n\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ "radio", "checkbox" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( "value" ) === null ? "on" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;\n\njQuery.extend( jQuery.event, {\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, "type" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don\'t do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we\'re not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( "." ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( "." );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( ":" ) < 0 && "on" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === "object" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( "." );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( "(^|\\\\.)" + namespaces.join( "\\\\.(?:.*\\\\.|)" ) + "(\\\\.|$)" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&\n\t\t\t\tdataPriv.get( cur, "handle" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( ( !special._default ||\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\tacceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t// Don\'t do default actions on window, that\'s where global variables be (#6170)\n\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don\'t re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\telem[ type ]();\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\t// Used only for `focus(in | out)` events\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\t}\n\n} );\n\njQuery.fn.extend( {\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\njQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +\n\t"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +\n\t"change select submit keydown keypress keyup contextmenu" ).split( " " ),\n\tfunction( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n} );\n\njQuery.fn.extend( {\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n} );\n\n\n\n\nsupport.focusin = "onfocusin" in window;\n\n\n// Support: Firefox <=44\n// Firefox doesn\'t have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n\tjQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdataPriv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\nvar location = window.location;\n\nvar nonce = jQuery.now();\n\nvar rquery = ( /\\?/ );\n\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml;\n\tif ( !data || typeof data !== "string" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE 9 - 11 only\n\t// IE throws on parseFromString with invalid input.\n\ttry {\n\t\txml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {\n\t\tjQuery.error( "Invalid XML: " + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( jQuery.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && jQuery.type( obj ) === "object" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, valueOrFunction ) {\n\n\t\t\t// If value is a function, invoke it and use its return value\n\t\t\tvar value = jQuery.isFunction( valueOrFunction ) ?\n\t\t\t\tvalueOrFunction() :\n\t\t\t\tvalueOrFunction;\n\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + "=" +\n\t\t\t\tencodeURIComponent( value == null ? "" : value );\n\t\t};\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the "old" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( "&" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for "elements" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, "elements" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} )\n\t\t.filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( ":disabled" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( ":disabled" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} )\n\t\t.map( function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\tif ( val == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( jQuery.isArray( val ) ) {\n\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, "\\r\\n" ) };\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn { name: elem.name, value: val.replace( rCRLF, "\\r\\n" ) };\n\t\t} ).get();\n\t}\n} );\n\n\nvar\n\tr20 = /%20/g,\n\trhash = /#.*$/,\n\trantiCache = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol "*" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to "*" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol "*" can be used\n\t * 3) selection will start with transport dataType and THEN go to "*" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = "*/".concat( "*" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( "a" );\n\toriginAnchor.href = location.href;\n\n// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to "*"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== "string" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = "*";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === "+" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || "*";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === "string" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );\n}\n\n// A special extend for ajax options\n// that takes "flat" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === "*" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );\n\t\t}\n\t}\n\n\t// Check if we\'re dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There\'s only work to do if current dataType is non-auto\n\t\t\tif ( current === "*" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== "*" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + " " + current ] || converters[ "* " + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( " " );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + " " + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ "* " + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: "parsererror",\n\t\t\t\t\t\t\t\terror: conv ? e : "No conversion from " + prev + " to " + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: "success", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: "GET",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: "application/x-www-form-urlencoded; charset=UTF-8",\n\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t"*": allTypes,\n\t\t\ttext: "text/plain",\n\t\t\thtml: "text/html",\n\t\t\txml: "application/xml, text/xml",\n\t\t\tjson: "application/json, text/javascript"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: "responseXML",\n\t\t\ttext: "responseText",\n\t\t\tjson: "responseJSON"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall "*") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t"* text": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t"text html": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t"text json": JSON.parse,\n\n\t\t\t// Parse text as xml\n\t\t\t"text xml": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn\'t be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn\'t be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === "object" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( "once memory" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = "canceled",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( completed ) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + "" )\n\t\t\t.replace( rprotocol, location.protocol + "//" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];\n\n\t\t// A cross-domain request is in order when the origin doesn\'t match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( "a" );\n\n\t\t\t// Support: IE <=8 - 11, Edge 12 - 13\n\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t// e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t// Anchor\'s host property isn\'t correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + "//" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== "string" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( completed ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don\'t fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( "ajaxStart" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we\'re toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\t// Remove hash to simplify url manipulation\n\t\tcacheURL = s.url.replace( rhash, "" );\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// Remember the hash so we can put it back\n\t\t\tuncached = s.url.slice( cacheURL.length );\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;\n\n\t\t\t\t// #9682: remove data so that it\'s not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add or update anti-cache param if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\tcacheURL = cacheURL.replace( rantiCache, "$1" );\n\t\t\t\tuncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;\n\t\t\t}\n\n\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\ts.url = cacheURL + uncached;\n\n\t\t// Change \'%20\' to \'+\' if this is encoded form body content (gh-2658)\n\t\t} else if ( s.data && s.processData &&\n\t\t\t( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {\n\t\t\ts.data = s.data.replace( r20, "+" );\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( "Content-Type", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t"Accept",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :\n\t\t\t\ts.accepts[ "*" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = "abort";\n\n\t\t// Install callbacks on deferreds\n\t\tcompleteDeferred.add( s.complete );\n\t\tjqXHR.done( s.success );\n\t\tjqXHR.fail( s.error );\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, "No Transport" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( "timeout" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcompleted = false;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\tif ( completed ) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\t// Propagate others as results\n\t\t\t\tdone( -1, e );\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Ignore repeat invocations\n\t\t\tif ( completed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcompleted = true;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || "";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( "Last-Modified" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( "etag" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === "HEAD" ) {\n\t\t\t\t\tstatusText = "nocontent";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = "notmodified";\n\n\t\t\t\t// If we have data, let\'s convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = "error";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + "";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( "ajaxStop" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, "json" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, "script" );\n\t}\n} );\n\njQuery.each( [ "get", "post" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\ttype: "GET",\n\t\tdataType: "script",\n\t\tcache: true,\n\t\tasync: false,\n\t\tglobal: false,\n\t\t"throws": true\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( this[ 0 ] ) {\n\t\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t}\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function( selector ) {\n\t\tthis.parent( selector ).not( "body" ).each( function() {\n\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\n\njQuery.expr.pseudos.hidden = function( elem ) {\n\treturn !jQuery.expr.pseudos.visible( elem );\n};\njQuery.expr.pseudos.visible = function( elem ) {\n\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n};\n\n\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n};\n\nvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE <=9 only\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\nsupport.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport( function( options ) {\n\tvar callback, errorCallback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr();\n\n\t\t\t\txhr.open(\n\t\t\t\t\toptions.type,\n\t\t\t\t\toptions.url,\n\t\t\t\t\toptions.async,\n\t\t\t\t\toptions.username,\n\t\t\t\t\toptions.password\n\t\t\t\t);\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won\'t change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {\n\t\t\t\t\theaders[ "X-Requested-With" ] = "XMLHttpRequest";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\tif ( type === "abort" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === "error" ) {\n\n\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== "number" ) {\n\t\t\t\t\t\t\t\t\tcomplete( 0, "error" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t( xhr.responseType || "text" ) !== "text"  ||\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== "string" ?\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\terrorCallback = xhr.onerror = callback( "error" );\n\n\t\t\t\t// Support: IE 9 only\n\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t// to handle uncaught aborts\n\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t} else {\n\t\t\t\t\txhr.onreadystatechange = function() {\n\n\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = callback( "abort" );\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// #14683: Only rethrow if this hasn\'t been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\njQuery.ajaxPrefilter( function( s ) {\n\tif ( s.crossDomain ) {\n\t\ts.contents.script = false;\n\t}\n} );\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: "text/javascript, application/javascript, " +\n\t\t\t"application/ecmascript, application/x-ecmascript"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t"text script": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache\'s special case and crossDomain\njQuery.ajaxPrefilter( "script", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = "GET";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( "script", function( s ) {\n\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( "<script>" ).prop( {\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t} ).on(\n\t\t\t\t\t"load error",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === "error" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: "callback",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t"url" :\n\t\t\ttypeof s.data === "string" &&\n\t\t\t\t( s.contentType || "" )\n\t\t\t\t\t.indexOf( "application/x-www-form-urlencoded" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && "data"\n\t\t);\n\n\t// Handle iff the expected data type is "jsonp" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ "script json" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + " was not called" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// Force json dataType\n\t\ts.dataTypes[ 0 ] = "json";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn\'t exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// Make sure that re-using the options doesn\'t screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// Save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn "script";\n\t}\n} );\n\n\n\n\n// Support: Safari 8 only\n// In Safari 8 documents created via document.implementation.createHTMLDocument\n// collapse sibling forms: the second one becomes a child of the first one.\n// Because of that, this security measure has to be disabled in Safari 8.\n// https://bugs.webkit.org/show_bug.cgi?id=137337\nsupport.createHTMLDocument = ( function() {\n\tvar body = document.implementation.createHTMLDocument( "" ).body;\n\tbody.innerHTML = "<form></form><form></form>";\n\treturn body.childNodes.length === 2;\n} )();\n\n\n// Argument "data" should be string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( typeof data !== "string" ) {\n\t\treturn [];\n\t}\n\tif ( typeof context === "boolean" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\n\tvar base, parsed, scripts;\n\n\tif ( !context ) {\n\n\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t// by using document.implementation\n\t\tif ( support.createHTMLDocument ) {\n\t\t\tcontext = document.implementation.createHTMLDocument( "" );\n\n\t\t\t// Set the base href for the created document\n\t\t\t// so any parsed elements with URLs\n\t\t\t// are based on the document\'s URL (gh-2965)\n\t\t\tbase = context.createElement( "base" );\n\t\t\tbase.href = document.location.href;\n\t\t\tcontext.head.appendChild( base );\n\t\t} else {\n\t\t\tcontext = document;\n\t\t}\n\t}\n\n\tparsed = rsingleTag.exec( data );\n\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( " " );\n\n\tif ( off > -1 ) {\n\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it\'s a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it\'s the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === "object" ) {\n\t\ttype = "POST";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If "type" variable is undefined, then "GET" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || "GET",\n\t\t\tdataType: "html",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE \'Permission Denied\' errors\n\t\t\t\tjQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets "data", "status", "jqXHR"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets "jqXHR", "status", "error"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [\n\t"ajaxStart",\n\t"ajaxStop",\n\t"ajaxComplete",\n\t"ajaxError",\n\t"ajaxSuccess",\n\t"ajaxSend"\n], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.expr.pseudos.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\n/**\n * Gets a window from an element\n */\nfunction getWindow( elem ) {\n\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\n}\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, "position" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === "static" ) {\n\t\t\telem.style.position = "relative";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, "top" );\n\t\tcurCSSLeft = jQuery.css( elem, "left" );\n\t\tcalculatePosition = ( position === "absolute" || position === "fixed" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( "using" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\toffset: function( options ) {\n\n\t\t// Preserve chaining for setter\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar docElem, win, rect, doc,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !elem ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a\n\t\t// disconnected node in IE throws an error\n\t\tif ( !elem.getClientRects().length ) {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t\trect = elem.getBoundingClientRect();\n\n\t\t// Make sure element is not hidden (display: none)\n\t\tif ( rect.width || rect.height ) {\n\t\t\tdoc = elem.ownerDocument;\n\t\t\twin = getWindow( doc );\n\t\t\tdocElem = doc.documentElement;\n\n\t\t\treturn {\n\t\t\t\ttop: rect.top + win.pageYOffset - docElem.clientTop,\n\t\t\t\tleft: rect.left + win.pageXOffset - docElem.clientLeft\n\t\t\t};\n\t\t}\n\n\t\t// Return zeros for disconnected and hidden elements (gh-2310)\n\t\treturn rect;\n\t},\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0},\n\t\t// because it is its only offset parent\n\t\tif ( jQuery.css( elem, "position" ) === "fixed" ) {\n\n\t\t\t// Assume getBoundingClientRect is there when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset = {\n\t\t\t\ttop: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),\n\t\t\t\tleft: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )\n\t\t\t};\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )\n\t\t};\n\t},\n\n\t// This method will return documentElement in the following cases:\n\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t//    documentElement of the parent window\n\t// 2) For the hidden or detached element\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t//\n\t// but those exceptions were never presented as a real life use-cases\n\t// and might be considered as more preferable results.\n\t//\n\t// This logic, however, is not guaranteed and can change at any point in the future\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {\n\tvar top = "pageYOffset" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\t\t\tvar win = getWindow( elem );\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length );\n\t};\n} );\n\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ "top", "left" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + "px" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: "height", Width: "width" }, function( name, type ) {\n\tjQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },\n\t\tfunction( defaultExtra, funcName ) {\n\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\treturn funcName.indexOf( "outer" ) === 0 ?\n\t\t\t\t\t\telem[ "inner" + name ] :\n\t\t\t\t\t\telem.document.documentElement[ "client" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ "scroll" + name ], doc[ "scroll" + name ],\n\t\t\t\t\t\telem.body[ "offset" + name ], doc[ "offset" + name ],\n\t\t\t\t\t\tdoc[ "client" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t};\n\t} );\n} );\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, "**" ) :\n\t\t\tthis.off( types, selector || "**", fn );\n\t}\n} );\n\njQuery.parseJSON = JSON.parse;\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( typeof define === "function" && define.amd ) {\n\tdefine( "jquery", [], function() {\n\t\treturn jQuery;\n\t} );\n}\n\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( !noGlobal ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\n\nreturn jQuery;\n} );\n';
},662:function(t,n){t.exports="(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@angular/core\"), require(\"@angular/forms\"), require(\"@angular/common\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"@angular/core\", \"@angular/forms\", \"@angular/common\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ng2-datetime-picker\"] = factory(require(\"@angular/core\"), require(\"@angular/forms\"), require(\"@angular/common\"));\n\telse\n\t\troot[\"ng2-datetime-picker\"] = factory(root[\"@angular/core\"], root[\"@angular/forms\"], root[\"@angular/common\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t};\n\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t};\n\tvar core_1 = __webpack_require__(1);\n\tvar forms_1 = __webpack_require__(2);\n\tvar common_1 = __webpack_require__(3);\n\tvar datetime_1 = __webpack_require__(4);\n\texports.DateTime = datetime_1.DateTime;\n\tvar datetime_picker_component_1 = __webpack_require__(5);\n\texports.DateTimePickerComponent = datetime_picker_component_1.DateTimePickerComponent;\n\tvar datetime_picker_directive_1 = __webpack_require__(6);\n\texports.DateTimePickerDirective = datetime_picker_directive_1.DateTimePickerDirective;\n\tvar Ng2DatetimePickerModule = (function () {\n\t    function Ng2DatetimePickerModule() {\n\t    }\n\t    Ng2DatetimePickerModule = __decorate([\n\t        core_1.NgModule({\n\t            imports: [common_1.CommonModule, forms_1.FormsModule],\n\t            declarations: [datetime_picker_component_1.DateTimePickerComponent, datetime_picker_directive_1.DateTimePickerDirective],\n\t            exports: [datetime_picker_component_1.DateTimePickerComponent, datetime_picker_directive_1.DateTimePickerDirective],\n\t            entryComponents: [datetime_picker_component_1.DateTimePickerComponent],\n\t            providers: [datetime_1.DateTime]\n\t        }), \n\t        __metadata('design:paramtypes', [])\n\t    ], Ng2DatetimePickerModule);\n\t    return Ng2DatetimePickerModule;\n\t}());\n\texports.Ng2DatetimePickerModule = Ng2DatetimePickerModule;\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t};\n\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t};\n\tvar core_1 = __webpack_require__(1);\n\tvar DateTime = (function () {\n\t    function DateTime() {\n\t        this.initialize();\n\t    }\n\t    DateTime.prototype.initialize = function () {\n\t        this.months = [\n\t            { fullName: 'January', shortName: 'Jan' },\n\t            { fullName: 'February', shortName: 'Feb' },\n\t            { fullName: 'March', shortName: 'Mar' },\n\t            { fullName: 'April', shortName: 'Apr' },\n\t            { fullName: 'May', shortName: 'May' },\n\t            { fullName: 'June', shortName: 'Jun' },\n\t            { fullName: 'July', shortName: 'Jul' },\n\t            { fullName: 'August', shortName: 'Aug' },\n\t            { fullName: 'September', shortName: 'Sep' },\n\t            { fullName: 'October', shortName: 'Oct' },\n\t            { fullName: 'November', shortName: 'Nov' },\n\t            { fullName: 'December', shortName: 'Dec' }\n\t        ];\n\t        this.days = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];\n\t        /**\n\t         * According to International Standard ISO 8601, Monday is the first day of the week\n\t         * followed by Tuesday, Wednesday, Thursday, Friday, Saturday,\n\t         * and with Sunday as the seventh and final day.\n\t         * However, in Javascript Sunday is 0, Monday is 1.. and so on\n\t         */\n\t        this.daysOfWeek = [\n\t            { fullName: 'Sunday', shortName: 'Su', weekend: true },\n\t            { fullName: 'Monday', shortName: 'Mo' },\n\t            { fullName: 'Tuesday', shortName: 'Tu' },\n\t            { fullName: 'Wednesday', shortName: 'We' },\n\t            { fullName: 'Thursday', shortName: 'Th' },\n\t            { fullName: 'Friday', shortName: 'Fr' },\n\t            { fullName: 'Saturday', shortName: 'Sa', weekend: true }\n\t        ];\n\t        /**\n\t         * if momentjs is available, use momentjs localized months, week, etc.\n\t         */\n\t        if (typeof moment !== 'undefined') {\n\t            this.months = this.months.map(function (el, index) {\n\t                el.fullName = moment.months()[index];\n\t                el.shortName = moment.monthsShort()[index];\n\t                return el;\n\t            });\n\t            this.daysOfWeek = this.daysOfWeek.map(function (el, index) {\n\t                el.fullName = moment.weekdays()[index];\n\t                el.shortName = moment.weekdaysShort()[index].substr(0, 2);\n\t                return el;\n\t            });\n\t            this.firstDayOfWeek = moment.localeData().firstDayOfWeek();\n\t        }\n\t        this.firstDayOfWeek = this.firstDayOfWeek || 0;\n\t        this.localizedDaysOfWeek = this.daysOfWeek\n\t            .concat(this.daysOfWeek)\n\t            .splice(this.firstDayOfWeek, 7);\n\t    };\n\t    DateTime.prototype.getMonthData = function (year, month) {\n\t        year = month > 11 ? year + 1 :\n\t            month < 0 ? year - 1 : year;\n\t        month = (month + 12) % 12;\n\t        var firstDayOfMonth = new Date(year, month, 1);\n\t        var lastDayOfMonth = new Date(year, month + 1, 0);\n\t        var lastDayOfPreviousMonth = new Date(year, month, 0);\n\t        var daysInMonth = lastDayOfMonth.getDate();\n\t        var daysInLastMonth = lastDayOfPreviousMonth.getDate();\n\t        var dayOfWeek = firstDayOfMonth.getDay();\n\t        // Ensure there are always leading days to give context\n\t        var leadingDays = (dayOfWeek - this.firstDayOfWeek + 7) % 7 || 7;\n\t        var trailingDays = this.days.slice(0, 6 * 7 - (leadingDays + daysInMonth));\n\t        if (trailingDays.length > 7) {\n\t            trailingDays = trailingDays.slice(0, trailingDays.length - 7);\n\t        }\n\t        var monthData = {\n\t            year: year,\n\t            month: month,\n\t            days: this.days.slice(0, daysInMonth),\n\t            leadingDays: this.days.slice(-leadingDays - (31 - daysInLastMonth), daysInLastMonth),\n\t            trailingDays: trailingDays\n\t        };\n\t        return monthData;\n\t    };\n\t    ;\n\t    DateTime.momentFormatDate = function (d, dateFormat) {\n\t        if (typeof moment === 'undefined') {\n\t            console.error(\"momentjs is required with dateFormat.\\n        please add <script src=\\\"moment.min.js\\\"></script>\\\"> in your html.\");\n\t        }\n\t        return moment(d).format(dateFormat);\n\t    };\n\t    DateTime.momentParse = function (dateStr, dateFormat) {\n\t        if (typeof moment === 'undefined') {\n\t            console.error(\"momentjs is required with dateFormat.\\n        please add <script src=\\\"moment.min.js\\\"></script>\\\"> in your html.\");\n\t        }\n\t        //return moment(dateStr).toDate();\n\t        var date = moment(dateStr, dateFormat).toDate();\n\t        if (isNaN(date.getTime())) {\n\t            date = moment(dateStr).toDate(); //parse as ISO format\n\t        }\n\t        return date;\n\t    };\n\t    DateTime.formatDate = function (d, dateOnly) {\n\t        // return d.toLocaleString('en-us', hash); // IE11 does not understand this\n\t        var pad0 = function (number) {\n\t            return (\"0\" + number).slice(-2);\n\t        };\n\t        var ret = d.getFullYear() + '-' + pad0(d.getMonth() + 1) + '-' + pad0(d.getDate());\n\t        if (!dateOnly) {\n\t            ret += ' ' + pad0(d.getHours()) + ':' + pad0(d.getMinutes());\n\t        }\n\t        return ret;\n\t    };\n\t    //return date as given from given string\n\t    // without considering timezone and day light saving time considered\n\t    DateTime.parse = function (dateStr) {\n\t        dateStr = DateTime.removeTimezone(dateStr);\n\t        dateStr = dateStr + DateTime.addDSTOffset(dateStr);\n\t        return DateTime.getDateFromString(dateStr);\n\t    };\n\t    //remove timezone\n\t    DateTime.removeTimezone = function (dateStr) {\n\t        // if no time is given, add 00:00:00 at the end\n\t        var matches = dateStr.match(/[0-9]{2}:/);\n\t        dateStr += matches ? '' : ' 00:00:00';\n\t        return dateStr.replace(/([0-9]{2}-[0-9]{2})-([0-9]{4})/, '$2-$1') //mm-dd-yyyy to yyyy-mm-dd\n\t            .replace(/([\\/-][0-9]{2,4})\\ ([0-9]{2}\\:[0-9]{2}\\:)/, '$1T$2') //reformat for FF\n\t            .replace(/EDT|EST|CDT|CST|MDT|PDT|PST|UT|GMT/g, '') //remove timezone\n\t            .replace(/\\s*\\(\\)\\s*/, '') //remove timezone\n\t            .replace(/[\\-\\+][0-9]{2}:?[0-9]{2}$/, '') //remove timezone\n\t            .replace(/000Z$/, '00'); //remove timezone\n\t    };\n\t    DateTime.addDSTOffset = function (dateStr) {\n\t        var date = DateTime.getDateFromString(dateStr);\n\t        var jan = new Date(date.getFullYear(), 0, 1);\n\t        var jul = new Date(date.getFullYear(), 6, 1);\n\t        var stdTimezoneOffset = Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());\n\t        var isDST = date.getTimezoneOffset() < stdTimezoneOffset;\n\t        var offset = isDST ? stdTimezoneOffset - 60 : stdTimezoneOffset;\n\t        var diff = offset >= 0 ? '-' : '+';\n\t        offset = Math.abs(offset);\n\t        return diff +\n\t            ('0' + (offset / 60)).slice(-2) + ':' +\n\t            ('0' + (offset % 60)).slice(-2);\n\t    };\n\t    ;\n\t    DateTime.getDateFromString = function (dateStr) {\n\t        var tmp = dateStr.split(/[\\+\\-:\\ T]/); // split by dash, colon or space\n\t        return new Date(parseInt(tmp[0], 10), parseInt(tmp[1], 10) - 1, parseInt(tmp[2], 10), parseInt(tmp[3] || '0', 10), parseInt(tmp[4] || '0', 10), parseInt(tmp[5] || '0', 10));\n\t    };\n\t    DateTime = __decorate([\n\t        core_1.Injectable(), \n\t        __metadata('design:paramtypes', [])\n\t    ], DateTime);\n\t    return DateTime;\n\t}());\n\texports.DateTime = DateTime;\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t};\n\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t};\n\tvar core_1 = __webpack_require__(1);\n\tvar datetime_1 = __webpack_require__(4);\n\t//@TODO\n\t// . display currently selected day\n\t/**\n\t * show a selected date in monthly calendar\n\t */\n\tvar DateTimePickerComponent = (function () {\n\t    function DateTimePickerComponent(elementRef, dateTime, cdRef) {\n\t        this.dateTime = dateTime;\n\t        this.cdRef = cdRef;\n\t        this.changes = new core_1.EventEmitter();\n\t        this.closing = new core_1.EventEmitter();\n\t        this.el = elementRef.nativeElement;\n\t    }\n\t    DateTimePickerComponent.prototype.ngAfterViewInit = function () {\n\t        if (!this.dateOnly) {\n\t            this._hours.nativeElement.addEventListener('keyup', function (e) {\n\t                e.stopPropagation();\n\t            });\n\t            this._hours.nativeElement.addEventListener('mousedown', function (e) {\n\t                e.stopPropagation();\n\t            });\n\t            this._minutes.nativeElement.addEventListener('keyup', function (e) {\n\t                e.stopPropagation();\n\t            });\n\t            this._minutes.nativeElement.addEventListener('mousedown', function (e) {\n\t                e.stopPropagation();\n\t            });\n\t        }\n\t    };\n\t    Object.defineProperty(DateTimePickerComponent.prototype, \"year\", {\n\t        get: function () {\n\t            return this.selectedDate.getFullYear();\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(DateTimePickerComponent.prototype, \"month\", {\n\t        get: function () {\n\t            return this.selectedDate.getMonth();\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(DateTimePickerComponent.prototype, \"day\", {\n\t        get: function () {\n\t            return this.selectedDate.getDate();\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(DateTimePickerComponent.prototype, \"today\", {\n\t        get: function () {\n\t            var dt = new Date();\n\t            dt.setHours(0);\n\t            dt.setMinutes(0);\n\t            dt.setSeconds(0);\n\t            dt.setMilliseconds(0);\n\t            return dt;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    DateTimePickerComponent.prototype.initDateTime = function (date) {\n\t        date = date || new Date();\n\t        this.selectedDate = date;\n\t        this.hour = this.selectedDate.getHours();\n\t        this.minute = this.selectedDate.getMinutes();\n\t        this.monthData = this.dateTime.getMonthData(this.year, this.month);\n\t    };\n\t    DateTimePickerComponent.prototype.toDate = function (year, month, day) {\n\t        return new Date(year, month, day);\n\t    };\n\t    DateTimePickerComponent.prototype.toDateOnly = function (date) {\n\t        return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0);\n\t    };\n\t    /**\n\t     * set the selected date and close it when closeOnSelect is true\n\t     * @param date {Date}\n\t     */\n\t    DateTimePickerComponent.prototype.selectDate = function (dayNum) {\n\t        if (dayNum) {\n\t            this.selectedDate = new Date(this.monthData.year, this.monthData.month, dayNum);\n\t        }\n\t        this.selectedDate.setHours(parseInt('' + this.hour || '0', 10));\n\t        this.selectedDate.setMinutes(parseInt('' + this.minute || '0', 10));\n\t        this.changes.emit(this.selectedDate);\n\t        this.closing.emit(true);\n\t    };\n\t    ;\n\t    /**\n\t     * show prev/next month calendar\n\t     */\n\t    DateTimePickerComponent.prototype.updateMonthData = function (num) {\n\t        this.monthData = this.dateTime.getMonthData(this.monthData.year, this.monthData.month + num);\n\t    };\n\t    __decorate([\n\t        core_1.ViewChild('hours'), \n\t        __metadata('design:type', core_1.ElementRef)\n\t    ], DateTimePickerComponent.prototype, \"_hours\", void 0);\n\t    __decorate([\n\t        core_1.ViewChild('minutes'), \n\t        __metadata('design:type', core_1.ElementRef)\n\t    ], DateTimePickerComponent.prototype, \"_minutes\", void 0);\n\t    DateTimePickerComponent = __decorate([\n\t        core_1.Component({\n\t            providers: [datetime_1.DateTime],\n\t            selector: 'datetime-picker',\n\t            template: \"\\n<div class=\\\"datetime-picker\\\" tabindex=\\\"0\\\">\\n\\n  <!-- Month - Year  -->\\n  <div class=\\\"month\\\">\\n    <button type=\\\"button\\\" class=\\\"prev\\\" (click)=\\\"updateMonthData(-1)\\\">&laquo;</button>\\n     <span title=\\\"{{dateTime.months[monthData.month]?.fullName}}\\\">\\n           {{dateTime.months[monthData.month]?.shortName}}\\n     </span>\\n    {{monthData.year}}\\n    <button type=\\\"button\\\" class=\\\"next\\\" (click)=\\\"updateMonthData(+1)\\\">&raquo;</button>\\n  </div>\\n\\n  <div class=\\\"days\\\">\\n\\n    <!-- Su Mo Tu We Th Fr Sa -->\\n    <div class=\\\"day-of-week\\\"\\n         *ngFor=\\\"let dayOfWeek of dateTime.localizedDaysOfWeek\\\"\\n         [ngClass]=\\\"{weekend: dayOfWeek.weekend}\\\"\\n         title=\\\"{{dayOfWeek.fullName}}\\\">\\n      {{dayOfWeek.shortName}}\\n    </div>\\n\\n    <!-- Fill up blank days for this month -->\\n    <div *ngIf=\\\"monthData.leadingDays.length < 7\\\">\\n      <div class=\\\"day\\\" *ngFor=\\\"let dayNum of monthData.leadingDays\\\"\\n           [ngClass]=\\\"{weekend: [0,6].indexOf(toDate(monthData.year, monthData.month-1, dayNum).getDay()) !== -1}\\\">\\n        {{dayNum}}\\n      </div>\\n    </div>\\n\\n    <div class=\\\"day selectable\\\"\\n         *ngFor=\\\"let dayNum of monthData.days\\\"\\n         (click)=\\\"selectDate(dayNum)\\\"\\n         title=\\\"{{monthData.year}}-{{monthData.month+1}}-{{dayNum}}\\\"\\n         [ngClass]=\\\"{\\n           selected:\\n             toDate(monthData.year, monthData.month, dayNum).getTime() === toDateOnly(selectedDate).getTime(),\\n           today:\\n             toDate(monthData.year, monthData.month, dayNum).getTime() === today.getTime(),\\n           weekend:\\n             [0,6].indexOf(toDate(monthData.year, monthData.month, dayNum).getDay()) !== -1\\n         }\\\">\\n      {{dayNum}}\\n    </div>\\n\\n    <!-- Fill up blank days for this month -->\\n    <div *ngIf=\\\"monthData.trailingDays.length < 7\\\">\\n      <div class=\\\"day\\\"\\n           *ngFor=\\\"let dayNum of monthData.trailingDays\\\"\\n           [ngClass]=\\\"{weekend: [0,6].indexOf(toDate(monthData.year, monthData.month+1, dayNum).getDay()) !== -1}\\\">\\n        {{dayNum}}\\n      </div>\\n    </div>\\n  </div>\\n\\n  <!-- Time -->\\n  <div class=\\\"days\\\" id=\\\"time\\\" *ngIf=\\\"!dateOnly\\\">\\n    <label class=\\\"timeLabel\\\">Time:</label>\\n    <span class=\\\"timeValue\\\">\\n      {{(\\\"0\\\"+hour).slice(-2)}} : {{(\\\"0\\\"+minute).slice(-2)}}\\n    </span><br/>\\n    <label class=\\\"hourLabel\\\">Hour:</label>\\n    <input #hours class=\\\"hourInput\\\"\\n           (change)=\\\"selectDate()\\\"\\n           type=\\\"range\\\" min=\\\"0\\\" max=\\\"23\\\" [(ngModel)]=\\\"hour\\\" />\\n    <label class=\\\"minutesLabel\\\">Min:</label>\\n    <input #minutes class=\\\"minutesInput\\\"\\n           (change)=\\\"selectDate()\\\"\\n           type=\\\"range\\\" min=\\\"0\\\" max=\\\"59\\\" range=\\\"10\\\" [(ngModel)]=\\\"minute\\\"/>\\n  </div>\\n</div>\\n\\n<!--<hr/>-->\\n<!--Date: {{selectedDate}}<br/>-->\\n<!--Hour: {{hour}} Minute: {{minute}}<br/>-->\\n  \",\n\t            styles: [\n\t                \"\\n @keyframes slideDown {\\n  0% {\\n    transform:  translateY(-10px);\\n  }\\n  100% {\\n    transform: translateY(0px);\\n  }\\n}\\n\\n.ng2-datetime-picker {\\n    display: inline-block;\\n    position: relative;\\n}\\n\\n.datetime-picker {\\n    color: #333;\\n    outline-width: 0;\\n    font: normal 14px sans-serif;\\n    border: 1px solid #ddd;\\n    display: inline-block;\\n    background: #fff;\\n    animation: slideDown 0.1s ease-in-out;\\n    animation-fill-mode: both;\\n}\\n.datetime-picker > .month {\\n    text-align: center;\\n    line-height: 22px;\\n    padding: 10px;\\n    background: #fcfcfc;\\n    text-transform: uppercase;\\n    font-weight: bold;\\n    border-bottom: 1px solid #ddd;\\n    position: relative;\\n}\\n.datetime-picker > .month > button {\\n    color: #555;\\n    font: normal 14px sans-serif;\\n    outline: none;\\n    position: absolute;\\n    background: transparent;\\n    border: none;\\n    cursor: pointer;\\n}\\n.datetime-picker > .month > button:hover {\\n    color: #333;\\n}\\n.datetime-picker > .month > button.prev {\\n    left: 10px;\\n}\\n.datetime-picker > .month > button.next {\\n    right: 10px;\\n}\\n.datetime-picker > .days {\\n    width: 210px; /* 30 x 7 */\\n    margin: 10px;\\n    text-align: center;\\n}\\n.datetime-picker > .days .day-of-week,\\n.datetime-picker > .days .day {\\n    box-sizing: border-box;\\n    -moz-box-sizing: border-box;\\n    border: 1px solid transparent;\\n    width: 30px;\\n    line-height: 28px;\\n    float: left;\\n}\\n.datetime-picker > .days .day-of-week {\\n    font-weight: bold;\\n}\\n.datetime-picker > .days .day-of-week.weekend {\\n    color: #ccc;\\n    background-color: inherit;\\n}\\n.datetime-picker > .days .day:not(.selectable) {\\n    color: #ccc;\\n    cursor: default;\\n}\\n.datetime-picker > .days .weekend {\\n    color: #ccc;\\n    background-color: #eee;\\n}\\n.datetime-picker > .days .day.selectable  {\\n    cursor: pointer;\\n}\\n.datetime-picker > .days .day.selected {\\n    background: gray;\\n    color: #fff;\\n}\\n.datetime-picker > .days .day:not(.selected).selectable:hover {\\n    background: #eee;\\n}\\n.datetime-picker > .days:after {\\n    content: '';\\n    display: block;\\n    clear: left;\\n    height: 0;\\n}\\n.datetime-picker .hourLabel,\\n.datetime-picker .minutesLabel {\\n    display: inline-block;\\n    width: 40px;\\n    text-align: right;\\n}\\n.datetime-picker input[type=range] {\\n    width: 150px;\\n}\\n  \"\n\t            ],\n\t            encapsulation: core_1.ViewEncapsulation.None\n\t        }), \n\t        __metadata('design:paramtypes', [core_1.ElementRef, datetime_1.DateTime, core_1.ChangeDetectorRef])\n\t    ], DateTimePickerComponent);\n\t    return DateTimePickerComponent;\n\t}());\n\texports.DateTimePickerComponent = DateTimePickerComponent;\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t};\n\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t};\n\tvar __param = (this && this.__param) || function (paramIndex, decorator) {\n\t    return function (target, key) { decorator(target, key, paramIndex); }\n\t};\n\tvar core_1 = __webpack_require__(1);\n\tvar forms_1 = __webpack_require__(2);\n\tvar datetime_picker_component_1 = __webpack_require__(5);\n\tvar datetime_1 = __webpack_require__(4);\n\t/**\n\t * If the given string is not a valid date, it defaults back to today\n\t */\n\tvar DateTimePickerDirective = (function () {\n\t    function DateTimePickerDirective(resolver, viewContainerRef, parent) {\n\t        var _this = this;\n\t        this.resolver = resolver;\n\t        this.viewContainerRef = viewContainerRef;\n\t        this.parent = parent;\n\t        this.ngModelChange = new core_1.EventEmitter();\n\t        /* input element string value is changed */\n\t        this.valueChanged = function (date) {\n\t            _this.setElement(date);\n\t            _this.el.value = _this.getFormattedDateStr();\n\t            if (_this.ctrl) {\n\t                _this.ctrl.patchValue(_this.el.value);\n\t            }\n\t            _this.ngModel = _this.el['dateValue'];\n\t            if (_this.ngModel) {\n\t                _this.ngModel.toString = function () { return _this.el.value; };\n\t                _this.ngModelChange.emit(_this.ngModel);\n\t            }\n\t        };\n\t        this.hideDatetimePicker = function (event) {\n\t            if (_this.componentRef) {\n\t                if (event &&\n\t                    event.type === 'click' &&\n\t                    event.target !== _this.el &&\n\t                    !_this.elementIn(event.target, _this.datetimePickerEl)) {\n\t                    _this.componentRef.destroy();\n\t                    _this.componentRef = undefined;\n\t                }\n\t                else if (!event) {\n\t                    _this.componentRef.destroy();\n\t                    _this.componentRef = undefined;\n\t                }\n\t            }\n\t            event && event.stopPropagation();\n\t        };\n\t        this.keyEventListener = function (e) {\n\t            if (e.keyCode === 27 || e.keyCode === 9 || e.keyCode === 13) {\n\t                if (!_this.justShown) {\n\t                    _this.hideDatetimePicker();\n\t                }\n\t            }\n\t        };\n\t        this.el = this.viewContainerRef.element.nativeElement;\n\t    }\n\t    DateTimePickerDirective.prototype.ngOnInit = function () {\n\t        var _this = this;\n\t        if (this.parent && this.parent[\"form\"] && this.formControlName) {\n\t            this.ctrl = this.parent[\"form\"].get(this.formControlName);\n\t            this.sub = this.ctrl.valueChanges.subscribe(function (date) {\n\t                _this.setElement(date);\n\t                _this.updateDatepicker();\n\t            });\n\t        }\n\t        //wrap this element with a <div> tag, so that we can position dynamic elememnt correctly\n\t        var wrapper = document.createElement(\"div\");\n\t        wrapper.className = 'ng2-datetime-picker';\n\t        this.el.parentElement.insertBefore(wrapper, this.el.nextSibling);\n\t        wrapper.appendChild(this.el);\n\t        // add a click listener to document, so that it can hide when others clicked\n\t        document.body.addEventListener('click', this.hideDatetimePicker);\n\t        this.el.addEventListener('keyup', this.keyEventListener);\n\t        setTimeout(function () {\n\t            _this.valueChanged(_this.el.value);\n\t            if (_this.ctrl) {\n\t                _this.ctrl.markAsPristine();\n\t            }\n\t        });\n\t    };\n\t    DateTimePickerDirective.prototype.ngOnChanges = function (changes) {\n\t        var date;\n\t        if (changes && changes['ngModel']) {\n\t            date = changes['ngModel'].currentValue;\n\t        }\n\t        this.setElement(date);\n\t        this.updateDatepicker();\n\t    };\n\t    DateTimePickerDirective.prototype.updateDatepicker = function () {\n\t        if (this.componentRef) {\n\t            var component = this.componentRef.instance;\n\t            component.initDateTime(this.el['dateValue']);\n\t        }\n\t    };\n\t    DateTimePickerDirective.prototype.setElement = function (date) {\n\t        if (typeof date === 'string' && date) {\n\t            this.el['dateValue'] = this.getDate(date);\n\t        }\n\t        else if (typeof date === 'object') {\n\t            this.el['dateValue'] = date;\n\t        }\n\t        else if (typeof date === 'undefined') {\n\t            this.el['dateValue'] = null;\n\t        }\n\t        if (this.ctrl) {\n\t            this.ctrl.markAsDirty();\n\t        }\n\t    };\n\t    DateTimePickerDirective.prototype.ngOnDestroy = function () {\n\t        if (this.sub) {\n\t            this.sub.unsubscribe();\n\t        }\n\t        document.body.removeEventListener('click', this.hideDatetimePicker);\n\t    };\n\t    //show datetimePicker element below the current element\n\t    DateTimePickerDirective.prototype.showDatetimePicker = function (event) {\n\t        var _this = this;\n\t        if (this.componentRef) {\n\t            return;\n\t        }\n\t        var factory = this.resolver.resolveComponentFactory(datetime_picker_component_1.DateTimePickerComponent);\n\t        this.componentRef = this.viewContainerRef.createComponent(factory);\n\t        this.datetimePickerEl = this.componentRef.location.nativeElement;\n\t        this.datetimePickerEl.addEventListener('keyup', this.keyEventListener);\n\t        var component = this.componentRef.instance;\n\t        component.initDateTime(this.el['dateValue']);\n\t        component.dateOnly = this.dateOnly;\n\t        this.styleDatetimePicker();\n\t        component.changes.subscribe(this.valueChanged);\n\t        component.closing.subscribe(function () {\n\t            _this.closeOnSelect !== \"false\" && _this.hideDatetimePicker();\n\t        });\n\t        //Hack not to fire tab keyup event\n\t        this.justShown = true;\n\t        setTimeout(function () { return _this.justShown = false; }, 100);\n\t    };\n\t    DateTimePickerDirective.prototype.elementIn = function (el, containerEl) {\n\t        while (el = el.parentNode) {\n\t            if (el === containerEl)\n\t                return true;\n\t        }\n\t        return false;\n\t    };\n\t    DateTimePickerDirective.prototype.styleDatetimePicker = function () {\n\t        var _this = this;\n\t        // setting position, width, and height of auto complete dropdown\n\t        var thisElBCR = this.el.getBoundingClientRect();\n\t        this.datetimePickerEl.style.width = thisElBCR.width + 'px';\n\t        this.datetimePickerEl.style.position = 'absolute';\n\t        this.datetimePickerEl.style.zIndex = '1000';\n\t        this.datetimePickerEl.style.left = '0';\n\t        this.datetimePickerEl.style.transition = 'height 0.3s ease-in';\n\t        this.datetimePickerEl.style.visibility = 'hidden';\n\t        setTimeout(function () {\n\t            var thisElBcr = _this.el.getBoundingClientRect();\n\t            var datetimePickerElBcr = _this.datetimePickerEl.getBoundingClientRect();\n\t            if (thisElBcr.bottom + datetimePickerElBcr.height > window.innerHeight) {\n\t                _this.datetimePickerEl.style.bottom =\n\t                    (thisElBcr.bottom - window.innerHeight + 15) + 'px';\n\t            }\n\t            else {\n\t                // otherwise, show below\n\t                _this.datetimePickerEl.style.top = thisElBcr.height + 'px';\n\t            }\n\t            _this.datetimePickerEl.style.visibility = 'visible';\n\t        });\n\t    };\n\t    ;\n\t    /**\n\t     *  returns toString function of date object\n\t     */\n\t    DateTimePickerDirective.prototype.getFormattedDateStr = function () {\n\t        if (this.el['dateValue']) {\n\t            if (this.dateFormat) {\n\t                return datetime_1.DateTime.momentFormatDate(this.el['dateValue'], this.dateFormat);\n\t            }\n\t            else {\n\t                return datetime_1.DateTime.formatDate(this.el['dateValue'], this.dateOnly);\n\t            }\n\t        }\n\t        else {\n\t            return null;\n\t        }\n\t    };\n\t    DateTimePickerDirective.prototype.getDate = function (arg) {\n\t        var date;\n\t        if (typeof arg === 'string') {\n\t            if (this.dateFormat) {\n\t                date = datetime_1.DateTime.momentParse(arg, this.dateFormat);\n\t            }\n\t            else {\n\t                //remove timezone and respect day light saving time\n\t                date = datetime_1.DateTime.parse(arg);\n\t            }\n\t        }\n\t        else {\n\t            date = arg;\n\t        }\n\t        return date;\n\t    };\n\t    __decorate([\n\t        core_1.Input('date-format'), \n\t        __metadata('design:type', String)\n\t    ], DateTimePickerDirective.prototype, \"dateFormat\", void 0);\n\t    __decorate([\n\t        core_1.Input('date-only'), \n\t        __metadata('design:type', Boolean)\n\t    ], DateTimePickerDirective.prototype, \"dateOnly\", void 0);\n\t    __decorate([\n\t        core_1.Input('close-on-select'), \n\t        __metadata('design:type', String)\n\t    ], DateTimePickerDirective.prototype, \"closeOnSelect\", void 0);\n\t    __decorate([\n\t        core_1.Input(), \n\t        __metadata('design:type', String)\n\t    ], DateTimePickerDirective.prototype, \"formControlName\", void 0);\n\t    __decorate([\n\t        core_1.Input('ngModel'), \n\t        __metadata('design:type', Object)\n\t    ], DateTimePickerDirective.prototype, \"ngModel\", void 0);\n\t    __decorate([\n\t        core_1.Output('ngModelChange'), \n\t        __metadata('design:type', Object)\n\t    ], DateTimePickerDirective.prototype, \"ngModelChange\", void 0);\n\t    DateTimePickerDirective = __decorate([\n\t        core_1.Directive({\n\t            selector: '[datetime-picker], [ng2-datetime-picker]',\n\t            providers: [datetime_1.DateTime],\n\t            host: {\n\t                '(click)': 'showDatetimePicker()',\n\t                '(focus)': 'showDatetimePicker()'\n\t            }\n\t        }),\n\t        __param(2, core_1.Optional()),\n\t        __param(2, core_1.Host()),\n\t        __param(2, core_1.SkipSelf()), \n\t        __metadata('design:paramtypes', [core_1.ComponentFactoryResolver, core_1.ViewContainerRef, forms_1.ControlContainer])\n\t    ], DateTimePickerDirective);\n\t    return DateTimePickerDirective;\n\t}());\n\texports.DateTimePickerDirective = DateTimePickerDirective;\n\n\n/***/ }\n/******/ ])\n});\n;\n//# sourceMappingURL=ng2-datetime-picker.umd.js.map";
},682:function(t,n,e){e(375),e(372),e(376),e(374),t.exports=e(373)}},[682]);
//# sourceMappingURL=scripts.91ac9184e69f0a27fa79.bundle.map